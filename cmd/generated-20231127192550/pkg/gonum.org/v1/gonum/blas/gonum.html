<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Package: gonum.org/v1/gonum/blas/gonum</title>
<link href="../../../../../css/auto-v0.6.7.css" rel="stylesheet">
<script src="../../../../../jvs/golds-v0.6.7.js"></script>
<body onload="onPageLoad()"><div>

<pre id="package-details"><code><span style="font-size:xx-large;">package <b>gonum</b></span>

<span class="title">Import Path</span>
	<a href="../../../../../index.html#pkg-gonum.org/v1/gonum/blas/gonum">gonum.org/v1/gonum/blas/gonum</a><i> (on <a href="https://pkg.go.dev/gonum.org/v1/gonum/blas/gonum" target="_blank">go.dev</a>)</i>

<span class="title">Dependency Relation</span>
	imports <a href="../../../../../dep/gonum.org/v1/gonum/blas/gonum.html">11 packages</a>, and imported by <a href="../../../../../dep/gonum.org/v1/gonum/blas/gonum.html#imported-by">2 packages</a>

<div id="files"><span class="title">Involved Source Files</span>

	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/dgemm.go.html">dgemm.go</a></span>
	<input type='checkbox' checked class="fold" id="file-1-fold-content"><label for="file-1-fold-content">  <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/doc.go.html#doc">d</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/doc.go.html">doc.go</a></label><span id='file-1-fold-content-items' class="fold-items">
<span class="md-text">		Package gonum is a Go implementation of the BLAS API. This implementation
		panics when the input arguments are invalid as per the standard, for example
		if a vector increment is zero. Note that the treatment of NaN values
		is not specified, and differs among the BLAS implementations.
		gonum.org/v1/gonum/blas/blas64 provides helpful wrapper functions to the BLAS
		interface. The rest of this text describes the layout of the data for the input types.
		
		Note that in the function documentation, x[i] refers to the i^th element
		of the vector, which will be different from the i^th element of the slice if
		incX != 1.
		
		See http://www.netlib.org/lapack/explore-html/d4/de1/_l_i_c_e_n_s_e_source.html
		for more license information.
		
		Vector arguments are effectively strided slices. They have two input arguments,
		a number of elements, n, and an increment, incX. The increment specifies the
		distance between elements of the vector. The actual Go slice may be longer
		than necessary.
		The increment may be positive or negative, except in functions with only
		a single vector argument where the increment may only be positive. If the increment
		is negative, s[0] is the last element in the slice. Note that this is not the same
		as counting backward from the end of the slice, as len(s) may be longer than
		necessary. So, for example, if n = 5 and incX = 3, the elements of s are
		
			[0 * * 1 * * 2 * * 3 * * 4 * * * ...]
		
		where ∗ elements are never accessed. If incX = -3, the same elements are
		accessed, just in reverse order (4, 3, 2, 1, 0).
		
		Dense matrices are specified by a number of rows, a number of columns, and a stride.
		The stride specifies the number of entries in the slice between the first element
		of successive rows. The stride must be at least as large as the number of columns
		but may be longer.
		
			[a00 ... a0n a0* ... a1stride-1 a21 ... amn am* ... amstride-1]
		
		Thus, dense[i*ld + j] refers to the {i, j}th element of the matrix.
		
		Symmetric and triangular matrices (non-packed) are stored identically to Dense,
		except that only elements in one triangle of the matrix are accessed.
		
		Packed symmetric and packed triangular matrices are laid out with the entries
		condensed such that all of the unreferenced elements are removed. So, the upper triangular
		matrix
		
			[
			  1  2  3
			  0  4  5
			  0  0  6
			]
		
		and the lower-triangular matrix
		
			[
			  1  0  0
			  2  3  0
			  4  5  6
			]
		
		will both be compacted as [1 2 3 4 5 6]. The (i, j) element of the original
		dense matrix can be found at element i*n - (i-1)*i/2 + j for upper triangular,
		and at element i * (i+1) /2 + j for lower triangular.
		
		Banded matrices are laid out in a compact format, constructed by removing the
		zeros in the rows and aligning the diagonals. For example, the matrix
		
			[
			  1  2  3  0  0  0
			  4  5  6  7  0  0
			  0  8  9 10 11  0
			  0  0 12 13 14 15
			  0  0  0 16 17 18
			  0  0  0  0 19 20
			]
		
		implicitly becomes (∗ entries are never accessed)
		
			[
			   *  1  2  3
			   4  5  6  7
			   8  9 10 11
			  12 13 14 15
			  16 17 18  *
			  19 20  *  *
			]
		
		which is given to the BLAS routine as [∗ 1 2 3 4 ...].
		
		See http://www.crest.iu.edu/research/mtl/reference/html/banded.html
		for more information</span>
</span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html">errors.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/gonum.go.html">gonum.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx128.go.html">level1cmplx128.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx64.go.html">level1cmplx64.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32.go.html">level1float32.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32_dsdot.go.html">level1float32_dsdot.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32_sdot.go.html">level1float32_sdot.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32_sdsdot.go.html">level1float32_sdsdot.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64.go.html">level1float64.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64_ddot.go.html">level1float64_ddot.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html">level2cmplx128.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html">level2cmplx64.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html">level2float32.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html">level2float64.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx128.go.html">level3cmplx128.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx64.go.html">level3cmplx64.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3float32.go.html">level3float32.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3float64.go.html">level3float64.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/sgemm.go.html">sgemm.go</a></span></div>
<div id="exported-types"><span class="title">Package-Level Type Names<span class="title-stat"><i> (only one, which is exported)</i></span></span>

<div id="exported-types-buttons" class="js-on">	/* sort exporteds by: <label id="sort-types-by-alphabet" class="button">alphabet</label> | <label id="sort-types-by-popularity" class="button">popularity</label> */</div><div class="anchor type-res" id="name-Implementation" data-popularity="7900">	<input type='checkbox' class="fold" id="Implementation-fold-content"><label for="Implementation-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..Implementation.html">type</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/gonum.go.html#line-15">Implementation</a> <i>(struct)</i></label><span id='Implementation-fold-content-docs' class="fold-docs">

		<input type='checkbox' class="fold" id="Implementation-fold-methods"><label for="Implementation-fold-methods">Methods (<i>total 142, all are exported</i>)</label><span id='Implementation-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Caxpy"><label for="Implementation-fold-method-Caxpy">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx64.go.html#line-183">Caxpy</a>(n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Caxpy-docs' class="fold-docs">
<span class="md-text">				Caxpy adds alpha times x to y:
				
					y[i] += alpha * x[i] for all i
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ccopy"><label for="Implementation-fold-method-Ccopy">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx64.go.html#line-222">Ccopy</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ccopy-docs' class="fold-docs">
<span class="md-text">				Ccopy copies the vector x to vector y.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cdotc"><label for="Implementation-fold-method-Cdotc">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx64.go.html#line-266">Cdotc</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-complex64">complex64</a></label><span id='Implementation-fold-method-Cdotc-docs' class="fold-docs">
<span class="md-text">				Cdotc computes the dot product
				
					xᴴ · y
				
				of two complex vectors x and y.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cdotu"><label for="Implementation-fold-method-Cdotu">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx64.go.html#line-311">Cdotu</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-complex64">complex64</a></label><span id='Implementation-fold-method-Cdotu-docs' class="fold-docs">
<span class="md-text">				Cdotu computes the dot product
				
					xᵀ · y
				
				of two complex vectors x and y.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cgbmv"><label for="Implementation-fold-method-Cgbmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-28">Cgbmv</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, kL, kU <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex64">complex64</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Cgbmv-docs' class="fold-docs">
<span class="md-text">				Cgbmv performs one of the matrix-vector operations
				
					y = alpha * A * x + beta * y   if trans = blas.NoTrans
					y = alpha * Aᵀ * x + beta * y  if trans = blas.Trans
					y = alpha * Aᴴ * x + beta * y  if trans = blas.ConjTrans
				
				where alpha and beta are scalars, x and y are vectors, and A is an m×n band matrix
				with kL sub-diagonals and kU super-diagonals.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cgemm"><label for="Implementation-fold-method-Cgemm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx64.go.html#line-30">Cgemm</a>(tA, tB <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex64">complex64</a>, c []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Cgemm-docs' class="fold-docs">
<span class="md-text">				Cgemm performs one of the matrix-matrix operations
				
					C = alpha * op(A) * op(B) + beta * C
				
				where op(X) is one of
				
					op(X) = X  or  op(X) = Xᵀ  or  op(X) = Xᴴ,
				
				alpha and beta are scalars, and A, B and C are matrices, with op(A) an m×k matrix,
				op(B) a k×n matrix and C an m×n matrix.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cgemv"><label for="Implementation-fold-method-Cgemv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-226">Cgemv</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex64">complex64</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Cgemv-docs' class="fold-docs">
<span class="md-text">				Cgemv performs one of the matrix-vector operations
				
					y = alpha * A * x + beta * y   if trans = blas.NoTrans
					y = alpha * Aᵀ * x + beta * y  if trans = blas.Trans
					y = alpha * Aᴴ * x + beta * y  if trans = blas.ConjTrans
				
				where alpha and beta are scalars, x and y are vectors, and A is an m×n dense matrix.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cgerc"><label for="Implementation-fold-method-Cgerc">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-384">Cgerc</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Cgerc-docs' class="fold-docs">
<span class="md-text">				Cgerc performs the rank-one operation
				
					A += alpha * x * yᴴ
				
				where A is an m×n dense matrix, alpha is a scalar, x is an m element vector,
				and y is an n element vector.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cgeru"><label for="Implementation-fold-method-Cgeru">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-446">Cgeru</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Cgeru-docs' class="fold-docs">
<span class="md-text">				Cgeru performs the rank-one operation
				
					A += alpha * x * yᵀ
				
				where A is an m×n dense matrix, alpha is a scalar, x is an m element vector,
				and y is an n element vector.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Chbmv"><label for="Implementation-fold-method-Chbmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-520">Chbmv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex64">complex64</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Chbmv-docs' class="fold-docs">
<span class="md-text">				Chbmv performs the matrix-vector operation
				
					y = alpha * A * x + beta * y
				
				where alpha and beta are scalars, x and y are vectors, and A is an n×n
				Hermitian band matrix with k super-diagonals. The imaginary parts of
				the diagonal elements of A are ignored and assumed to be zero.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Chemm"><label for="Implementation-fold-method-Chemm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx64.go.html#line-278">Chemm</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex64">complex64</a>, c []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Chemm-docs' class="fold-docs">
<span class="md-text">				Chemm performs one of the matrix-matrix operations
				
					C = alpha*A*B + beta*C  if side == blas.Left
					C = alpha*B*A + beta*C  if side == blas.Right
				
				where alpha and beta are scalars, A is an m×m or n×n hermitian matrix and B
				and C are m×n matrices. The imaginary parts of the diagonal elements of A are
				assumed to be zero.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Chemv"><label for="Implementation-fold-method-Chemv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-695">Chemv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex64">complex64</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Chemv-docs' class="fold-docs">
<span class="md-text">				Chemv performs the matrix-vector operation
				
					y = alpha * A * x + beta * y
				
				where alpha and beta are scalars, x and y are vectors, and A is an n×n
				Hermitian matrix. The imaginary parts of the diagonal elements of A are
				ignored and assumed to be zero.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cher"><label for="Implementation-fold-method-Cher">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-859">Cher</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Cher-docs' class="fold-docs">
<span class="md-text">				Cher performs the Hermitian rank-one operation
				
					A += alpha * x * xᴴ
				
				where A is an n×n Hermitian matrix, alpha is a real scalar, and x is an n
				element vector. On entry, the imaginary parts of the diagonal elements of A
				are ignored and assumed to be zero, on return they will be set to zero.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cher2"><label for="Implementation-fold-method-Cher2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-985">Cher2</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Cher2-docs' class="fold-docs">
<span class="md-text">				Cher2 performs the Hermitian rank-two operation
				
					A += alpha * x * yᴴ + conj(alpha) * y * xᴴ
				
				where alpha is a scalar, x and y are n element vectors and A is an n×n
				Hermitian matrix. On entry, the imaginary parts of the diagonal elements are
				ignored and assumed to be zero. On return they will be set to zero.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cher2k"><label for="Implementation-fold-method-Cher2k">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx64.go.html#line-633">Cher2k</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float32">float32</a>, c []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Cher2k-docs' class="fold-docs">
<span class="md-text">				Cher2k performs one of the hermitian rank-2k operations
				
					C = alpha*A*Bᴴ + conj(alpha)*B*Aᴴ + beta*C  if trans == blas.NoTrans
					C = alpha*Aᴴ*B + conj(alpha)*Bᴴ*A + beta*C  if trans == blas.ConjTrans
				
				where alpha and beta are scalars with beta real, C is an n×n hermitian matrix
				and A and B are n×k matrices in the first case and k×n matrices in the second case.
				
				The imaginary parts of the diagonal elements of C are assumed to be zero, and
				on return they will be set to zero.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cherk"><label for="Implementation-fold-method-Cherk">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx64.go.html#line-431">Cherk</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float32">float32</a>, c []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Cherk-docs' class="fold-docs">
<span class="md-text">				Cherk performs one of the hermitian rank-k operations
				
					C = alpha*A*Aᴴ + beta*C  if trans == blas.NoTrans
					C = alpha*Aᴴ*A + beta*C  if trans == blas.ConjTrans
				
				where alpha and beta are real scalars, C is an n×n hermitian matrix and A is
				an n×k matrix in the first case and a k×n matrix in the second case.
				
				The imaginary parts of the diagonal elements of C are assumed to be zero, and
				on return they will be set to zero.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Chpmv"><label for="Implementation-fold-method-Chpmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-1126">Chpmv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, ap []<a href="../../../../builtin.html#name-complex64">complex64</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex64">complex64</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Chpmv-docs' class="fold-docs">
<span class="md-text">				Chpmv performs the matrix-vector operation
				
					y = alpha * A * x + beta * y
				
				where alpha and beta are scalars, x and y are vectors, and A is an n×n
				Hermitian matrix in packed form. The imaginary parts of the diagonal
				elements of A are ignored and assumed to be zero.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Chpr"><label for="Implementation-fold-method-Chpr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-1297">Chpr</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-complex64">complex64</a>)</label><span id='Implementation-fold-method-Chpr-docs' class="fold-docs">
<span class="md-text">				Chpr performs the Hermitian rank-1 operation
				
					A += alpha * x * xᴴ
				
				where alpha is a real scalar, x is a vector, and A is an n×n hermitian matrix
				in packed form. On entry, the imaginary parts of the diagonal elements are
				assumed to be zero, and on return they are set to zero.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Chpr2"><label for="Implementation-fold-method-Chpr2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-1435">Chpr2</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-complex64">complex64</a>)</label><span id='Implementation-fold-method-Chpr2-docs' class="fold-docs">
<span class="md-text">				Chpr2 performs the Hermitian rank-2 operation
				
					A += alpha * x * yᴴ + conj(alpha) * y * xᴴ
				
				where alpha is a complex scalar, x and y are n element vectors, and A is an
				n×n Hermitian matrix, supplied in packed form. On entry, the imaginary parts
				of the diagonal elements are assumed to be zero, and on return they are set to zero.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cscal"><label for="Implementation-fold-method-Cscal">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx64.go.html#line-399">Cscal</a>(n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Cscal-docs' class="fold-docs">
<span class="md-text">				Cscal scales the vector x by a complex scalar alpha.
				Cscal has no effect if incX &lt; 0.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Csscal"><label for="Implementation-fold-method-Csscal">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx64.go.html#line-353">Csscal</a>(n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Csscal-docs' class="fold-docs">
<span class="md-text">				Csscal scales the vector x by a real scalar alpha.
				Csscal has no effect if incX &lt; 0.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Cswap"><label for="Implementation-fold-method-Cswap">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx64.go.html#line-438">Cswap</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex64">complex64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Cswap-docs' class="fold-docs">
<span class="md-text">				Cswap exchanges the elements of two complex vectors x and y.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Csymm"><label for="Implementation-fold-method-Csymm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx64.go.html#line-830">Csymm</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex64">complex64</a>, c []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Csymm-docs' class="fold-docs">
<span class="md-text">				Csymm performs one of the matrix-matrix operations
				
					C = alpha*A*B + beta*C  if side == blas.Left
					C = alpha*B*A + beta*C  if side == blas.Right
				
				where alpha and beta are scalars, A is an m×m or n×n symmetric matrix and B
				and C are m×n matrices.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Csyr2k"><label for="Implementation-fold-method-Csyr2k">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx64.go.html#line-1140">Csyr2k</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex64">complex64</a>, c []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Csyr2k-docs' class="fold-docs">
<span class="md-text">				Csyr2k performs one of the symmetric rank-2k operations
				
					C = alpha*A*Bᵀ + alpha*B*Aᵀ + beta*C  if trans == blas.NoTrans
					C = alpha*Aᵀ*B + alpha*Bᵀ*A + beta*C  if trans == blas.Trans
				
				where alpha and beta are scalars, C is an n×n symmetric matrix and A and B
				are n×k matrices in the first case and k×n matrices in the second case.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Csyrk"><label for="Implementation-fold-method-Csyrk">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx64.go.html#line-978">Csyrk</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex64">complex64</a>, c []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Csyrk-docs' class="fold-docs">
<span class="md-text">				Csyrk performs one of the symmetric rank-k operations
				
					C = alpha*A*Aᵀ + beta*C  if trans == blas.NoTrans
					C = alpha*Aᵀ*A + beta*C  if trans == blas.Trans
				
				where alpha and beta are scalars, C is an n×n symmetric matrix and A is
				an n×k matrix in the first case and a k×n matrix in the second case.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ctbmv"><label for="Implementation-fold-method-Ctbmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-1587">Ctbmv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ctbmv-docs' class="fold-docs">
<span class="md-text">				Ctbmv performs one of the matrix-vector operations
				
					x = A * x   if trans = blas.NoTrans
					x = Aᵀ * x  if trans = blas.Trans
					x = Aᴴ * x  if trans = blas.ConjTrans
				
				where x is an n element vector and A is an n×n triangular band matrix, with
				(k+1) diagonals.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ctbsv"><label for="Implementation-fold-method-Ctbsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-1833">Ctbsv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ctbsv-docs' class="fold-docs">
<span class="md-text">				Ctbsv solves one of the systems of equations
				
					A * x = b   if trans == blas.NoTrans
					Aᵀ * x = b  if trans == blas.Trans
					Aᴴ * x = b  if trans == blas.ConjTrans
				
				where b and x are n element vectors and A is an n×n triangular band matrix
				with (k+1) diagonals.
				
				On entry, x contains the values of b, and the solution is
				stored in-place into x.
				
				No test for singularity or near-singularity is included in this
				routine. Such tests must be performed before calling this routine.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ctpmv"><label for="Implementation-fold-method-Ctpmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-2073">Ctpmv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-complex64">complex64</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ctpmv-docs' class="fold-docs">
<span class="md-text">				Ctpmv performs one of the matrix-vector operations
				
					x = A * x   if trans = blas.NoTrans
					x = Aᵀ * x  if trans = blas.Trans
					x = Aᴴ * x  if trans = blas.ConjTrans
				
				where x is an n element vector and A is an n×n triangular matrix, supplied in
				packed form.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ctpsv"><label for="Implementation-fold-method-Ctpsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-2321">Ctpsv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-complex64">complex64</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ctpsv-docs' class="fold-docs">
<span class="md-text">				Ctpsv solves one of the systems of equations
				
					A * x = b   if trans == blas.NoTrans
					Aᵀ * x = b  if trans == blas.Trans
					Aᴴ * x = b  if trans == blas.ConjTrans
				
				where b and x are n element vectors and A is an n×n triangular matrix in
				packed form.
				
				On entry, x contains the values of b, and the solution is
				stored in-place into x.
				
				No test for singularity or near-singularity is included in this
				routine. Such tests must be performed before calling this routine.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ctrmm"><label for="Implementation-fold-method-Ctrmm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx64.go.html#line-1321">Ctrmm</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ctrmm-docs' class="fold-docs">
<span class="md-text">				Ctrmm performs one of the matrix-matrix operations
				
					B = alpha * op(A) * B  if side == blas.Left,
					B = alpha * B * op(A)  if side == blas.Right,
				
				where alpha is a scalar, B is an m×n matrix, A is a unit, or non-unit,
				upper or lower triangular matrix and op(A) is one of
				
					op(A) = A   if trans == blas.NoTrans,
					op(A) = Aᵀ  if trans == blas.Trans,
					op(A) = Aᴴ  if trans == blas.ConjTrans.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ctrmv"><label for="Implementation-fold-method-Ctrmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-2554">Ctrmv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ctrmv-docs' class="fold-docs">
<span class="md-text">				Ctrmv performs one of the matrix-vector operations
				
					x = A * x   if trans = blas.NoTrans
					x = Aᵀ * x  if trans = blas.Trans
					x = Aᴴ * x  if trans = blas.ConjTrans
				
				where x is a vector, and A is an n×n triangular matrix.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ctrsm"><label for="Implementation-fold-method-Ctrsm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx64.go.html#line-1556">Ctrsm</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, transA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex64">complex64</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex64">complex64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ctrsm-docs' class="fold-docs">
<span class="md-text">				Ctrsm solves one of the matrix equations
				
					op(A) * X = alpha * B  if side == blas.Left,
					X * op(A) = alpha * B  if side == blas.Right,
				
				where alpha is a scalar, X and B are m×n matrices, A is a unit or
				non-unit, upper or lower triangular matrix and op(A) is one of
				
					op(A) = A   if transA == blas.NoTrans,
					op(A) = Aᵀ  if transA == blas.Trans,
					op(A) = Aᴴ  if transA == blas.ConjTrans.
				
				On return the matrix X is overwritten on B.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ctrsv"><label for="Implementation-fold-method-Ctrsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx64.go.html#line-2772">Ctrsv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex64">complex64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ctrsv-docs' class="fold-docs">
<span class="md-text">				Ctrsv solves one of the systems of equations
				
					A * x = b   if trans == blas.NoTrans
					Aᵀ * x = b  if trans == blas.Trans
					Aᴴ * x = b  if trans == blas.ConjTrans
				
				where b and x are n element vectors and A is an n×n triangular matrix.
				
				On entry, x contains the values of b, and the solution is
				stored in-place into x.
				
				No test for singularity or near-singularity is included in this
				routine. Such tests must be performed before calling this routine.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dasum"><label for="Implementation-fold-method-Dasum">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64.go.html#line-51">Dasum</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dasum-docs' class="fold-docs">
<span class="md-text">				Dasum computes the sum of the absolute values of the elements of x.
				
					\sum_i |x[i]|
				
				Dasum returns 0 if incX is negative.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Daxpy"><label for="Implementation-fold-method-Daxpy">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64.go.html#line-211">Daxpy</a>(n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Daxpy-docs' class="fold-docs">
<span class="md-text">				Daxpy adds alpha times x to y
				
					y[i] += alpha * x[i] for all i</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dcopy"><label for="Implementation-fold-method-Dcopy">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64.go.html#line-171">Dcopy</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dcopy-docs' class="fold-docs">
<span class="md-text">				Dcopy copies the elements of x into the elements of y.
				
					y[i] = x[i] for all i</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ddot"><label for="Implementation-fold-method-Ddot">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64_ddot.go.html#line-14">Ddot</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Ddot-docs' class="fold-docs">
<span class="md-text">				Ddot computes the dot product of the two vectors
				
					\sum_i x[i]*y[i]</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgbmv"><label for="Implementation-fold-method-Dgbmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-70">Dgbmv</a>(tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, kL, kU <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgbmv-docs' class="fold-docs">
<span class="md-text">				Dgbmv performs one of the matrix-vector operations
				
					y = alpha * A * x + beta * y   if tA == blas.NoTrans
					y = alpha * Aᵀ * x + beta * y  if tA == blas.Trans or blas.ConjTrans
				
				where A is an m×n band matrix with kL sub-diagonals and kU super-diagonals,
				x and y are vectors, and alpha and beta are scalars.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgemm"><label for="Implementation-fold-method-Dgemm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/dgemm.go.html#line-25">Dgemm</a>(tA, tB <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgemm-docs' class="fold-docs">
<span class="md-text">				Dgemm performs one of the matrix-matrix operations
				
					C = alpha * A * B + beta * C
					C = alpha * Aᵀ * B + beta * C
					C = alpha * A * Bᵀ + beta * C
					C = alpha * Aᵀ * Bᵀ + beta * C
				
				where A is an m×k or k×m dense matrix, B is an n×k or k×n dense matrix, C is
				an m×n matrix, and alpha and beta are scalars. tA and tB specify whether A or
				B are transposed.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgemv"><label for="Implementation-fold-method-Dgemv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-236">Dgemv</a>(tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgemv-docs' class="fold-docs">
<span class="md-text">				Dgemv computes
				
					y = alpha * A * x + beta * y   if tA = blas.NoTrans
					y = alpha * Aᵀ * x + beta * y  if tA = blas.Trans or blas.ConjTrans
				
				where A is an m×n dense matrix, x and y are vectors, and alpha and beta are scalars.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dger"><label for="Implementation-fold-method-Dger">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-19">Dger</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dger-docs' class="fold-docs">
<span class="md-text">				Dger performs the rank-one operation
				
					A += alpha * x * yᵀ
				
				where A is an m×n dense matrix, x and y are vectors, and alpha is a scalar.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dnrm2"><label for="Implementation-fold-method-Dnrm2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64.go.html#line-21">Dnrm2</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dnrm2-docs' class="fold-docs">
<span class="md-text">				Dnrm2 computes the Euclidean norm of a vector,
				
					sqrt(\sum_i x[i] * x[i]).
				
				This function returns 0 if incX is negative.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Drot"><label for="Implementation-fold-method-Drot">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64.go.html#line-441">Drot</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>, c <a href="../../../../builtin.html#name-float64">float64</a>, s <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Drot-docs' class="fold-docs">
<span class="md-text">				Drot applies a plane transformation.
				
					x[i] = c * x[i] + s * y[i]
					y[i] = c * y[i] - s * x[i]</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Drotg"><label for="Implementation-fold-method-Drotg">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64.go.html#line-279">Drotg</a>(a, b <a href="../../../../builtin.html#name-float64">float64</a>) (c, s, r, z <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Drotg-docs' class="fold-docs">
<span class="md-text">				Drotg computes a plane rotation
				
					⎡  c s ⎤ ⎡ a ⎤ = ⎡ r ⎤
					⎣ -s c ⎦ ⎣ b ⎦   ⎣ 0 ⎦
				
				satisfying c^2 + s^2 = 1.
				
				The computation uses the formulas
				
					sigma = sgn(a)    if |a| &gt;  |b|
					      = sgn(b)    if |b| &gt;= |a|
					r = sigma*sqrt(a^2 + b^2)
					c = 1; s = 0      if r = 0
					c = a/r; s = b/r  if r != 0
					c &gt;= 0            if |a| &gt; |b|
				
				The subroutine also computes
				
					z = s    if |a| &gt; |b|,
					  = 1/c  if |b| &gt;= |a| and c != 0
					  = 1    if c = 0
				
				This allows c and s to be reconstructed from z as follows:
				
					If z = 1, set c = 0, s = 1.
					If |z| &lt; 1, set c = sqrt(1 - z^2) and s = z.
					If |z| &gt; 1, set c = 1/z and s = sqrt(1 - c^2).
				
				NOTE: There is a discrepancy between the reference implementation and the
				BLAS technical manual regarding the sign for r when a or b are zero. Drotg
				agrees with the definition in the manual and other common BLAS
				implementations.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Drotm"><label for="Implementation-fold-method-Drotm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64.go.html#line-485">Drotm</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>, p <a href="../blas.html">blas</a>.<a href="../blas.html#name-DrotmParams">DrotmParams</a>)</label><span id='Implementation-fold-method-Drotm-docs' class="fold-docs">
<span class="md-text">				Drotm applies the modified Givens rotation to the 2×n matrix.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Drotmg"><label for="Implementation-fold-method-Drotmg">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64.go.html#line-330">Drotmg</a>(d1, d2, x1, y1 <a href="../../../../builtin.html#name-float64">float64</a>) (p <a href="../blas.html">blas</a>.<a href="../blas.html#name-DrotmParams">DrotmParams</a>, rd1, rd2, rx1 <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Drotmg-docs' class="fold-docs">
<span class="md-text">				Drotmg computes the modified Givens rotation. See
				http://www.netlib.org/lapack/explore-html/df/deb/drotmg_8f.html
				for more details.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsbmv"><label for="Implementation-fold-method-Dsbmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-1431">Dsbmv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dsbmv-docs' class="fold-docs">
<span class="md-text">				Dsbmv performs the matrix-vector operation
				
					y = alpha * A * x + beta * y
				
				where A is an n×n symmetric band matrix with k super-diagonals, x and y are
				vectors, and alpha and beta are scalars.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dscal"><label for="Implementation-fold-method-Dscal">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64.go.html#line-595">Dscal</a>(n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dscal-docs' class="fold-docs">
<span class="md-text">				Dscal scales x by alpha.
				
					x[i] *= alpha
				
				Dscal has no effect if incX &lt; 0.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsdot"><label for="Implementation-fold-method-Dsdot">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32_dsdot.go.html#line-18">Dsdot</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dsdot-docs' class="fold-docs">
<span class="md-text">				Dsdot computes the dot product of the two vectors
				
					\sum_i x[i]*y[i]
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dspmv"><label for="Implementation-fold-method-Dspmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-1998">Dspmv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, ap []<a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dspmv-docs' class="fold-docs">
<span class="md-text">				Dspmv performs the matrix-vector operation
				
					y = alpha * A * x + beta * y
				
				where A is an n×n symmetric matrix in packed format, x and y are vectors,
				and alpha and beta are scalars.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dspr"><label for="Implementation-fold-method-Dspr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-2167">Dspr</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dspr-docs' class="fold-docs">
<span class="md-text">				Dspr performs the symmetric rank-one operation
				
					A += alpha * x * xᵀ
				
				where A is an n×n symmetric matrix in packed format, x is a vector, and
				alpha is a scalar.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dspr2"><label for="Implementation-fold-method-Dspr2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-2261">Dspr2</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dspr2-docs' class="fold-docs">
<span class="md-text">				Dspr2 performs the symmetric rank-2 update
				
					A += alpha * x * yᵀ + alpha * y * xᵀ
				
				where A is an n×n symmetric matrix in packed format, x and y are vectors,
				and alpha is a scalar.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dswap"><label for="Implementation-fold-method-Dswap">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64.go.html#line-128">Dswap</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dswap-docs' class="fold-docs">
<span class="md-text">				Dswap exchanges the elements of two vectors.
				
					x[i], y[i] = y[i], x[i] for all i</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsymm"><label for="Implementation-fold-method-Dsymm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3float64.go.html#line-226">Dsymm</a>(s <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dsymm-docs' class="fold-docs">
<span class="md-text">				Dsymm performs one of the matrix-matrix operations
				
					C = alpha * A * B + beta * C  if side == blas.Left
					C = alpha * B * A + beta * C  if side == blas.Right
				
				where A is an n×n or m×m symmetric matrix, B and C are m×n matrices, and alpha
				is a scalar.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsymv"><label for="Implementation-fold-method-Dsymv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-645">Dsymv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dsymv-docs' class="fold-docs">
<span class="md-text">				Dsymv performs the matrix-vector operation
				
					y = alpha * A * x + beta * y
				
				where A is an n×n symmetric matrix, x and y are vectors, and alpha and
				beta are scalars.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsyr"><label for="Implementation-fold-method-Dsyr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-1602">Dsyr</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dsyr-docs' class="fold-docs">
<span class="md-text">				Dsyr performs the symmetric rank-one update
				
					A += alpha * x * xᵀ
				
				where A is an n×n symmetric matrix, and x is a vector.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsyr2"><label for="Implementation-fold-method-Dsyr2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-1702">Dsyr2</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dsyr2-docs' class="fold-docs">
<span class="md-text">				Dsyr2 performs the symmetric rank-two update
				
					A += alpha * x * yᵀ + alpha * y * xᵀ
				
				where A is an n×n symmetric matrix, x and y are vectors, and alpha is a scalar.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsyr2k"><label for="Implementation-fold-method-Dsyr2k">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3float64.go.html#line-523">Dsyr2k</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dsyr2k-docs' class="fold-docs">
<span class="md-text">				Dsyr2k performs one of the symmetric rank 2k operations
				
					C = alpha * A * Bᵀ + alpha * B * Aᵀ + beta * C  if tA == blas.NoTrans
					C = alpha * Aᵀ * B + alpha * Bᵀ * A + beta * C  if tA == blas.Trans or tA == blas.ConjTrans
				
				where A and B are n×k or k×n matrices, C is an n×n symmetric matrix, and
				alpha and beta are scalars.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsyrk"><label for="Implementation-fold-method-Dsyrk">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3float64.go.html#line-371">Dsyrk</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dsyrk-docs' class="fold-docs">
<span class="md-text">				Dsyrk performs one of the symmetric rank-k operations
				
					C = alpha * A * Aᵀ + beta * C  if tA == blas.NoTrans
					C = alpha * Aᵀ * A + beta * C  if tA == blas.Trans or tA == blas.ConjTrans
				
				where A is an n×k or k×n matrix, C is an n×n symmetric matrix, and alpha and
				beta are scalars.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtbmv"><label for="Implementation-fold-method-Dtbmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-815">Dtbmv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dtbmv-docs' class="fold-docs">
<span class="md-text">				Dtbmv performs one of the matrix-vector operations
				
					x = A * x   if tA == blas.NoTrans
					x = Aᵀ * x  if tA == blas.Trans or blas.ConjTrans
				
				where A is an n×n triangular band matrix with k+1 diagonals, and x is a vector.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtbsv"><label for="Implementation-fold-method-Dtbsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-1214">Dtbsv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dtbsv-docs' class="fold-docs">
<span class="md-text">				Dtbsv solves one of the systems of equations
				
					A * x = b   if tA == blas.NoTrans
					Aᵀ * x = b  if tA == blas.Trans or tA == blas.ConjTrans
				
				where A is an n×n triangular band matrix with k+1 diagonals,
				and x and b are vectors.
				
				At entry to the function, x contains the values of b, and the result is
				stored in-place into x.
				
				No test for singularity or near-singularity is included in this
				routine. Such tests must be performed before calling this routine.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtpmv"><label for="Implementation-fold-method-Dtpmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-1026">Dtpmv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dtpmv-docs' class="fold-docs">
<span class="md-text">				Dtpmv performs one of the matrix-vector operations
				
					x = A * x   if tA == blas.NoTrans
					x = Aᵀ * x  if tA == blas.Trans or blas.ConjTrans
				
				where A is an n×n triangular matrix in packed format, and x is a vector.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtpsv"><label for="Implementation-fold-method-Dtpsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-1818">Dtpsv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dtpsv-docs' class="fold-docs">
<span class="md-text">				Dtpsv solves one of the systems of equations
				
					A * x = b   if tA == blas.NoTrans
					Aᵀ * x = b  if tA == blas.Trans or blas.ConjTrans
				
				where A is an n×n triangular matrix in packed format, and x and b are vectors.
				
				At entry to the function, x contains the values of b, and the result is
				stored in-place into x.
				
				No test for singularity or near-singularity is included in this
				routine. Such tests must be performed before calling this routine.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtrmm"><label for="Implementation-fold-method-Dtrmm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3float64.go.html#line-725">Dtrmm</a>(s <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dtrmm-docs' class="fold-docs">
<span class="md-text">				Dtrmm performs one of the matrix-matrix operations
				
					B = alpha * A * B   if tA == blas.NoTrans and side == blas.Left
					B = alpha * Aᵀ * B  if tA == blas.Trans or blas.ConjTrans, and side == blas.Left
					B = alpha * B * A   if tA == blas.NoTrans and side == blas.Right
					B = alpha * B * Aᵀ  if tA == blas.Trans or blas.ConjTrans, and side == blas.Right
				
				where A is an n×n or m×m triangular matrix, B is an m×n matrix, and alpha is a scalar.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtrmv"><label for="Implementation-fold-method-Dtrmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-308">Dtrmv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dtrmv-docs' class="fold-docs">
<span class="md-text">				Dtrmv performs one of the matrix-vector operations
				
					x = A * x   if tA == blas.NoTrans
					x = Aᵀ * x  if tA == blas.Trans or blas.ConjTrans
				
				where A is an n×n triangular matrix, and x is a vector.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtrsm"><label for="Implementation-fold-method-Dtrsm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3float64.go.html#line-28">Dtrsm</a>(s <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dtrsm-docs' class="fold-docs">
<span class="md-text">				Dtrsm solves one of the matrix equations
				
					A * X = alpha * B   if tA == blas.NoTrans and side == blas.Left
					Aᵀ * X = alpha * B  if tA == blas.Trans or blas.ConjTrans, and side == blas.Left
					X * A = alpha * B   if tA == blas.NoTrans and side == blas.Right
					X * Aᵀ = alpha * B  if tA == blas.Trans or blas.ConjTrans, and side == blas.Right
				
				where A is an n×n or m×m triangular matrix, X and B are m×n matrices, and alpha is a
				scalar.
				
				At entry to the function, X contains the values of B, and the result is
				stored in-place into X.
				
				No check is made that A is invertible.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtrsv"><label for="Implementation-fold-method-Dtrsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float64.go.html#line-468">Dtrsv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dtrsv-docs' class="fold-docs">
<span class="md-text">				Dtrsv solves one of the systems of equations
				
					A * x = b   if tA == blas.NoTrans
					Aᵀ * x = b  if tA == blas.Trans or blas.ConjTrans
				
				where A is an n×n triangular matrix, and x and b are vectors.
				
				At entry to the function, x contains the values of b, and the result is
				stored in-place into x.
				
				No test for singularity or near-singularity is included in this
				routine. Such tests must be performed before calling this routine.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dzasum"><label for="Implementation-fold-method-Dzasum">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx128.go.html#line-21">Dzasum</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dzasum-docs' class="fold-docs">
<span class="md-text">				Dzasum returns the sum of the absolute values of the elements of x
				
					\sum_i |Re(x[i])| + |Im(x[i])|
				
				Dzasum returns 0 if incX is negative.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dznrm2"><label for="Implementation-fold-method-Dznrm2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx128.go.html#line-56">Dznrm2</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dznrm2-docs' class="fold-docs">
<span class="md-text">				Dznrm2 computes the Euclidean norm of the complex vector x,
				
					‖x‖_2 = sqrt(\sum_i x[i] * conj(x[i])).
				
				This function returns 0 if incX is negative.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Icamax"><label for="Implementation-fold-method-Icamax">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx64.go.html#line-136">Icamax</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></label><span id='Implementation-fold-method-Icamax-docs' class="fold-docs">
<span class="md-text">				Icamax returns the index of the first element of x having largest |Re(·)|+|Im(·)|.
				Icamax returns -1 if n is 0 or incX is negative.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Idamax"><label for="Implementation-fold-method-Idamax">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float64.go.html#line-81">Idamax</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></label><span id='Implementation-fold-method-Idamax-docs' class="fold-docs">
<span class="md-text">				Idamax returns the index of an element of x with the largest absolute value.
				If there are multiple such indices the earliest is returned.
				Idamax returns -1 if n == 0.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Isamax"><label for="Implementation-fold-method-Isamax">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32.go.html#line-89">Isamax</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></label><span id='Implementation-fold-method-Isamax-docs' class="fold-docs">
<span class="md-text">				Isamax returns the index of an element of x with the largest absolute value.
				If there are multiple such indices the earliest is returned.
				Isamax returns -1 if n == 0.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Izamax"><label for="Implementation-fold-method-Izamax">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx128.go.html#line-128">Izamax</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></label><span id='Implementation-fold-method-Izamax-docs' class="fold-docs">
<span class="md-text">				Izamax returns the index of the first element of x having largest |Re(·)|+|Im(·)|.
				Izamax returns -1 if n is 0 or incX is negative.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Sasum"><label for="Implementation-fold-method-Sasum">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32.go.html#line-57">Sasum</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float32">float32</a></label><span id='Implementation-fold-method-Sasum-docs' class="fold-docs">
<span class="md-text">				Sasum computes the sum of the absolute values of the elements of x.
				
					\sum_i |x[i]|
				
				Sasum returns 0 if incX is negative.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Saxpy"><label for="Implementation-fold-method-Saxpy">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32.go.html#line-225">Saxpy</a>(n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Saxpy-docs' class="fold-docs">
<span class="md-text">				Saxpy adds alpha times x to y
				
					y[i] += alpha * x[i] for all i
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Scasum"><label for="Implementation-fold-method-Scasum">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx64.go.html#line-25">Scasum</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float32">float32</a></label><span id='Implementation-fold-method-Scasum-docs' class="fold-docs">
<span class="md-text">				Scasum returns the sum of the absolute values of the elements of x
				
					\sum_i |Re(x[i])| + |Im(x[i])|
				
				Scasum returns 0 if incX is negative.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Scnrm2"><label for="Implementation-fold-method-Scnrm2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx64.go.html#line-62">Scnrm2</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex64">complex64</a>, incX <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float32">float32</a></label><span id='Implementation-fold-method-Scnrm2-docs' class="fold-docs">
<span class="md-text">				Scnrm2 computes the Euclidean norm of the complex vector x,
				
					‖x‖_2 = sqrt(\sum_i x[i] * conj(x[i])).
				
				This function returns 0 if incX is negative.
				
				Complex64 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Scopy"><label for="Implementation-fold-method-Scopy">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32.go.html#line-183">Scopy</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Scopy-docs' class="fold-docs">
<span class="md-text">				Scopy copies the elements of x into the elements of y.
				
					y[i] = x[i] for all i
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Sdot"><label for="Implementation-fold-method-Sdot">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32_sdot.go.html#line-18">Sdot</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float32">float32</a></label><span id='Implementation-fold-method-Sdot-docs' class="fold-docs">
<span class="md-text">				Sdot computes the dot product of the two vectors
				
					\sum_i x[i]*y[i]
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Sdsdot"><label for="Implementation-fold-method-Sdsdot">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32_sdsdot.go.html#line-18">Sdsdot</a>(n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float32">float32</a></label><span id='Implementation-fold-method-Sdsdot-docs' class="fold-docs">
<span class="md-text">				Sdsdot computes the dot product of the two vectors plus a constant
				
					alpha + \sum_i x[i]*y[i]
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Sgbmv"><label for="Implementation-fold-method-Sgbmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-76">Sgbmv</a>(tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, kL, kU <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float32">float32</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Sgbmv-docs' class="fold-docs">
<span class="md-text">				Sgbmv performs one of the matrix-vector operations
				
					y = alpha * A * x + beta * y   if tA == blas.NoTrans
					y = alpha * Aᵀ * x + beta * y  if tA == blas.Trans or blas.ConjTrans
				
				where A is an m×n band matrix with kL sub-diagonals and kU super-diagonals,
				x and y are vectors, and alpha and beta are scalars.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Sgemm"><label for="Implementation-fold-method-Sgemm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/sgemm.go.html#line-29">Sgemm</a>(tA, tB <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float32">float32</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float32">float32</a>, c []<a href="../../../../builtin.html#name-float32">float32</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Sgemm-docs' class="fold-docs">
<span class="md-text">				Sgemm performs one of the matrix-matrix operations
				
					C = alpha * A * B + beta * C
					C = alpha * Aᵀ * B + beta * C
					C = alpha * A * Bᵀ + beta * C
					C = alpha * Aᵀ * Bᵀ + beta * C
				
				where A is an m×k or k×m dense matrix, B is an n×k or k×n dense matrix, C is
				an m×n matrix, and alpha and beta are scalars. tA and tB specify whether A or
				B are transposed.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Sgemv"><label for="Implementation-fold-method-Sgemv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-244">Sgemv</a>(tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float32">float32</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Sgemv-docs' class="fold-docs">
<span class="md-text">				Sgemv computes
				
					y = alpha * A * x + beta * y   if tA = blas.NoTrans
					y = alpha * Aᵀ * x + beta * y  if tA = blas.Trans or blas.ConjTrans
				
				where A is an m×n dense matrix, x and y are vectors, and alpha and beta are scalars.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Sger"><label for="Implementation-fold-method-Sger">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-23">Sger</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Sger-docs' class="fold-docs">
<span class="md-text">				Sger performs the rank-one operation
				
					A += alpha * x * yᵀ
				
				where A is an m×n dense matrix, x and y are vectors, and alpha is a scalar.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Snrm2"><label for="Implementation-fold-method-Snrm2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32.go.html#line-25">Snrm2</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float32">float32</a></label><span id='Implementation-fold-method-Snrm2-docs' class="fold-docs">
<span class="md-text">				Snrm2 computes the Euclidean norm of a vector,
				
					sqrt(\sum_i x[i] * x[i]).
				
				This function returns 0 if incX is negative.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Srot"><label for="Implementation-fold-method-Srot">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32.go.html#line-461">Srot</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>, c <a href="../../../../builtin.html#name-float32">float32</a>, s <a href="../../../../builtin.html#name-float32">float32</a>)</label><span id='Implementation-fold-method-Srot-docs' class="fold-docs">
<span class="md-text">				Srot applies a plane transformation.
				
					x[i] = c * x[i] + s * y[i]
					y[i] = c * y[i] - s * x[i]
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Srotg"><label for="Implementation-fold-method-Srotg">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32.go.html#line-295">Srotg</a>(a, b <a href="../../../../builtin.html#name-float32">float32</a>) (c, s, r, z <a href="../../../../builtin.html#name-float32">float32</a>)</label><span id='Implementation-fold-method-Srotg-docs' class="fold-docs">
<span class="md-text">				Srotg computes a plane rotation
				
					⎡  c s ⎤ ⎡ a ⎤ = ⎡ r ⎤
					⎣ -s c ⎦ ⎣ b ⎦   ⎣ 0 ⎦
				
				satisfying c^2 + s^2 = 1.
				
				The computation uses the formulas
				
					sigma = sgn(a)    if |a| &gt;  |b|
					      = sgn(b)    if |b| &gt;= |a|
					r = sigma*sqrt(a^2 + b^2)
					c = 1; s = 0      if r = 0
					c = a/r; s = b/r  if r != 0
					c &gt;= 0            if |a| &gt; |b|
				
				The subroutine also computes
				
					z = s    if |a| &gt; |b|,
					  = 1/c  if |b| &gt;= |a| and c != 0
					  = 1    if c = 0
				
				This allows c and s to be reconstructed from z as follows:
				
					If z = 1, set c = 0, s = 1.
					If |z| &lt; 1, set c = sqrt(1 - z^2) and s = z.
					If |z| &gt; 1, set c = 1/z and s = sqrt(1 - c^2).
				
				NOTE: There is a discrepancy between the reference implementation and the
				BLAS technical manual regarding the sign for r when a or b are zero. Drotg
				agrees with the definition in the manual and other common BLAS
				implementations.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Srotm"><label for="Implementation-fold-method-Srotm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32.go.html#line-507">Srotm</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>, p <a href="../blas.html">blas</a>.<a href="../blas.html#name-SrotmParams">SrotmParams</a>)</label><span id='Implementation-fold-method-Srotm-docs' class="fold-docs">
<span class="md-text">				Srotm applies the modified Givens rotation to the 2×n matrix.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Srotmg"><label for="Implementation-fold-method-Srotmg">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32.go.html#line-348">Srotmg</a>(d1, d2, x1, y1 <a href="../../../../builtin.html#name-float32">float32</a>) (p <a href="../blas.html">blas</a>.<a href="../blas.html#name-SrotmParams">SrotmParams</a>, rd1, rd2, rx1 <a href="../../../../builtin.html#name-float32">float32</a>)</label><span id='Implementation-fold-method-Srotmg-docs' class="fold-docs">
<span class="md-text">				Srotmg computes the modified Givens rotation. See
				http://www.netlib.org/lapack/explore-html/df/deb/drotmg_8f.html
				for more details.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ssbmv"><label for="Implementation-fold-method-Ssbmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-1453">Ssbmv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float32">float32</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ssbmv-docs' class="fold-docs">
<span class="md-text">				Ssbmv performs the matrix-vector operation
				
					y = alpha * A * x + beta * y
				
				where A is an n×n symmetric band matrix with k super-diagonals, x and y are
				vectors, and alpha and beta are scalars.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Sscal"><label for="Implementation-fold-method-Sscal">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32.go.html#line-619">Sscal</a>(n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Sscal-docs' class="fold-docs">
<span class="md-text">				Sscal scales x by alpha.
				
					x[i] *= alpha
				
				Sscal has no effect if incX &lt; 0.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Sspmv"><label for="Implementation-fold-method-Sspmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-2028">Sspmv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, ap []<a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float32">float32</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Sspmv-docs' class="fold-docs">
<span class="md-text">				Sspmv performs the matrix-vector operation
				
					y = alpha * A * x + beta * y
				
				where A is an n×n symmetric matrix in packed format, x and y are vectors,
				and alpha and beta are scalars.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Sspr"><label for="Implementation-fold-method-Sspr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-2199">Sspr</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-float32">float32</a>)</label><span id='Implementation-fold-method-Sspr-docs' class="fold-docs">
<span class="md-text">				Sspr performs the symmetric rank-one operation
				
					A += alpha * x * xᵀ
				
				where A is an n×n symmetric matrix in packed format, x is a vector, and
				alpha is a scalar.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Sspr2"><label for="Implementation-fold-method-Sspr2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-2295">Sspr2</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-float32">float32</a>)</label><span id='Implementation-fold-method-Sspr2-docs' class="fold-docs">
<span class="md-text">				Sspr2 performs the symmetric rank-2 update
				
					A += alpha * x * yᵀ + alpha * y * xᵀ
				
				where A is an n×n symmetric matrix in packed format, x and y are vectors,
				and alpha is a scalar.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Sswap"><label for="Implementation-fold-method-Sswap">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1float32.go.html#line-138">Sswap</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Sswap-docs' class="fold-docs">
<span class="md-text">				Sswap exchanges the elements of two vectors.
				
					x[i], y[i] = y[i], x[i] for all i
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ssymm"><label for="Implementation-fold-method-Ssymm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3float32.go.html#line-232">Ssymm</a>(s <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float32">float32</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float32">float32</a>, c []<a href="../../../../builtin.html#name-float32">float32</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ssymm-docs' class="fold-docs">
<span class="md-text">				Ssymm performs one of the matrix-matrix operations
				
					C = alpha * A * B + beta * C  if side == blas.Left
					C = alpha * B * A + beta * C  if side == blas.Right
				
				where A is an n×n or m×m symmetric matrix, B and C are m×n matrices, and alpha
				is a scalar.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ssymv"><label for="Implementation-fold-method-Ssymv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-659">Ssymv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float32">float32</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ssymv-docs' class="fold-docs">
<span class="md-text">				Ssymv performs the matrix-vector operation
				
					y = alpha * A * x + beta * y
				
				where A is an n×n symmetric matrix, x and y are vectors, and alpha and
				beta are scalars.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ssyr"><label for="Implementation-fold-method-Ssyr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-1626">Ssyr</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ssyr-docs' class="fold-docs">
<span class="md-text">				Ssyr performs the symmetric rank-one update
				
					A += alpha * x * xᵀ
				
				where A is an n×n symmetric matrix, and x is a vector.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ssyr2"><label for="Implementation-fold-method-Ssyr2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-1728">Ssyr2</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float32">float32</a>, incY <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ssyr2-docs' class="fold-docs">
<span class="md-text">				Ssyr2 performs the symmetric rank-two update
				
					A += alpha * x * yᵀ + alpha * y * xᵀ
				
				where A is an n×n symmetric matrix, x and y are vectors, and alpha is a scalar.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ssyr2k"><label for="Implementation-fold-method-Ssyr2k">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3float32.go.html#line-533">Ssyr2k</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float32">float32</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float32">float32</a>, c []<a href="../../../../builtin.html#name-float32">float32</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ssyr2k-docs' class="fold-docs">
<span class="md-text">				Ssyr2k performs one of the symmetric rank 2k operations
				
					C = alpha * A * Bᵀ + alpha * B * Aᵀ + beta * C  if tA == blas.NoTrans
					C = alpha * Aᵀ * B + alpha * Bᵀ * A + beta * C  if tA == blas.Trans or tA == blas.ConjTrans
				
				where A and B are n×k or k×n matrices, C is an n×n symmetric matrix, and
				alpha and beta are scalars.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ssyrk"><label for="Implementation-fold-method-Ssyrk">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3float32.go.html#line-379">Ssyrk</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float32">float32</a>, c []<a href="../../../../builtin.html#name-float32">float32</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ssyrk-docs' class="fold-docs">
<span class="md-text">				Ssyrk performs one of the symmetric rank-k operations
				
					C = alpha * A * Aᵀ + beta * C  if tA == blas.NoTrans
					C = alpha * Aᵀ * A + beta * C  if tA == blas.Trans or tA == blas.ConjTrans
				
				where A is an n×k or k×n matrix, C is an n×n symmetric matrix, and alpha and
				beta are scalars.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Stbmv"><label for="Implementation-fold-method-Stbmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-831">Stbmv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Stbmv-docs' class="fold-docs">
<span class="md-text">				Stbmv performs one of the matrix-vector operations
				
					x = A * x   if tA == blas.NoTrans
					x = Aᵀ * x  if tA == blas.Trans or blas.ConjTrans
				
				where A is an n×n triangular band matrix with k+1 diagonals, and x is a vector.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Stbsv"><label for="Implementation-fold-method-Stbsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-1234">Stbsv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Stbsv-docs' class="fold-docs">
<span class="md-text">				Stbsv solves one of the systems of equations
				
					A * x = b   if tA == blas.NoTrans
					Aᵀ * x = b  if tA == blas.Trans or tA == blas.ConjTrans
				
				where A is an n×n triangular band matrix with k+1 diagonals,
				and x and b are vectors.
				
				At entry to the function, x contains the values of b, and the result is
				stored in-place into x.
				
				No test for singularity or near-singularity is included in this
				routine. Such tests must be performed before calling this routine.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Stpmv"><label for="Implementation-fold-method-Stpmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-1044">Stpmv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Stpmv-docs' class="fold-docs">
<span class="md-text">				Stpmv performs one of the matrix-vector operations
				
					x = A * x   if tA == blas.NoTrans
					x = Aᵀ * x  if tA == blas.Trans or blas.ConjTrans
				
				where A is an n×n triangular matrix in packed format, and x is a vector.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Stpsv"><label for="Implementation-fold-method-Stpsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-1846">Stpsv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-float32">float32</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Stpsv-docs' class="fold-docs">
<span class="md-text">				Stpsv solves one of the systems of equations
				
					A * x = b   if tA == blas.NoTrans
					Aᵀ * x = b  if tA == blas.Trans or blas.ConjTrans
				
				where A is an n×n triangular matrix in packed format, and x and b are vectors.
				
				At entry to the function, x contains the values of b, and the result is
				stored in-place into x.
				
				No test for singularity or near-singularity is included in this
				routine. Such tests must be performed before calling this routine.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Strmm"><label for="Implementation-fold-method-Strmm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3float32.go.html#line-737">Strmm</a>(s <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float32">float32</a>, ldb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Strmm-docs' class="fold-docs">
<span class="md-text">				Strmm performs one of the matrix-matrix operations
				
					B = alpha * A * B   if tA == blas.NoTrans and side == blas.Left
					B = alpha * Aᵀ * B  if tA == blas.Trans or blas.ConjTrans, and side == blas.Left
					B = alpha * B * A   if tA == blas.NoTrans and side == blas.Right
					B = alpha * B * Aᵀ  if tA == blas.Trans or blas.ConjTrans, and side == blas.Right
				
				where A is an n×n or m×m triangular matrix, B is an m×n matrix, and alpha is a scalar.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Strmv"><label for="Implementation-fold-method-Strmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-318">Strmv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Strmv-docs' class="fold-docs">
<span class="md-text">				Strmv performs one of the matrix-vector operations
				
					x = A * x   if tA == blas.NoTrans
					x = Aᵀ * x  if tA == blas.Trans or blas.ConjTrans
				
				where A is an n×n triangular matrix, and x is a vector.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Strsm"><label for="Implementation-fold-method-Strsm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3float32.go.html#line-32">Strsm</a>(s <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float32">float32</a>, ldb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Strsm-docs' class="fold-docs">
<span class="md-text">				Strsm solves one of the matrix equations
				
					A * X = alpha * B   if tA == blas.NoTrans and side == blas.Left
					Aᵀ * X = alpha * B  if tA == blas.Trans or blas.ConjTrans, and side == blas.Left
					X * A = alpha * B   if tA == blas.NoTrans and side == blas.Right
					X * Aᵀ = alpha * B  if tA == blas.Trans or blas.ConjTrans, and side == blas.Right
				
				where A is an n×n or m×m triangular matrix, X and B are m×n matrices, and alpha is a
				scalar.
				
				At entry to the function, X contains the values of B, and the result is
				stored in-place into X.
				
				No check is made that A is invertible.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Strsv"><label for="Implementation-fold-method-Strsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2float32.go.html#line-480">Strsv</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, tA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, d <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float32">float32</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Strsv-docs' class="fold-docs">
<span class="md-text">				Strsv solves one of the systems of equations
				
					A * x = b   if tA == blas.NoTrans
					Aᵀ * x = b  if tA == blas.Trans or blas.ConjTrans
				
				where A is an n×n triangular matrix, and x and b are vectors.
				
				At entry to the function, x contains the values of b, and the result is
				stored in-place into x.
				
				No test for singularity or near-singularity is included in this
				routine. Such tests must be performed before calling this routine.
				
				Float32 implementations are autogenerated and not directly tested.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zaxpy"><label for="Implementation-fold-method-Zaxpy">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx128.go.html#line-173">Zaxpy</a>(n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zaxpy-docs' class="fold-docs">
<span class="md-text">				Zaxpy adds alpha times x to y:
				
					y[i] += alpha * x[i] for all i</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zcopy"><label for="Implementation-fold-method-Zcopy">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx128.go.html#line-210">Zcopy</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zcopy-docs' class="fold-docs">
<span class="md-text">				Zcopy copies the vector x to vector y.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zdotc"><label for="Implementation-fold-method-Zdotc">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx128.go.html#line-252">Zdotc</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-complex128">complex128</a></label><span id='Implementation-fold-method-Zdotc-docs' class="fold-docs">
<span class="md-text">				Zdotc computes the dot product
				
					xᴴ · y
				
				of two complex vectors x and y.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zdotu"><label for="Implementation-fold-method-Zdotu">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx128.go.html#line-295">Zdotu</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-complex128">complex128</a></label><span id='Implementation-fold-method-Zdotu-docs' class="fold-docs">
<span class="md-text">				Zdotu computes the dot product
				
					xᵀ · y
				
				of two complex vectors x and y.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zdscal"><label for="Implementation-fold-method-Zdscal">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx128.go.html#line-335">Zdscal</a>(n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zdscal-docs' class="fold-docs">
<span class="md-text">				Zdscal scales the vector x by a real scalar alpha.
				Zdscal has no effect if incX &lt; 0.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zgbmv"><label for="Implementation-fold-method-Zgbmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-24">Zgbmv</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, kL, kU <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex128">complex128</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zgbmv-docs' class="fold-docs">
<span class="md-text">				Zgbmv performs one of the matrix-vector operations
				
					y = alpha * A * x + beta * y   if trans = blas.NoTrans
					y = alpha * Aᵀ * x + beta * y  if trans = blas.Trans
					y = alpha * Aᴴ * x + beta * y  if trans = blas.ConjTrans
				
				where alpha and beta are scalars, x and y are vectors, and A is an m×n band matrix
				with kL sub-diagonals and kU super-diagonals.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zgemm"><label for="Implementation-fold-method-Zgemm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx128.go.html#line-26">Zgemm</a>(tA, tB <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex128">complex128</a>, c []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zgemm-docs' class="fold-docs">
<span class="md-text">				Zgemm performs one of the matrix-matrix operations
				
					C = alpha * op(A) * op(B) + beta * C
				
				where op(X) is one of
				
					op(X) = X  or  op(X) = Xᵀ  or  op(X) = Xᴴ,
				
				alpha and beta are scalars, and A, B and C are matrices, with op(A) an m×k matrix,
				op(B) a k×n matrix and C an m×n matrix.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zgemv"><label for="Implementation-fold-method-Zgemv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-220">Zgemv</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex128">complex128</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zgemv-docs' class="fold-docs">
<span class="md-text">				Zgemv performs one of the matrix-vector operations
				
					y = alpha * A * x + beta * y   if trans = blas.NoTrans
					y = alpha * Aᵀ * x + beta * y  if trans = blas.Trans
					y = alpha * Aᴴ * x + beta * y  if trans = blas.ConjTrans
				
				where alpha and beta are scalars, x and y are vectors, and A is an m×n dense matrix.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zgerc"><label for="Implementation-fold-method-Zgerc">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-376">Zgerc</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zgerc-docs' class="fold-docs">
<span class="md-text">				Zgerc performs the rank-one operation
				
					A += alpha * x * yᴴ
				
				where A is an m×n dense matrix, alpha is a scalar, x is an m element vector,
				and y is an n element vector.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zgeru"><label for="Implementation-fold-method-Zgeru">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-436">Zgeru</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zgeru-docs' class="fold-docs">
<span class="md-text">				Zgeru performs the rank-one operation
				
					A += alpha * x * yᵀ
				
				where A is an m×n dense matrix, alpha is a scalar, x is an m element vector,
				and y is an n element vector.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zhbmv"><label for="Implementation-fold-method-Zhbmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-508">Zhbmv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex128">complex128</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zhbmv-docs' class="fold-docs">
<span class="md-text">				Zhbmv performs the matrix-vector operation
				
					y = alpha * A * x + beta * y
				
				where alpha and beta are scalars, x and y are vectors, and A is an n×n
				Hermitian band matrix with k super-diagonals. The imaginary parts of
				the diagonal elements of A are ignored and assumed to be zero.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zhemm"><label for="Implementation-fold-method-Zhemm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx128.go.html#line-272">Zhemm</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex128">complex128</a>, c []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zhemm-docs' class="fold-docs">
<span class="md-text">				Zhemm performs one of the matrix-matrix operations
				
					C = alpha*A*B + beta*C  if side == blas.Left
					C = alpha*B*A + beta*C  if side == blas.Right
				
				where alpha and beta are scalars, A is an m×m or n×n hermitian matrix and B
				and C are m×n matrices. The imaginary parts of the diagonal elements of A are
				assumed to be zero.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zhemv"><label for="Implementation-fold-method-Zhemv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-681">Zhemv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex128">complex128</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zhemv-docs' class="fold-docs">
<span class="md-text">				Zhemv performs the matrix-vector operation
				
					y = alpha * A * x + beta * y
				
				where alpha and beta are scalars, x and y are vectors, and A is an n×n
				Hermitian matrix. The imaginary parts of the diagonal elements of A are
				ignored and assumed to be zero.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zher"><label for="Implementation-fold-method-Zher">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-843">Zher</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zher-docs' class="fold-docs">
<span class="md-text">				Zher performs the Hermitian rank-one operation
				
					A += alpha * x * xᴴ
				
				where A is an n×n Hermitian matrix, alpha is a real scalar, and x is an n
				element vector. On entry, the imaginary parts of the diagonal elements of A
				are ignored and assumed to be zero, on return they will be set to zero.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zher2"><label for="Implementation-fold-method-Zher2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-967">Zher2</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zher2-docs' class="fold-docs">
<span class="md-text">				Zher2 performs the Hermitian rank-two operation
				
					A += alpha * x * yᴴ + conj(alpha) * y * xᴴ
				
				where alpha is a scalar, x and y are n element vectors and A is an n×n
				Hermitian matrix. On entry, the imaginary parts of the diagonal elements are
				ignored and assumed to be zero. On return they will be set to zero.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zher2k"><label for="Implementation-fold-method-Zher2k">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx128.go.html#line-623">Zher2k</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, c []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zher2k-docs' class="fold-docs">
<span class="md-text">				Zher2k performs one of the hermitian rank-2k operations
				
					C = alpha*A*Bᴴ + conj(alpha)*B*Aᴴ + beta*C  if trans == blas.NoTrans
					C = alpha*Aᴴ*B + conj(alpha)*Bᴴ*A + beta*C  if trans == blas.ConjTrans
				
				where alpha and beta are scalars with beta real, C is an n×n hermitian matrix
				and A and B are n×k matrices in the first case and k×n matrices in the second case.
				
				The imaginary parts of the diagonal elements of C are assumed to be zero, and
				on return they will be set to zero.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zherk"><label for="Implementation-fold-method-Zherk">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx128.go.html#line-423">Zherk</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, c []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zherk-docs' class="fold-docs">
<span class="md-text">				Zherk performs one of the hermitian rank-k operations
				
					C = alpha*A*Aᴴ + beta*C  if trans == blas.NoTrans
					C = alpha*Aᴴ*A + beta*C  if trans == blas.ConjTrans
				
				where alpha and beta are real scalars, C is an n×n hermitian matrix and A is
				an n×k matrix in the first case and a k×n matrix in the second case.
				
				The imaginary parts of the diagonal elements of C are assumed to be zero, and
				on return they will be set to zero.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zhpmv"><label for="Implementation-fold-method-Zhpmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-1106">Zhpmv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, ap []<a href="../../../../builtin.html#name-complex128">complex128</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex128">complex128</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zhpmv-docs' class="fold-docs">
<span class="md-text">				Zhpmv performs the matrix-vector operation
				
					y = alpha * A * x + beta * y
				
				where alpha and beta are scalars, x and y are vectors, and A is an n×n
				Hermitian matrix in packed form. The imaginary parts of the diagonal
				elements of A are ignored and assumed to be zero.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zhpr"><label for="Implementation-fold-method-Zhpr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-1275">Zhpr</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-complex128">complex128</a>)</label><span id='Implementation-fold-method-Zhpr-docs' class="fold-docs">
<span class="md-text">				Zhpr performs the Hermitian rank-1 operation
				
					A += alpha * x * xᴴ
				
				where alpha is a real scalar, x is a vector, and A is an n×n hermitian matrix
				in packed form. On entry, the imaginary parts of the diagonal elements are
				assumed to be zero, and on return they are set to zero.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zhpr2"><label for="Implementation-fold-method-Zhpr2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-1411">Zhpr2</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-complex128">complex128</a>)</label><span id='Implementation-fold-method-Zhpr2-docs' class="fold-docs">
<span class="md-text">				Zhpr2 performs the Hermitian rank-2 operation
				
					A += alpha * x * yᴴ + conj(alpha) * y * xᴴ
				
				where alpha is a complex scalar, x and y are n element vectors, and A is an
				n×n Hermitian matrix, supplied in packed form. On entry, the imaginary parts
				of the diagonal elements are assumed to be zero, and on return they are set to zero.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zscal"><label for="Implementation-fold-method-Zscal">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx128.go.html#line-379">Zscal</a>(n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zscal-docs' class="fold-docs">
<span class="md-text">				Zscal scales the vector x by a complex scalar alpha.
				Zscal has no effect if incX &lt; 0.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zswap"><label for="Implementation-fold-method-Zswap">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level1cmplx128.go.html#line-416">Zswap</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-complex128">complex128</a>, incY <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zswap-docs' class="fold-docs">
<span class="md-text">				Zswap exchanges the elements of two complex vectors x and y.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zsymm"><label for="Implementation-fold-method-Zsymm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx128.go.html#line-818">Zsymm</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex128">complex128</a>, c []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zsymm-docs' class="fold-docs">
<span class="md-text">				Zsymm performs one of the matrix-matrix operations
				
					C = alpha*A*B + beta*C  if side == blas.Left
					C = alpha*B*A + beta*C  if side == blas.Right
				
				where alpha and beta are scalars, A is an m×m or n×n symmetric matrix and B
				and C are m×n matrices.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zsyr2k"><label for="Implementation-fold-method-Zsyr2k">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx128.go.html#line-1124">Zsyr2k</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex128">complex128</a>, c []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zsyr2k-docs' class="fold-docs">
<span class="md-text">				Zsyr2k performs one of the symmetric rank-2k operations
				
					C = alpha*A*Bᵀ + alpha*B*Aᵀ + beta*C  if trans == blas.NoTrans
					C = alpha*Aᵀ*B + alpha*Bᵀ*A + beta*C  if trans == blas.Trans
				
				where alpha and beta are scalars, C is an n×n symmetric matrix and A and B
				are n×k matrices in the first case and k×n matrices in the second case.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Zsyrk"><label for="Implementation-fold-method-Zsyrk">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx128.go.html#line-964">Zsyrk</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-complex128">complex128</a>, c []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Zsyrk-docs' class="fold-docs">
<span class="md-text">				Zsyrk performs one of the symmetric rank-k operations
				
					C = alpha*A*Aᵀ + beta*C  if trans == blas.NoTrans
					C = alpha*Aᵀ*A + beta*C  if trans == blas.Trans
				
				where alpha and beta are scalars, C is an n×n symmetric matrix and A is
				an n×k matrix in the first case and a k×n matrix in the second case.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ztbmv"><label for="Implementation-fold-method-Ztbmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-1561">Ztbmv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ztbmv-docs' class="fold-docs">
<span class="md-text">				Ztbmv performs one of the matrix-vector operations
				
					x = A * x   if trans = blas.NoTrans
					x = Aᵀ * x  if trans = blas.Trans
					x = Aᴴ * x  if trans = blas.ConjTrans
				
				where x is an n element vector and A is an n×n triangular band matrix, with
				(k+1) diagonals.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ztbsv"><label for="Implementation-fold-method-Ztbsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-1805">Ztbsv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ztbsv-docs' class="fold-docs">
<span class="md-text">				Ztbsv solves one of the systems of equations
				
					A * x = b   if trans == blas.NoTrans
					Aᵀ * x = b  if trans == blas.Trans
					Aᴴ * x = b  if trans == blas.ConjTrans
				
				where b and x are n element vectors and A is an n×n triangular band matrix
				with (k+1) diagonals.
				
				On entry, x contains the values of b, and the solution is
				stored in-place into x.
				
				No test for singularity or near-singularity is included in this
				routine. Such tests must be performed before calling this routine.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ztpmv"><label for="Implementation-fold-method-Ztpmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-2043">Ztpmv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-complex128">complex128</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ztpmv-docs' class="fold-docs">
<span class="md-text">				Ztpmv performs one of the matrix-vector operations
				
					x = A * x   if trans = blas.NoTrans
					x = Aᵀ * x  if trans = blas.Trans
					x = Aᴴ * x  if trans = blas.ConjTrans
				
				where x is an n element vector and A is an n×n triangular matrix, supplied in
				packed form.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ztpsv"><label for="Implementation-fold-method-Ztpsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-2289">Ztpsv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, ap []<a href="../../../../builtin.html#name-complex128">complex128</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ztpsv-docs' class="fold-docs">
<span class="md-text">				Ztpsv solves one of the systems of equations
				
					A * x = b   if trans == blas.NoTrans
					Aᵀ * x = b  if trans == blas.Trans
					Aᴴ * x = b  if trans == blas.ConjTrans
				
				where b and x are n element vectors and A is an n×n triangular matrix in
				packed form.
				
				On entry, x contains the values of b, and the solution is
				stored in-place into x.
				
				No test for singularity or near-singularity is included in this
				routine. Such tests must be performed before calling this routine.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ztrmm"><label for="Implementation-fold-method-Ztrmm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx128.go.html#line-1303">Ztrmm</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ztrmm-docs' class="fold-docs">
<span class="md-text">				Ztrmm performs one of the matrix-matrix operations
				
					B = alpha * op(A) * B  if side == blas.Left,
					B = alpha * B * op(A)  if side == blas.Right,
				
				where alpha is a scalar, B is an m×n matrix, A is a unit, or non-unit,
				upper or lower triangular matrix and op(A) is one of
				
					op(A) = A   if trans == blas.NoTrans,
					op(A) = Aᵀ  if trans == blas.Trans,
					op(A) = Aᴴ  if trans == blas.ConjTrans.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ztrmv"><label for="Implementation-fold-method-Ztrmv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-2520">Ztrmv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ztrmv-docs' class="fold-docs">
<span class="md-text">				Ztrmv performs one of the matrix-vector operations
				
					x = A * x   if trans = blas.NoTrans
					x = Aᵀ * x  if trans = blas.Trans
					x = Aᴴ * x  if trans = blas.ConjTrans
				
				where x is a vector, and A is an n×n triangular matrix.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ztrsm"><label for="Implementation-fold-method-Ztrsm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level3cmplx128.go.html#line-1536">Ztrsm</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, transA <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-complex128">complex128</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-complex128">complex128</a>, ldb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ztrsm-docs' class="fold-docs">
<span class="md-text">				Ztrsm solves one of the matrix equations
				
					op(A) * X = alpha * B  if side == blas.Left,
					X * op(A) = alpha * B  if side == blas.Right,
				
				where alpha is a scalar, X and B are m×n matrices, A is a unit or
				non-unit, upper or lower triangular matrix and op(A) is one of
				
					op(A) = A   if transA == blas.NoTrans,
					op(A) = Aᵀ  if transA == blas.Trans,
					op(A) = Aᴴ  if transA == blas.ConjTrans.
				
				On return the matrix X is overwritten on B.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ztrsv"><label for="Implementation-fold-method-Ztrsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/level2cmplx128.go.html#line-2736">Ztrsv</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-complex128">complex128</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-complex128">complex128</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Ztrsv-docs' class="fold-docs">
<span class="md-text">				Ztrsv solves one of the systems of equations
				
					A * x = b   if trans == blas.NoTrans
					Aᵀ * x = b  if trans == blas.Trans
					Aᴴ * x = b  if trans == blas.ConjTrans
				
				where b and x are n element vectors and A is an n×n triangular matrix.
				
				On entry, x contains the values of b, and the solution is
				stored in-place into x.
				
				No test for singularity or near-singularity is included in this
				routine. Such tests must be performed before calling this routine.</span>
</span></span></span>
		<input type='checkbox' class="fold" id="Implementation-fold-impls"><label for="Implementation-fold-impls">Implements (<i>at least 16, all are exported</i>)</label><span id='Implementation-fold-impls-items' class="fold-items"><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Complex128">Complex128</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Complex128Level1">Complex128Level1</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Complex128Level2">Complex128Level2</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Complex128Level3">Complex128Level3</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Complex64">Complex64</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Complex64Level1">Complex64Level1</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Complex64Level2">Complex64Level2</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Complex64Level3">Complex64Level3</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Float32">Float32</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Float32Level1">Float32Level1</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Float32Level2">Float32Level2</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Float32Level3">Float32Level3</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Float64">Float64</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Float64Level1">Float64Level1</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Float64Level2">Float64Level2</a></span><span>
			 Implementation : gonum.org/v1/gonum/blas.<a href="../blas.html#name-Float64Level3">Float64Level3</a></span></span>

</span></div></div>
<div id="exported-functions"><span class="title">Package-Level Functions<span class="title-stat"><i> (total 19, none are exported)</i></span></span>

	<input type='checkbox' class="showhide" id="unexported-functions-showhide"><i><label for="unexported-functions-showhide" class="show-inline">/* 19 unexporteds ... */</label><label for="unexported-functions-showhide" class="hide-inline">/* 19 unexporteds: */</label></i><div class="anchor value-res hidden" id="name-blocks"><i>	<input type='checkbox' class="fold" id="blocks-fold-content"><label for="blocks-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..blocks^2a12d.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/gonum.go.html#line-40">blocks</a>(dim, bsize <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></label><span id='blocks-fold-content-docs' class="fold-docs">
<span class="md-text">		blocks returns the number of divisions of the dimension length with the given
		block size.</span>

</span></i></div><div class="anchor value-res hidden" id="name-dcabs1"><i>	<input type='checkbox' class="fold" id="dcabs1-fold-content"><label for="dcabs1-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..dcabs1^9016d.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/gonum.go.html#line-45">dcabs1</a>(z <a href="../../../../builtin.html#name-complex128">complex128</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='dcabs1-fold-content-docs' class="fold-docs">
<span class="md-text">		dcabs1 returns |real(z)|+|imag(z)|.</span>

</span></i></div><div class="anchor value-res hidden" id="name-dgemmParallel"><i>	<span class="nodocs"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..dgemmParallel^52806.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/dgemm.go.html#line-124">dgemmParallel</a>(aTrans, bTrans <a href="../../../../builtin.html#name-bool">bool</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>)</span></i></div><div class="anchor value-res hidden" id="name-dgemmSerial"><i>	<input type='checkbox' class="fold" id="dgemmSerial-fold-content"><label for="dgemmSerial-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..dgemmSerial^6e494.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/dgemm.go.html#line-217">dgemmSerial</a>(aTrans, bTrans <a href="../../../../builtin.html#name-bool">bool</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='dgemmSerial-fold-content-docs' class="fold-docs">
<span class="md-text">		dgemmSerial is serial matrix multiply</span>

</span></i></div><div class="anchor value-res hidden" id="name-dgemmSerialNotNot"><i>	<input type='checkbox' class="fold" id="dgemmSerialNotNot-fold-content"><label for="dgemmSerialNotNot-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..dgemmSerialNotNot^ec417.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/dgemm.go.html#line-237">dgemmSerialNotNot</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='dgemmSerialNotNot-fold-content-docs' class="fold-docs">
<span class="md-text">		dgemmSerial where neither a nor b are transposed</span>

</span></i></div><div class="anchor value-res hidden" id="name-dgemmSerialNotTrans"><i>	<input type='checkbox' class="fold" id="dgemmSerialNotTrans-fold-content"><label for="dgemmSerialNotTrans-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..dgemmSerialNotTrans^93b3b.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/dgemm.go.html#line-268">dgemmSerialNotTrans</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='dgemmSerialNotTrans-fold-content-docs' class="fold-docs">
<span class="md-text">		dgemmSerial where neither a is not transposed and b is</span>

</span></i></div><div class="anchor value-res hidden" id="name-dgemmSerialTransNot"><i>	<input type='checkbox' class="fold" id="dgemmSerialTransNot-fold-content"><label for="dgemmSerialTransNot-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..dgemmSerialTransNot^587cb.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/dgemm.go.html#line-252">dgemmSerialTransNot</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='dgemmSerialTransNot-fold-content-docs' class="fold-docs">
<span class="md-text">		dgemmSerial where neither a is transposed and b is not</span>

</span></i></div><div class="anchor value-res hidden" id="name-dgemmSerialTransTrans"><i>	<input type='checkbox' class="fold" id="dgemmSerialTransTrans-fold-content"><label for="dgemmSerialTransTrans-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..dgemmSerialTransTrans^44315.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/dgemm.go.html#line-281">dgemmSerialTransTrans</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='dgemmSerialTransTrans-fold-content-docs' class="fold-docs">
<span class="md-text">		dgemmSerial where both are transposed</span>

</span></i></div><div class="anchor value-res hidden" id="name-max"><i>	<span class="nodocs"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..max^9baf3.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/gonum.go.html#line-24">max</a>(a, b <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></span></i></div><div class="anchor value-res hidden" id="name-min"><i>	<span class="nodocs"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..min^1f6fa.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/gonum.go.html#line-31">min</a>(a, b <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></span></i></div><div class="anchor value-res hidden" id="name-scabs1"><i>	<input type='checkbox' class="fold" id="scabs1-fold-content"><label for="scabs1-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..scabs1^92974.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/gonum.go.html#line-50">scabs1</a>(z <a href="../../../../builtin.html#name-complex64">complex64</a>) <a href="../../../../builtin.html#name-float32">float32</a></label><span id='scabs1-fold-content-docs' class="fold-docs">
<span class="md-text">		scabs1 returns |real(z)|+|imag(z)|.</span>

</span></i></div><div class="anchor value-res hidden" id="name-sgemmParallel"><i>	<span class="nodocs"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..sgemmParallel^47460.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/sgemm.go.html#line-128">sgemmParallel</a>(aTrans, bTrans <a href="../../../../builtin.html#name-bool">bool</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float32">float32</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float32">float32</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>)</span></i></div><div class="anchor value-res hidden" id="name-sgemmSerial"><i>	<input type='checkbox' class="fold" id="sgemmSerial-fold-content"><label for="sgemmSerial-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..sgemmSerial^e25e2.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/sgemm.go.html#line-221">sgemmSerial</a>(aTrans, bTrans <a href="../../../../builtin.html#name-bool">bool</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float32">float32</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float32">float32</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>)</label><span id='sgemmSerial-fold-content-docs' class="fold-docs">
<span class="md-text">		sgemmSerial is serial matrix multiply</span>

</span></i></div><div class="anchor value-res hidden" id="name-sgemmSerialNotNot"><i>	<input type='checkbox' class="fold" id="sgemmSerialNotNot-fold-content"><label for="sgemmSerialNotNot-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..sgemmSerialNotNot^fe261.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/sgemm.go.html#line-241">sgemmSerialNotNot</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float32">float32</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float32">float32</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>)</label><span id='sgemmSerialNotNot-fold-content-docs' class="fold-docs">
<span class="md-text">		sgemmSerial where neither a nor b are transposed</span>

</span></i></div><div class="anchor value-res hidden" id="name-sgemmSerialNotTrans"><i>	<input type='checkbox' class="fold" id="sgemmSerialNotTrans-fold-content"><label for="sgemmSerialNotTrans-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..sgemmSerialNotTrans^3dbad.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/sgemm.go.html#line-272">sgemmSerialNotTrans</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float32">float32</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float32">float32</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>)</label><span id='sgemmSerialNotTrans-fold-content-docs' class="fold-docs">
<span class="md-text">		sgemmSerial where neither a is not transposed and b is</span>

</span></i></div><div class="anchor value-res hidden" id="name-sgemmSerialTransNot"><i>	<input type='checkbox' class="fold" id="sgemmSerialTransNot-fold-content"><label for="sgemmSerialTransNot-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..sgemmSerialTransNot^a64fc.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/sgemm.go.html#line-256">sgemmSerialTransNot</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float32">float32</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float32">float32</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>)</label><span id='sgemmSerialTransNot-fold-content-docs' class="fold-docs">
<span class="md-text">		sgemmSerial where neither a is transposed and b is not</span>

</span></i></div><div class="anchor value-res hidden" id="name-sgemmSerialTransTrans"><i>	<input type='checkbox' class="fold" id="sgemmSerialTransTrans-fold-content"><label for="sgemmSerialTransTrans-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..sgemmSerialTransTrans^ab13a.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/sgemm.go.html#line-285">sgemmSerialTransTrans</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float32">float32</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float32">float32</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float32">float32</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float32">float32</a>)</label><span id='sgemmSerialTransTrans-fold-content-docs' class="fold-docs">
<span class="md-text">		sgemmSerial where both are transposed</span>

</span></i></div><div class="anchor value-res hidden" id="name-sliceView32"><i>	<span class="nodocs"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..sliceView32^ed0dd.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/sgemm.go.html#line-299">sliceView32</a>(a []<a href="../../../../builtin.html#name-float32">float32</a>, lda, i, j, r, c <a href="../../../../builtin.html#name-int">int</a>) []<a href="../../../../builtin.html#name-float32">float32</a></span></i></div><div class="anchor value-res hidden" id="name-sliceView64"><i>	<span class="nodocs"> <a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..sliceView64^79802.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/dgemm.go.html#line-295">sliceView64</a>(a []<a href="../../../../builtin.html#name-float64">float64</a>, lda, i, j, r, c <a href="../../../../builtin.html#name-int">int</a>) []<a href="../../../../builtin.html#name-float64">float64</a></span></i></div></div>
<div id="exported-constants"><span class="title">Package-Level Constants<span class="title-stat"><i> (total 23, none are exported)</i></span></span>

	<input type='checkbox' class="showhide" id="unexported-constants-showhide"><i><label for="unexported-constants-showhide" class="show-inline">/* 23 unexporteds ... */</label><label for="unexported-constants-showhide" class="hide-inline">/* 23 unexporteds: */</label></i><div class="anchor value-res hidden" id="name-badDiag"><i>	<input type='checkbox' class="fold" id="badDiag-fold-content"><label for="badDiag-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..badDiag^79c17.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-21">badDiag</a> = "blas: illegal diagonal"</label><span id='badDiag-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badFlag"><i>	<input type='checkbox' class="fold" id="badFlag-fold-content"><label for="badFlag-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..badFlag^82a5a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-23">badFlag</a> = "blas: illegal rotm flag"</label><span id='badFlag-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdA"><i>	<input type='checkbox' class="fold" id="badLdA-fold-content"><label for="badLdA-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..badLdA^47124.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-25">badLdA</a> = "blas: bad leading dimension of A"</label><span id='badLdA-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdB"><i>	<input type='checkbox' class="fold" id="badLdB-fold-content"><label for="badLdB-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..badLdB^b6eed.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-26">badLdB</a> = "blas: bad leading dimension of B"</label><span id='badLdB-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdC"><i>	<input type='checkbox' class="fold" id="badLdC-fold-content"><label for="badLdC-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..badLdC^4796a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-27">badLdC</a> = "blas: bad leading dimension of C"</label><span id='badLdC-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badSide"><i>	<input type='checkbox' class="fold" id="badSide-fold-content"><label for="badSide-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..badSide^7168b.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-22">badSide</a> = "blas: illegal side"</label><span id='badSide-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badTranspose"><i>	<input type='checkbox' class="fold" id="badTranspose-fold-content"><label for="badTranspose-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..badTranspose^8c0fa.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-20">badTranspose</a> = "blas: illegal transpose"</label><span id='badTranspose-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badUplo"><i>	<input type='checkbox' class="fold" id="badUplo-fold-content"><label for="badUplo-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..badUplo^dbb29.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-19">badUplo</a> = "blas: illegal triangle"</label><span id='badUplo-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-blockSize"><i>	<input type='checkbox' class="fold" id="blockSize-fold-content"><label for="blockSize-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..blockSize^87af4.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/gonum.go.html#line-20">blockSize</a> = 64 // <span class="md-text">b x b matrix</span></label><span id='blockSize-fold-content-docs' class="fold-docs">
<span class="md-text">		[SD]gemm behavior constants. These are kept here to keep them out of the
		way during single precision code generation.</span>

</span></i></div><div class="anchor value-res hidden" id="name-kLLT0"><i>	<input type='checkbox' class="fold" id="kLLT0-fold-content"><label for="kLLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..kLLT0^3b1f1.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-16">kLLT0</a> = "blas: kL < 0"</label><span id='kLLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-kLT0"><i>	<input type='checkbox' class="fold" id="kLT0-fold-content"><label for="kLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..kLT0^82e4f.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-15">kLT0</a> = "blas: k < 0"</label><span id='kLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-kULT0"><i>	<input type='checkbox' class="fold" id="kULT0-fold-content"><label for="kULT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..kULT0^896c4.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-17">kULT0</a> = "blas: kU < 0"</label><span id='kULT0-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-minParBlock"><i>	<input type='checkbox' class="fold" id="minParBlock-fold-content"><label for="minParBlock-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..minParBlock^f0e34.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/gonum.go.html#line-21">minParBlock</a> = 4 // <span class="md-text">minimum number of blocks needed to go parallel</span></label><span id='minParBlock-fold-content-docs' class="fold-docs">
<span class="md-text">		[SD]gemm behavior constants. These are kept here to keep them out of the
		way during single precision code generation.</span>

</span></i></div><div class="anchor value-res hidden" id="name-mLT0"><i>	<input type='checkbox' class="fold" id="mLT0-fold-content"><label for="mLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..mLT0^ad35b.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-13">mLT0</a> = "blas: m < 0"</label><span id='mLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nLT0"><i>	<input type='checkbox' class="fold" id="nLT0-fold-content"><label for="nLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..nLT0^e9f5b.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-14">nLT0</a> = "blas: n < 0"</label><span id='nLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortA"><i>	<input type='checkbox' class="fold" id="shortA-fold-content"><label for="shortA-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..shortA^e8c8c.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-32">shortA</a> = "blas: insufficient length of a"</label><span id='shortA-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortAP"><i>	<input type='checkbox' class="fold" id="shortAP-fold-content"><label for="shortAP-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..shortAP^acd1e.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-31">shortAP</a> = "blas: insufficient length of ap"</label><span id='shortAP-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortB"><i>	<input type='checkbox' class="fold" id="shortB-fold-content"><label for="shortB-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..shortB^76b08.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-33">shortB</a> = "blas: insufficient length of b"</label><span id='shortB-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortC"><i>	<input type='checkbox' class="fold" id="shortC-fold-content"><label for="shortC-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..shortC^1dbc2.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-34">shortC</a> = "blas: insufficient length of c"</label><span id='shortC-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortX"><i>	<input type='checkbox' class="fold" id="shortX-fold-content"><label for="shortX-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..shortX^fc690.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-29">shortX</a> = "blas: insufficient length of x"</label><span id='shortX-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortY"><i>	<input type='checkbox' class="fold" id="shortY-fold-content"><label for="shortY-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..shortY^09545.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-30">shortY</a> = "blas: insufficient length of y"</label><span id='shortY-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-zeroIncX"><i>	<input type='checkbox' class="fold" id="zeroIncX-fold-content"><label for="zeroIncX-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..zeroIncX^da7c2.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-10">zeroIncX</a> = "blas: zero x index increment"</label><span id='zeroIncX-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-zeroIncY"><i>	<input type='checkbox' class="fold" id="zeroIncY-fold-content"><label for="zeroIncY-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/blas/gonum..zeroIncY^befad.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/blas/gonum/errors.go.html#line-11">zeroIncY</a> = "blas: zero y index increment"</label><span id='zeroIncY-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings used during parameter checks.
		This list is duplicated in netlib/blas/netlib. Keep in sync.</span>

</span></i></div></div></code></pre><pre id="footer">
<table><tr><td><img src="../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.7</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>