<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Package: gonum.org/v1/gonum/lapack/gonum</title>
<link href="../../../../../css/auto-v0.6.7.css" rel="stylesheet">
<script src="../../../../../jvs/golds-v0.6.7.js"></script>
<body onload="onPageLoad()"><div>

<pre id="package-details"><code><span style="font-size:xx-large;">package <b>gonum</b></span>

<span class="title">Import Path</span>
	<a href="../../../../../index.html#pkg-gonum.org/v1/gonum/lapack/gonum">gonum.org/v1/gonum/lapack/gonum</a><i> (on <a href="https://pkg.go.dev/gonum.org/v1/gonum/lapack/gonum" target="_blank">go.dev</a>)</i>

<span class="title">Dependency Relation</span>
	imports <a href="../../../../../dep/gonum.org/v1/gonum/lapack/gonum.html">6 packages</a>, and imported by <a href="../../../../../dep/gonum.org/v1/gonum/lapack/gonum.html#imported-by">one package</a>

<div id="files"><span class="title">Involved Source Files</span>

	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dbdsqr.go.html">dbdsqr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgebak.go.html">dgebak.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgebal.go.html">dgebal.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgebd2.go.html">dgebd2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgebrd.go.html">dgebrd.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgecon.go.html">dgecon.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgeev.go.html">dgeev.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgehd2.go.html">dgehd2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgehrd.go.html">dgehrd.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgelq2.go.html">dgelq2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgelqf.go.html">dgelqf.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgels.go.html">dgels.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgeql2.go.html">dgeql2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgeqp3.go.html">dgeqp3.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgeqr2.go.html">dgeqr2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgeqrf.go.html">dgeqrf.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgerq2.go.html">dgerq2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgerqf.go.html">dgerqf.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgesc2.go.html">dgesc2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgesv.go.html">dgesv.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgesvd.go.html">dgesvd.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgetc2.go.html">dgetc2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgetf2.go.html">dgetf2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgetrf.go.html">dgetrf.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgetri.go.html">dgetri.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgetrs.go.html">dgetrs.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dggsvd3.go.html">dggsvd3.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dggsvp3.go.html">dggsvp3.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgtsv.go.html">dgtsv.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dhseqr.go.html">dhseqr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlabrd.go.html">dlabrd.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlacn2.go.html">dlacn2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlacpy.go.html">dlacpy.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlae2.go.html">dlae2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaev2.go.html">dlaev2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaexc.go.html">dlaexc.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlag2.go.html">dlag2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlags2.go.html">dlags2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlagtm.go.html">dlagtm.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlahqr.go.html">dlahqr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlahr2.go.html">dlahr2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaln2.go.html">dlaln2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlangb.go.html">dlangb.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlange.go.html">dlange.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlangt.go.html">dlangt.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlansb.go.html">dlansb.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlanst.go.html">dlanst.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlansy.go.html">dlansy.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlantb.go.html">dlantb.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlantr.go.html">dlantr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlanv2.go.html">dlanv2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlapll.go.html">dlapll.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlapmr.go.html">dlapmr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlapmt.go.html">dlapmt.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlapy2.go.html">dlapy2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaqp2.go.html">dlaqp2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaqps.go.html">dlaqps.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaqr04.go.html">dlaqr04.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaqr1.go.html">dlaqr1.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaqr23.go.html">dlaqr23.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaqr5.go.html">dlaqr5.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlarf.go.html">dlarf.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlarfb.go.html">dlarfb.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlarfg.go.html">dlarfg.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlarft.go.html">dlarft.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlarfx.go.html">dlarfx.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlartg.go.html">dlartg.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlas2.go.html">dlas2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlascl.go.html">dlascl.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaset.go.html">dlaset.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasq1.go.html">dlasq1.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasq2.go.html">dlasq2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasq3.go.html">dlasq3.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasq4.go.html">dlasq4.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasq5.go.html">dlasq5.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasq6.go.html">dlasq6.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasr.go.html">dlasr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasrt.go.html">dlasrt.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlassq.go.html">dlassq.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasv2.go.html">dlasv2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaswp.go.html">dlaswp.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasy2.go.html">dlasy2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlatbs.go.html">dlatbs.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlatdf.go.html">dlatdf.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlatrd.go.html">dlatrd.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlatrs.go.html">dlatrs.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlauu2.go.html">dlauu2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlauum.go.html">dlauum.go</a></span>
	<input type='checkbox' checked class="fold" id="file-88-fold-content"><label for="file-88-fold-content">  <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/doc.go.html#doc">d</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/doc.go.html">doc.go</a></label><span id='file-88-fold-content-items' class="fold-items">
<span class="md-text">		Package gonum is a pure-go implementation of the LAPACK API. The LAPACK API defines
		a set of algorithms for advanced matrix operations.
		
		The function definitions and implementations follow that of the netlib reference
		implementation. See http://www.netlib.org/lapack/explore-html/ for more
		information, and http://www.netlib.org/lapack/explore-html/d4/de1/_l_i_c_e_n_s_e_source.html
		for more license information.
		
		Slice function arguments frequently represent vectors and matrices. The data
		layout is identical to that found in https://pkg.go.dev/gonum.org/v1/gonum/blas/gonum.
		
		Most LAPACK functions are built on top the routines defined in the BLAS API,
		and as such the computation time for many LAPACK functions is
		dominated by BLAS calls. Here, BLAS is accessed through the
		blas64 package (https://pkg.go.dev/gonum.org/v1/gonum/blas/blas64). In particular,
		this implies that an external BLAS library will be used if it is
		registered in blas64.
		
		The full LAPACK capability has not been implemented at present. The full
		API is very large, containing approximately 200 functions for double precision
		alone. Future additions will be focused on supporting the Gonum matrix
		package (https://pkg.go.dev/gonum.org/v1/gonum/mat), though pull requests
		with implementations and tests for LAPACK function are encouraged.</span>
</span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorg2l.go.html">dorg2l.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorg2r.go.html">dorg2r.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorgbr.go.html">dorgbr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorghr.go.html">dorghr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorgl2.go.html">dorgl2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorglq.go.html">dorglq.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorgql.go.html">dorgql.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorgqr.go.html">dorgqr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorgr2.go.html">dorgr2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorgtr.go.html">dorgtr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorm2r.go.html">dorm2r.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dormbr.go.html">dormbr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dormhr.go.html">dormhr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorml2.go.html">dorml2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dormlq.go.html">dormlq.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dormqr.go.html">dormqr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dormr2.go.html">dormr2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpbcon.go.html">dpbcon.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpbtf2.go.html">dpbtf2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpbtrf.go.html">dpbtrf.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpbtrs.go.html">dpbtrs.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpocon.go.html">dpocon.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpotf2.go.html">dpotf2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpotrf.go.html">dpotrf.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpotri.go.html">dpotri.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpotrs.go.html">dpotrs.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpstf2.go.html">dpstf2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpstrf.go.html">dpstrf.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/drscl.go.html">drscl.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dsteqr.go.html">dsteqr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dsterf.go.html">dsterf.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dsyev.go.html">dsyev.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dsytd2.go.html">dsytd2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dsytrd.go.html">dsytrd.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtbtrs.go.html">dtbtrs.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtgsja.go.html">dtgsja.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtrcon.go.html">dtrcon.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtrevc3.go.html">dtrevc3.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtrexc.go.html">dtrexc.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtrti2.go.html">dtrti2.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtrtri.go.html">dtrtri.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtrtrs.go.html">dtrtrs.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html">errors.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/iladlc.go.html">iladlc.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/iladlr.go.html">iladlr.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/ilaenv.go.html">ilaenv.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/iparmq.go.html">iparmq.go</a></span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html">lapack.go</a></span></div>
<div id="exported-types"><span class="title">Package-Level Type Names<span class="title-stat"><i> (only one, which is exported)</i></span></span>

<div id="exported-types-buttons" class="js-on">	/* sort exporteds by: <label id="sort-types-by-alphabet" class="button">alphabet</label> | <label id="sort-types-by-popularity" class="button">popularity</label> */</div><div class="anchor type-res" id="name-Implementation" data-popularity="6750">	<input type='checkbox' class="fold" id="Implementation-fold-content"><label for="Implementation-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..Implementation.html">type</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html#line-12">Implementation</a> <i>(struct)</i></label><span id='Implementation-fold-content-docs' class="fold-docs">
<span class="md-text">		Implementation is the native Go implementation of LAPACK routines. It
		is built on top of calls to the return of blas64.Implementation(), so while
		this code is in pure Go, the underlying BLAS implementation may not be.</span>

		<input type='checkbox' class="fold" id="Implementation-fold-methods"><label for="Implementation-fold-methods">Methods (<i>total 134, all are exported</i>)</label><span id='Implementation-fold-methods-items' class="fold-items"><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dbdsqr"><label for="Implementation-fold-method-Dbdsqr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dbdsqr.go.html#line-55">Dbdsqr</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n, ncvt, nru, ncc <a href="../../../../builtin.html#name-int">int</a>, d, e, vt []<a href="../../../../builtin.html#name-float64">float64</a>, ldvt <a href="../../../../builtin.html#name-int">int</a>, u []<a href="../../../../builtin.html#name-float64">float64</a>, ldu <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dbdsqr-docs' class="fold-docs">
<span class="md-text">				Dbdsqr performs a singular value decomposition of a real n×n bidiagonal matrix.
				
				The SVD of the bidiagonal matrix B is
				
					B = Q * S * Pᵀ
				
				where S is a diagonal matrix of singular values, Q is an orthogonal matrix of
				left singular vectors, and P is an orthogonal matrix of right singular vectors.
				
				Q and P are only computed if requested. If left singular vectors are requested,
				this routine returns U * Q instead of Q, and if right singular vectors are
				requested Pᵀ * VT is returned instead of Pᵀ.
				
				Frequently Dbdsqr is used in conjunction with Dgebrd which reduces a general
				matrix A into bidiagonal form. In this case, the SVD of A is
				
					A = (U * Q) * S * (Pᵀ * VT)
				
				This routine may also compute Qᵀ * C.
				
				d and e contain the elements of the bidiagonal matrix b. d must have length at
				least n, and e must have length at least n-1. Dbdsqr will panic if there is
				insufficient length. On exit, D contains the singular values of B in decreasing
				order.
				
				VT is a matrix of size n×ncvt whose elements are stored in vt. The elements
				of vt are modified to contain Pᵀ * VT on exit. VT is not used if ncvt == 0.
				
				U is a matrix of size nru×n whose elements are stored in u. The elements
				of u are modified to contain U * Q on exit. U is not used if nru == 0.
				
				C is a matrix of size n×ncc whose elements are stored in c. The elements
				of c are modified to contain Qᵀ * C on exit. C is not used if ncc == 0.
				
				work contains temporary storage and must have length at least 4*(n-1). Dbdsqr
				will panic if there is insufficient working memory.
				
				Dbdsqr returns whether the decomposition was successful.
				
				Dbdsqr is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgebak"><label for="Implementation-fold-method-Dgebak">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgebak.go.html#line-25">Dgebak</a>(job <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-BalanceJob">BalanceJob</a>, side <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-EVSide">EVSide</a>, n, ilo, ihi <a href="../../../../builtin.html#name-int">int</a>, scale []<a href="../../../../builtin.html#name-float64">float64</a>, m <a href="../../../../builtin.html#name-int">int</a>, v []<a href="../../../../builtin.html#name-float64">float64</a>, ldv <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgebak-docs' class="fold-docs">
<span class="md-text">				Dgebak updates an n×m matrix V as
				
					V = P D V       if side == lapack.EVRight,
					V = P D^{-1} V  if side == lapack.EVLeft,
				
				where P and D are n×n permutation and scaling matrices, respectively,
				implicitly represented by job, scale, ilo and ihi as returned by Dgebal.
				
				Typically, columns of the matrix V contain the right or left (determined by
				side) eigenvectors of the balanced matrix output by Dgebal, and Dgebak forms
				the eigenvectors of the original matrix.
				
				Dgebak is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgebal"><label for="Implementation-fold-method-Dgebal">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgebal.go.html#line-66">Dgebal</a>(job <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-BalanceJob">BalanceJob</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, scale []<a href="../../../../builtin.html#name-float64">float64</a>) (ilo, ihi <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgebal-docs' class="fold-docs">
<span class="md-text">				Dgebal balances an n×n matrix A. Balancing consists of two stages, permuting
				and scaling. Both steps are optional and depend on the value of job.
				
				Permuting consists of applying a permutation matrix P such that the matrix
				that results from Pᵀ*A*P takes the upper block triangular form
				
					         [ T1  X  Y  ]
					Pᵀ A P = [  0  B  Z  ],
					         [  0  0  T2 ]
				
				where T1 and T2 are upper triangular matrices and B contains at least one
				nonzero off-diagonal element in each row and column. The indices ilo and ihi
				mark the starting and ending columns of the submatrix B. The eigenvalues of A
				isolated in the first 0 to ilo-1 and last ihi+1 to n-1 elements on the
				diagonal can be read off without any roundoff error.
				
				Scaling consists of applying a diagonal similarity transformation D such that
				D^{-1}*B*D has the 1-norm of each row and its corresponding column nearly
				equal. The output matrix is
				
					[ T1     X*D          Y    ]
					[  0  inv(D)*B*D  inv(D)*Z ].
					[  0      0           T2   ]
				
				Scaling may reduce the 1-norm of the matrix, and improve the accuracy of
				the computed eigenvalues and/or eigenvectors.
				
				job specifies the operations that will be performed on A.
				If job is lapack.BalanceNone, Dgebal sets scale[i] = 1 for all i and returns ilo=0, ihi=n-1.
				If job is lapack.Permute, only permuting will be done.
				If job is lapack.Scale, only scaling will be done.
				If job is lapack.PermuteScale, both permuting and scaling will be done.
				
				On return, if job is lapack.Permute or lapack.PermuteScale, it will hold that
				
					A[i,j] == 0,   for i &gt; j and j ∈ {0, ..., ilo-1, ihi+1, ..., n-1}.
				
				If job is lapack.BalanceNone or lapack.Scale, or if n == 0, it will hold that
				
					ilo == 0 and ihi == n-1.
				
				On return, scale will contain information about the permutations and scaling
				factors applied to A. If π(j) denotes the index of the column interchanged
				with column j, and D[j,j] denotes the scaling factor applied to column j,
				then
				
					scale[j] == π(j),     for j ∈ {0, ..., ilo-1, ihi+1, ..., n-1},
					         == D[j,j],   for j ∈ {ilo, ..., ihi}.
				
				scale must have length equal to n, otherwise Dgebal will panic.
				
				Dgebal is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgebd2"><label for="Implementation-fold-method-Dgebd2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgebd2.go.html#line-19">Dgebd2</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, d, e, tauQ, tauP, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dgebd2-docs' class="fold-docs">
<span class="md-text">				Dgebd2 reduces an m×n matrix A to upper or lower bidiagonal form by an orthogonal
				transformation.
				
					Qᵀ * A * P = B
				
				if m &gt;= n, B is upper diagonal, otherwise B is lower bidiagonal.
				d is the diagonal, len = min(m,n)
				e is the off-diagonal len = min(m,n)-1
				
				Dgebd2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgebrd"><label for="Implementation-fold-method-Dgebrd">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgebrd.go.html#line-63">Dgebrd</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, d, e, tauQ, tauP, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgebrd-docs' class="fold-docs">
<span class="md-text">				Dgebrd reduces a general m×n matrix A to upper or lower bidiagonal form B by
				an orthogonal transformation:
				
					Qᵀ * A * P = B.
				
				The diagonal elements of B are stored in d and the off-diagonal elements are stored
				in e. These are additionally stored along the diagonal of A and the off-diagonal
				of A. If m &gt;= n B is an upper-bidiagonal matrix, and if m &lt; n B is a
				lower-bidiagonal matrix.
				
				The remaining elements of A store the data needed to construct Q and P.
				The matrices Q and P are products of elementary reflectors
				
					if m &gt;= n, Q = H_0 * H_1 * ... * H_{n-1},
					           P = G_0 * G_1 * ... * G_{n-2},
					if m &lt; n,  Q = H_0 * H_1 * ... * H_{m-2},
					           P = G_0 * G_1 * ... * G_{m-1},
				
				where
				
					H_i = I - tauQ[i] * v_i * v_iᵀ,
					G_i = I - tauP[i] * u_i * u_iᵀ.
				
				As an example, on exit the entries of A when m = 6, and n = 5
				
					[ d   e  u1  u1  u1]
					[v1   d   e  u2  u2]
					[v1  v2   d   e  u3]
					[v1  v2  v3   d   e]
					[v1  v2  v3  v4   d]
					[v1  v2  v3  v4  v5]
				
				and when m = 5, n = 6
				
					[ d  u1  u1  u1  u1  u1]
					[ e   d  u2  u2  u2  u2]
					[v1   e   d  u3  u3  u3]
					[v1  v2   e   d  u4  u4]
					[v1  v2  v3   e   d  u5]
				
				d, tauQ, and tauP must all have length at least min(m,n), and e must have
				length min(m,n) - 1, unless lwork is -1 when there is no check except for
				work which must have a length of at least one.
				
				work is temporary storage, and lwork specifies the usable memory length.
				At minimum, lwork &gt;= max(1,m,n) or be -1 and this function will panic otherwise.
				Dgebrd is blocked decomposition, but the block size is limited
				by the temporary space available. If lwork == -1, instead of performing Dgebrd,
				the optimal work length will be stored into work[0].
				
				Dgebrd is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgecon"><label for="Implementation-fold-method-Dgecon">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgecon.go.html#line-26">Dgecon</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, anorm <a href="../../../../builtin.html#name-float64">float64</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, iwork []<a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dgecon-docs' class="fold-docs">
<span class="md-text">				Dgecon estimates the reciprocal of the condition number of the n×n matrix A
				given the LU decomposition of the matrix. The condition number computed may
				be based on the 1-norm or the ∞-norm.
				
				The slice a contains the result of the LU decomposition of A as computed by Dgetrf.
				
				anorm is the corresponding 1-norm or ∞-norm of the original matrix A. anorm
				must be non-negative.
				
				work must have length at least 4*n and iwork must have length at least n,
				otherwise Dgecon will panic.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgeev"><label for="Implementation-fold-method-Dgeev">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgeev.go.html#line-71">Dgeev</a>(jobvl <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-LeftEVJob">LeftEVJob</a>, jobvr <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-RightEVJob">RightEVJob</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, wr, wi []<a href="../../../../builtin.html#name-float64">float64</a>, vl []<a href="../../../../builtin.html#name-float64">float64</a>, ldvl <a href="../../../../builtin.html#name-int">int</a>, vr []<a href="../../../../builtin.html#name-float64">float64</a>, ldvr <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) (first <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgeev-docs' class="fold-docs">
<span class="md-text">				Dgeev computes the eigenvalues and, optionally, the left and/or right
				eigenvectors for an n×n real nonsymmetric matrix A.
				
				The right eigenvector v_j of A corresponding to an eigenvalue λ_j
				is defined by
				
					A v_j = λ_j v_j,
				
				and the left eigenvector u_j corresponding to an eigenvalue λ_j is defined by
				
					u_jᴴ A = λ_j u_jᴴ,
				
				where u_jᴴ is the conjugate transpose of u_j.
				
				On return, A will be overwritten and the left and right eigenvectors will be
				stored, respectively, in the columns of the n×n matrices VL and VR in the
				same order as their eigenvalues. If the j-th eigenvalue is real, then
				
					u_j = VL[:,j],
					v_j = VR[:,j],
				
				and if it is not real, then j and j+1 form a complex conjugate pair and the
				eigenvectors can be recovered as
				
					u_j     = VL[:,j] + i*VL[:,j+1],
					u_{j+1} = VL[:,j] - i*VL[:,j+1],
					v_j     = VR[:,j] + i*VR[:,j+1],
					v_{j+1} = VR[:,j] - i*VR[:,j+1],
				
				where i is the imaginary unit. The computed eigenvectors are normalized to
				have Euclidean norm equal to 1 and largest component real.
				
				Left eigenvectors will be computed only if jobvl == lapack.LeftEVCompute,
				otherwise jobvl must be lapack.LeftEVNone.
				Right eigenvectors will be computed only if jobvr == lapack.RightEVCompute,
				otherwise jobvr must be lapack.RightEVNone.
				For other values of jobvl and jobvr Dgeev will panic.
				
				wr and wi contain the real and imaginary parts, respectively, of the computed
				eigenvalues. Complex conjugate pairs of eigenvalues appear consecutively with
				the eigenvalue having the positive imaginary part first.
				wr and wi must have length n, and Dgeev will panic otherwise.
				
				work must have length at least lwork and lwork must be at least max(1,4*n) if
				the left or right eigenvectors are computed, and at least max(1,3*n) if no
				eigenvectors are computed. For good performance, lwork must generally be
				larger.  On return, optimal value of lwork will be stored in work[0].
				
				If lwork == -1, instead of performing Dgeev, the function only calculates the
				optimal value of lwork and stores it into work[0].
				
				On return, first is the index of the first valid eigenvalue. If first == 0,
				all eigenvalues and eigenvectors have been computed. If first is positive,
				Dgeev failed to compute all the eigenvalues, no eigenvectors have been
				computed and wr[first:] and wi[first:] contain those eigenvalues which have
				converged.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgehd2"><label for="Implementation-fold-method-Dgehd2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgehd2.go.html#line-66">Dgehd2</a>(n, ilo, ihi <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dgehd2-docs' class="fold-docs">
<span class="md-text">				Dgehd2 reduces a block of a general n×n matrix A to upper Hessenberg form H
				by an orthogonal similarity transformation Qᵀ * A * Q = H.
				
				The matrix Q is represented as a product of (ihi-ilo) elementary
				reflectors
				
					Q = H_{ilo} H_{ilo+1} ... H_{ihi-1}.
				
				Each H_i has the form
				
					H_i = I - tau[i] * v * vᵀ
				
				where v is a real vector with v[0:i+1] = 0, v[i+1] = 1 and v[ihi+1:n] = 0.
				v[i+2:ihi+1] is stored on exit in A[i+2:ihi+1,i].
				
				On entry, a contains the n×n general matrix to be reduced. On return, the
				upper triangle and the first subdiagonal of A are overwritten with the upper
				Hessenberg matrix H, and the elements below the first subdiagonal, with the
				slice tau, represent the orthogonal matrix Q as a product of elementary
				reflectors.
				
				The contents of A are illustrated by the following example, with n = 7, ilo =
				1 and ihi = 5.
				On entry,
				
					[ a   a   a   a   a   a   a ]
					[     a   a   a   a   a   a ]
					[     a   a   a   a   a   a ]
					[     a   a   a   a   a   a ]
					[     a   a   a   a   a   a ]
					[     a   a   a   a   a   a ]
					[                         a ]
				
				on return,
				
					[ a   a   h   h   h   h   a ]
					[     a   h   h   h   h   a ]
					[     h   h   h   h   h   h ]
					[     v1  h   h   h   h   h ]
					[     v1  v2  h   h   h   h ]
					[     v1  v2  v3  h   h   h ]
					[                         a ]
				
				where a denotes an element of the original matrix A, h denotes a
				modified element of the upper Hessenberg matrix H, and vi denotes an
				element of the vector defining H_i.
				
				ilo and ihi determine the block of A that will be reduced to upper Hessenberg
				form. It must hold that 0 &lt;= ilo &lt;= ihi &lt;= max(0, n-1), otherwise Dgehd2 will
				panic.
				
				On return, tau will contain the scalar factors of the elementary reflectors.
				It must have length equal to n-1, otherwise Dgehd2 will panic.
				
				work must have length at least n, otherwise Dgehd2 will panic.
				
				Dgehd2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgehrd"><label for="Implementation-fold-method-Dgehrd">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgehrd.go.html#line-76">Dgehrd</a>(n, ilo, ihi <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgehrd-docs' class="fold-docs">
<span class="md-text">				Dgehrd reduces a block of a real n×n general matrix A to upper Hessenberg
				form H by an orthogonal similarity transformation Qᵀ * A * Q = H.
				
				The matrix Q is represented as a product of (ihi-ilo) elementary
				reflectors
				
					Q = H_{ilo} H_{ilo+1} ... H_{ihi-1}.
				
				Each H_i has the form
				
					H_i = I - tau[i] * v * vᵀ
				
				where v is a real vector with v[0:i+1] = 0, v[i+1] = 1 and v[ihi+1:n] = 0.
				v[i+2:ihi+1] is stored on exit in A[i+2:ihi+1,i].
				
				On entry, a contains the n×n general matrix to be reduced. On return, the
				upper triangle and the first subdiagonal of A will be overwritten with the
				upper Hessenberg matrix H, and the elements below the first subdiagonal, with
				the slice tau, represent the orthogonal matrix Q as a product of elementary
				reflectors.
				
				The contents of a are illustrated by the following example, with n = 7, ilo =
				1 and ihi = 5.
				On entry,
				
					[ a   a   a   a   a   a   a ]
					[     a   a   a   a   a   a ]
					[     a   a   a   a   a   a ]
					[     a   a   a   a   a   a ]
					[     a   a   a   a   a   a ]
					[     a   a   a   a   a   a ]
					[                         a ]
				
				on return,
				
					[ a   a   h   h   h   h   a ]
					[     a   h   h   h   h   a ]
					[     h   h   h   h   h   h ]
					[     v1  h   h   h   h   h ]
					[     v1  v2  h   h   h   h ]
					[     v1  v2  v3  h   h   h ]
					[                         a ]
				
				where a denotes an element of the original matrix A, h denotes a
				modified element of the upper Hessenberg matrix H, and vi denotes an
				element of the vector defining H_i.
				
				ilo and ihi determine the block of A that will be reduced to upper Hessenberg
				form. It must hold that 0 &lt;= ilo &lt;= ihi &lt; n if n &gt; 0, and ilo == 0 and ihi ==
				-1 if n == 0, otherwise Dgehrd will panic.
				
				On return, tau will contain the scalar factors of the elementary reflectors.
				Elements tau[:ilo] and tau[ihi:] will be set to zero. tau must have length
				equal to n-1 if n &gt; 0, otherwise Dgehrd will panic.
				
				work must have length at least lwork and lwork must be at least max(1,n),
				otherwise Dgehrd will panic. On return, work[0] contains the optimal value of
				lwork.
				
				If lwork == -1, instead of performing Dgehrd, only the optimal value of lwork
				will be stored in work[0].
				
				Dgehrd is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgelq2"><label for="Implementation-fold-method-Dgelq2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgelq2.go.html#line-27">Dgelq2</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dgelq2-docs' class="fold-docs">
<span class="md-text">				Dgelq2 computes the LQ factorization of the m×n matrix A.
				
				In an LQ factorization, L is a lower triangular m×n matrix, and Q is an n×n
				orthonormal matrix.
				
				a is modified to contain the information to construct L and Q.
				The lower triangle of a contains the matrix L. The upper triangular elements
				(not including the diagonal) contain the elementary reflectors. tau is modified
				to contain the reflector scales. tau must have length of at least k = min(m,n)
				and this function will panic otherwise.
				
				See Dgeqr2 for a description of the elementary reflectors and orthonormal
				matrix Q. Q is constructed as a product of these elementary reflectors,
				Q = H_{k-1} * ... * H_1 * H_0.
				
				work is temporary storage of length at least m and this function will panic otherwise.
				
				Dgelq2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgelqf"><label for="Implementation-fold-method-Dgelqf">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgelqf.go.html#line-23">Dgelqf</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgelqf-docs' class="fold-docs">
<span class="md-text">				Dgelqf computes the LQ factorization of the m×n matrix A using a blocked
				algorithm. See the documentation for Dgelq2 for a description of the
				parameters at entry and exit.
				
				work is temporary storage, and lwork specifies the usable memory length.
				At minimum, lwork &gt;= m, and this function will panic otherwise.
				Dgelqf is a blocked LQ factorization, but the block size is limited
				by the temporary space available. If lwork == -1, instead of performing Dgelqf,
				the optimal work length will be stored into work[0].
				
				tau must have length at least min(m,n), and this function will panic otherwise.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgels"><label for="Implementation-fold-method-Dgels">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgels.go.html#line-42">Dgels</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, nrhs <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-bool">bool</a></label><span id='Implementation-fold-method-Dgels-docs' class="fold-docs">
<span class="md-text">				Dgels finds a minimum-norm solution based on the matrices A and B using the
				QR or LQ factorization. Dgels returns false if the matrix
				A is singular, and true if this solution was successfully found.
				
				The minimization problem solved depends on the input parameters.
				
				 1. If m &gt;= n and trans == blas.NoTrans, Dgels finds X such that || A*X - B||_2
				    is minimized.
				 2. If m &lt; n and trans == blas.NoTrans, Dgels finds the minimum norm solution of
				    A * X = B.
				 3. If m &gt;= n and trans == blas.Trans, Dgels finds the minimum norm solution of
				    Aᵀ * X = B.
				 4. If m &lt; n and trans == blas.Trans, Dgels finds X such that || A*X - B||_2
				    is minimized.
				
				Note that the least-squares solutions (cases 1 and 3) perform the minimization
				per column of B. This is not the same as finding the minimum-norm matrix.
				
				The matrix A is a general matrix of size m×n and is modified during this call.
				The input matrix B is of size max(m,n)×nrhs, and serves two purposes. On entry,
				the elements of b specify the input matrix B. B has size m×nrhs if
				trans == blas.NoTrans, and n×nrhs if trans == blas.Trans. On exit, the
				leading submatrix of b contains the solution vectors X. If trans == blas.NoTrans,
				this submatrix is of size n×nrhs, and of size m×nrhs otherwise.
				
				work is temporary storage, and lwork specifies the usable memory length.
				At minimum, lwork &gt;= max(m,n) + max(m,n,nrhs), and this function will panic
				otherwise. A longer work will enable blocked algorithms to be called.
				In the special case that lwork == -1, work[0] will be set to the optimal working
				length.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgeql2"><label for="Implementation-fold-method-Dgeql2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgeql2.go.html#line-32">Dgeql2</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dgeql2-docs' class="fold-docs">
<span class="md-text">				Dgeql2 computes the QL factorization of the m×n matrix A. That is, Dgeql2
				computes Q and L such that
				
					A = Q * L
				
				where Q is an m×m orthonormal matrix and L is a lower trapezoidal matrix.
				
				Q is represented as a product of elementary reflectors,
				
					Q = H_{k-1} * ... * H_1 * H_0
				
				where k = min(m,n) and each H_i has the form
				
					H_i = I - tau[i] * v_i * v_iᵀ
				
				Vector v_i has v[m-k+i+1:m] = 0, v[m-k+i] = 1, and v[:m-k+i+1] is stored on
				exit in A[0:m-k+i-1, n-k+i].
				
				tau must have length at least min(m,n), and Dgeql2 will panic otherwise.
				
				work is temporary memory storage and must have length at least n.
				
				Dgeql2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgeqp3"><label for="Implementation-fold-method-Dgeqp3">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgeqp3.go.html#line-46">Dgeqp3</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, jpvt []<a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgeqp3-docs' class="fold-docs">
<span class="md-text">				Dgeqp3 computes a QR factorization with column pivoting of the
				m×n matrix A: A*P = Q*R using Level 3 BLAS.
				
				The matrix Q is represented as a product of elementary reflectors
				
					Q = H_0 H_1 . . . H_{k-1}, where k = min(m,n).
				
				Each H_i has the form
				
					H_i = I - tau * v * vᵀ
				
				where tau and v are real vectors with v[0:i-1] = 0 and v[i] = 1;
				v[i:m] is stored on exit in A[i:m, i], and tau in tau[i].
				
				jpvt specifies a column pivot to be applied to A. If
				jpvt[j] is at least zero, the jth column of A is permuted
				to the front of A*P (a leading column), if jpvt[j] is -1
				the jth column of A is a free column. If jpvt[j] &lt; -1, Dgeqp3
				will panic. On return, jpvt holds the permutation that was
				applied; the jth column of A*P was the jpvt[j] column of A.
				jpvt must have length n or Dgeqp3 will panic.
				
				tau holds the scalar factors of the elementary reflectors.
				It must have length min(m, n), otherwise Dgeqp3 will panic.
				
				work must have length at least max(1,lwork), and lwork must be at least
				3*n+1, otherwise Dgeqp3 will panic. For optimal performance lwork must
				be at least 2*n+(n+1)*nb, where nb is the optimal blocksize. On return,
				work[0] will contain the optimal value of lwork.
				
				If lwork == -1, instead of performing Dgeqp3, only the optimal value of lwork
				will be stored in work[0].
				
				Dgeqp3 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgeqr2"><label for="Implementation-fold-method-Dgeqr2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgeqr2.go.html#line-35">Dgeqr2</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dgeqr2-docs' class="fold-docs">
<span class="md-text">				Dgeqr2 computes a QR factorization of the m×n matrix A.
				
				In a QR factorization, Q is an m×m orthonormal matrix, and R is an
				upper triangular m×n matrix.
				
				A is modified to contain the information to construct Q and R.
				The upper triangle of a contains the matrix R. The lower triangular elements
				(not including the diagonal) contain the elementary reflectors. tau is modified
				to contain the reflector scales. tau must have length at least min(m,n), and
				this function will panic otherwise.
				
				The ith elementary reflector can be explicitly constructed by first extracting
				the
				
					v[j] = 0           j &lt; i
					v[j] = 1           j == i
					v[j] = a[j*lda+i]  j &gt; i
				
				and computing H_i = I - tau[i] * v * vᵀ.
				
				The orthonormal matrix Q can be constructed from a product of these elementary
				reflectors, Q = H_0 * H_1 * ... * H_{k-1}, where k = min(m,n).
				
				work is temporary storage of length at least n and this function will panic otherwise.
				
				Dgeqr2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgeqrf"><label for="Implementation-fold-method-Dgeqrf">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgeqrf.go.html#line-24">Dgeqrf</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgeqrf-docs' class="fold-docs">
<span class="md-text">				Dgeqrf computes the QR factorization of the m×n matrix A using a blocked
				algorithm. See the documentation for Dgeqr2 for a description of the
				parameters at entry and exit.
				
				work is temporary storage, and lwork specifies the usable memory length.
				The length of work must be at least max(1, lwork) and lwork must be -1
				or at least n, otherwise this function will panic.
				Dgeqrf is a blocked QR factorization, but the block size is limited
				by the temporary space available. If lwork == -1, instead of performing Dgeqrf,
				the optimal work length will be stored into work[0].
				
				tau must have length at least min(m,n), and this function will panic otherwise.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgerq2"><label for="Implementation-fold-method-Dgerq2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgerq2.go.html#line-36">Dgerq2</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dgerq2-docs' class="fold-docs">
<span class="md-text">				Dgerq2 computes an RQ factorization of the m×n matrix A,
				
					A = R * Q.
				
				On exit, if m &lt;= n, the upper triangle of the subarray
				A[0:m, n-m:n] contains the m×m upper triangular matrix R.
				If m &gt;= n, the elements on and above the (m-n)-th subdiagonal
				contain the m×n upper trapezoidal matrix R.
				The remaining elements, with tau, represent the
				orthogonal matrix Q as a product of min(m,n) elementary
				reflectors.
				
				The matrix Q is represented as a product of elementary reflectors
				
					Q = H_0 H_1 . . . H_{min(m,n)-1}.
				
				Each H(i) has the form
				
					H_i = I - tau_i * v * vᵀ
				
				where v is a vector with v[0:n-k+i-1] stored in A[m-k+i, 0:n-k+i-1],
				v[n-k+i:n] = 0 and v[n-k+i] = 1.
				
				tau must have length min(m,n) and work must have length m, otherwise
				Dgerq2 will panic.
				
				Dgerq2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgerqf"><label for="Implementation-fold-method-Dgerqf">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgerqf.go.html#line-40">Dgerqf</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgerqf-docs' class="fold-docs">
<span class="md-text">				Dgerqf computes an RQ factorization of the m×n matrix A,
				
					A = R * Q.
				
				On exit, if m &lt;= n, the upper triangle of the subarray
				A[0:m, n-m:n] contains the m×m upper triangular matrix R.
				If m &gt;= n, the elements on and above the (m-n)-th subdiagonal
				contain the m×n upper trapezoidal matrix R.
				The remaining elements, with tau, represent the
				orthogonal matrix Q as a product of min(m,n) elementary
				reflectors.
				
				The matrix Q is represented as a product of elementary reflectors
				
					Q = H_0 H_1 . . . H_{min(m,n)-1}.
				
				Each H(i) has the form
				
					H_i = I - tau_i * v * vᵀ
				
				where v is a vector with v[0:n-k+i-1] stored in A[m-k+i, 0:n-k+i-1],
				v[n-k+i:n] = 0 and v[n-k+i] = 1.
				
				tau must have length min(m,n), work must have length max(1, lwork),
				and lwork must be -1 or at least max(1, m), otherwise Dgerqf will panic.
				On exit, work[0] will contain the optimal length for work.
				
				Dgerqf is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgesc2"><label for="Implementation-fold-method-Dgesc2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgesc2.go.html#line-34">Dgesc2</a>(n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, rhs []<a href="../../../../builtin.html#name-float64">float64</a>, ipiv, jpiv []<a href="../../../../builtin.html#name-int">int</a>) (scale <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dgesc2-docs' class="fold-docs">
<span class="md-text">				Dgesc2 solves a system of linear equations
				
					A * x = scale * b
				
				with a general n×n matrix A represented by the LU factorization with complete
				pivoting
				
					A = P * L * U * Q
				
				as computed by Dgetc2.
				
				On entry, rhs contains the right hand side vector b. On return, it is
				overwritten with the solution vector x.
				
				Dgesc2 returns a scale factor
				
					0 &lt;= scale &lt;= 1
				
				chosen to prevent overflow in the solution.
				
				Dgesc2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgesv"><label for="Implementation-fold-method-Dgesv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgesv.go.html#line-28">Dgesv</a>(n, nrhs <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, ipiv []<a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dgesv-docs' class="fold-docs">
<span class="md-text">				Dgesv computes the solution to a real system of linear equations
				
					A * X = B
				
				where A is an n×n matrix and X and B are n×nrhs matrices.
				
				The LU decomposition with partial pivoting and row interchanges is used to
				factor A as
				
					A = P * L * U
				
				where P is a permutation matrix, L is unit lower triangular, and U is upper
				triangular. On return, the factors L and U are stored in a; the unit diagonal
				elements of L are not stored. The row pivot indices that define the
				permutation matrix P are stored in ipiv.
				
				The factored form of A is then used to solve the system of equations A * X =
				B. On entry, b contains the right hand side matrix B. On return, if ok is
				true, b contains the solution matrix X.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgesvd"><label for="Implementation-fold-method-Dgesvd">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgesvd.go.html#line-63">Dgesvd</a>(jobU, jobVT <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-SVDJob">SVDJob</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, s, u []<a href="../../../../builtin.html#name-float64">float64</a>, ldu <a href="../../../../builtin.html#name-int">int</a>, vt []<a href="../../../../builtin.html#name-float64">float64</a>, ldvt <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dgesvd-docs' class="fold-docs">
<span class="md-text">				Dgesvd computes the singular value decomposition of the input matrix A.
				
				The singular value decomposition is
				
					A = U * Sigma * Vᵀ
				
				where Sigma is an m×n diagonal matrix containing the singular values of A,
				U is an m×m orthogonal matrix and V is an n×n orthogonal matrix. The first
				min(m,n) columns of U and V are the left and right singular vectors of A
				respectively.
				
				jobU and jobVT are options for computing the singular vectors. The behavior
				is as follows
				
					jobU == lapack.SVDAll       All m columns of U are returned in u
					jobU == lapack.SVDStore     The first min(m,n) columns are returned in u
					jobU == lapack.SVDOverwrite The first min(m,n) columns of U are written into a
					jobU == lapack.SVDNone      The columns of U are not computed.
				
				The behavior is the same for jobVT and the rows of Vᵀ. At most one of jobU
				and jobVT can equal lapack.SVDOverwrite, and Dgesvd will panic otherwise.
				
				On entry, a contains the data for the m×n matrix A. During the call to Dgesvd
				the data is overwritten. On exit, A contains the appropriate singular vectors
				if either job is lapack.SVDOverwrite.
				
				s is a slice of length at least min(m,n) and on exit contains the singular
				values in decreasing order.
				
				u contains the left singular vectors on exit, stored column-wise. If
				jobU == lapack.SVDAll, u is of size m×m. If jobU == lapack.SVDStore u is
				of size m×min(m,n). If jobU == lapack.SVDOverwrite or lapack.SVDNone, u is
				not used.
				
				vt contains the left singular vectors on exit, stored row-wise. If
				jobV == lapack.SVDAll, vt is of size n×n. If jobVT == lapack.SVDStore vt is
				of size min(m,n)×n. If jobVT == lapack.SVDOverwrite or lapack.SVDNone, vt is
				not used.
				
				work is a slice for storing temporary memory, and lwork is the usable size of
				the slice. lwork must be at least max(5*min(m,n), 3*min(m,n)+max(m,n)).
				If lwork == -1, instead of performing Dgesvd, the optimal work length will be
				stored into work[0]. Dgesvd will panic if the working memory has insufficient
				storage.
				
				Dgesvd returns whether the decomposition successfully completed.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgetc2"><label for="Implementation-fold-method-Dgetc2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgetc2.go.html#line-32">Dgetc2</a>(n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, ipiv, jpiv []<a href="../../../../builtin.html#name-int">int</a>) (k <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgetc2-docs' class="fold-docs">
<span class="md-text">				Dgetc2 computes an LU factorization with complete pivoting of the n×n matrix
				A. The factorization has the form
				
					A = P * L * U * Q,
				
				where P and Q are permutation matrices, L is lower triangular with unit
				diagonal elements and U is upper triangular.
				
				On entry, a contains the matrix A to be factored. On return, a is overwritten
				with the factors L and U. The unit diagonal elements of L are not stored.
				
				On return, ipiv and jpiv contain the pivot indices: row i has been
				interchanged with row ipiv[i] and column j has been interchanged with column
				jpiv[j]. ipiv and jpiv must have length n, otherwise Dgetc2 will panic.
				
				If k is non-negative, then U[k,k] is likely to produce overflow when solving
				for x in A*x=b and U has been perturbed to avoid the overflow.
				
				Dgetc2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgetf2"><label for="Implementation-fold-method-Dgetf2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgetf2.go.html#line-32">Dgetf2</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, ipiv []<a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dgetf2-docs' class="fold-docs">
<span class="md-text">				Dgetf2 computes the LU decomposition of the m×n matrix A.
				The LU decomposition is a factorization of a into
				
					A = P * L * U
				
				where P is a permutation matrix, L is a unit lower triangular matrix, and
				U is a (usually) non-unit upper triangular matrix. On exit, L and U are stored
				in place into a.
				
				ipiv is a permutation vector. It indicates that row i of the matrix was
				changed with ipiv[i]. ipiv must have length at least min(m,n), and will panic
				otherwise. ipiv is zero-indexed.
				
				Dgetf2 returns whether the matrix A is singular. The LU decomposition will
				be computed regardless of the singularity of A, but division by zero
				will occur if the false is returned and the result is used to solve a
				system of equations.
				
				Dgetf2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgetrf"><label for="Implementation-fold-method-Dgetrf">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgetrf.go.html#line-31">Dgetrf</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, ipiv []<a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dgetrf-docs' class="fold-docs">
<span class="md-text">				Dgetrf computes the LU decomposition of the m×n matrix A.
				The LU decomposition is a factorization of A into
				
					A = P * L * U
				
				where P is a permutation matrix, L is a unit lower triangular matrix, and
				U is a (usually) non-unit upper triangular matrix. On exit, L and U are stored
				in place into a.
				
				ipiv is a permutation vector. It indicates that row i of the matrix was
				changed with ipiv[i]. ipiv must have length at least min(m,n), and will panic
				otherwise. ipiv is zero-indexed.
				
				Dgetrf is the blocked version of the algorithm.
				
				Dgetrf returns whether the matrix A is singular. The LU decomposition will
				be computed regardless of the singularity of A, but division by zero
				will occur if the false is returned and the result is used to solve a
				system of equations.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgetri"><label for="Implementation-fold-method-Dgetri">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgetri.go.html#line-24">Dgetri</a>(n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, ipiv []<a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dgetri-docs' class="fold-docs">
<span class="md-text">				Dgetri computes the inverse of the matrix A using the LU factorization computed
				by Dgetrf. On entry, a contains the PLU decomposition of A as computed by
				Dgetrf and on exit contains the reciprocal of the original matrix.
				
				Dgetri will not perform the inversion if the matrix is singular, and returns
				a boolean indicating whether the inversion was successful.
				
				work is temporary storage, and lwork specifies the usable memory length.
				At minimum, lwork &gt;= n and this function will panic otherwise.
				Dgetri is a blocked inversion, but the block size is limited
				by the temporary space available. If lwork == -1, instead of performing Dgetri,
				the optimal work length will be stored into work[0].</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgetrs"><label for="Implementation-fold-method-Dgetrs">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgetrs.go.html#line-25">Dgetrs</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, n, nrhs <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, ipiv []<a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dgetrs-docs' class="fold-docs">
<span class="md-text">				Dgetrs solves a system of equations using an LU factorization.
				The system of equations solved is
				
					A * X = B  if trans == blas.Trans
					Aᵀ * X = B if trans == blas.NoTrans
				
				A is a general n×n matrix with stride lda. B is a general matrix of size n×nrhs.
				
				On entry b contains the elements of the matrix B. On exit, b contains the
				elements of X, the solution to the system of equations.
				
				a and ipiv contain the LU factorization of A and the permutation indices as
				computed by Dgetrf. ipiv is zero-indexed.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dggsvd3"><label for="Implementation-fold-method-Dggsvd3">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dggsvd3.go.html#line-126">Dggsvd3</a>(jobU, jobV, jobQ <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-GSVDJob">GSVDJob</a>, m, n, p <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, alpha, beta, u []<a href="../../../../builtin.html#name-float64">float64</a>, ldu <a href="../../../../builtin.html#name-int">int</a>, v []<a href="../../../../builtin.html#name-float64">float64</a>, ldv <a href="../../../../builtin.html#name-int">int</a>, q []<a href="../../../../builtin.html#name-float64">float64</a>, ldq <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>, iwork []<a href="../../../../builtin.html#name-int">int</a>) (k, l <a href="../../../../builtin.html#name-int">int</a>, ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dggsvd3-docs' class="fold-docs">
<span class="md-text">				Dggsvd3 computes the generalized singular value decomposition (GSVD)
				of an m×n matrix A and p×n matrix B:
				
					Uᵀ*A*Q = D1*[ 0 R ]
				
					Vᵀ*B*Q = D2*[ 0 R ]
				
				where U, V and Q are orthogonal matrices.
				
				Dggsvd3 returns k and l, the dimensions of the sub-blocks. k+l
				is the effective numerical rank of the (m+p)×n matrix [ Aᵀ Bᵀ ]ᵀ.
				R is a (k+l)×(k+l) nonsingular upper triangular matrix, D1 and
				D2 are m×(k+l) and p×(k+l) diagonal matrices and of the following
				structures, respectively:
				
				If m-k-l &gt;= 0,
				
					                  k  l
					     D1 =     k [ I  0 ]
					              l [ 0  C ]
					          m-k-l [ 0  0 ]
				
					                k  l
					     D2 = l   [ 0  S ]
					          p-l [ 0  0 ]
				
					             n-k-l  k    l
					[ 0 R ] = k [  0   R11  R12 ] k
					          l [  0    0   R22 ] l
				
				where
				
					C = diag( alpha_k, ... , alpha_{k+l} ),
					S = diag( beta_k,  ... , beta_{k+l} ),
					C^2 + S^2 = I.
				
				R is stored in
				
					A[0:k+l, n-k-l:n]
				
				on exit.
				
				If m-k-l &lt; 0,
				
					               k m-k k+l-m
					    D1 =   k [ I  0    0  ]
					         m-k [ 0  C    0  ]
				
					                 k m-k k+l-m
					    D2 =   m-k [ 0  S    0  ]
					         k+l-m [ 0  0    I  ]
					           p-l [ 0  0    0  ]
				
					               n-k-l  k   m-k  k+l-m
					[ 0 R ] =    k [ 0    R11  R12  R13 ]
					           m-k [ 0     0   R22  R23 ]
					         k+l-m [ 0     0    0   R33 ]
				
				where
				
					C = diag( alpha_k, ... , alpha_m ),
					S = diag( beta_k,  ... , beta_m ),
					C^2 + S^2 = I.
				
					R = [ R11 R12 R13 ] is stored in A[1:m, n-k-l+1:n]
					    [  0  R22 R23 ]
				
				and R33 is stored in
				
					B[m-k:l, n+m-k-l:n] on exit.
				
				Dggsvd3 computes C, S, R, and optionally the orthogonal transformation
				matrices U, V and Q.
				
				jobU, jobV and jobQ are options for computing the orthogonal matrices. The behavior
				is as follows
				
					jobU == lapack.GSVDU        Compute orthogonal matrix U
					jobU == lapack.GSVDNone     Do not compute orthogonal matrix.
				
				The behavior is the same for jobV and jobQ with the exception that instead of
				lapack.GSVDU these accept lapack.GSVDV and lapack.GSVDQ respectively.
				The matrices U, V and Q must be m×m, p×p and n×n respectively unless the
				relevant job parameter is lapack.GSVDNone.
				
				alpha and beta must have length n or Dggsvd3 will panic. On exit, alpha and
				beta contain the generalized singular value pairs of A and B
				
					alpha[0:k] = 1,
					beta[0:k]  = 0,
				
				if m-k-l &gt;= 0,
				
					alpha[k:k+l] = diag(C),
					beta[k:k+l]  = diag(S),
				
				if m-k-l &lt; 0,
				
					alpha[k:m]= C, alpha[m:k+l]= 0
					beta[k:m] = S, beta[m:k+l] = 1.
				
				if k+l &lt; n,
				
					alpha[k+l:n] = 0 and
					beta[k+l:n]  = 0.
				
				On exit, iwork contains the permutation required to sort alpha descending.
				
				iwork must have length n, work must have length at least max(1, lwork), and
				lwork must be -1 or greater than n, otherwise Dggsvd3 will panic. If
				lwork is -1, work[0] holds the optimal lwork on return, but Dggsvd3 does
				not perform the GSVD.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dggsvp3"><label for="Implementation-fold-method-Dggsvp3">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dggsvp3.go.html#line-60">Dggsvp3</a>(jobU, jobV, jobQ <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-GSVDJob">GSVDJob</a>, m, p, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, tola, tolb <a href="../../../../builtin.html#name-float64">float64</a>, u []<a href="../../../../builtin.html#name-float64">float64</a>, ldu <a href="../../../../builtin.html#name-int">int</a>, v []<a href="../../../../builtin.html#name-float64">float64</a>, ldv <a href="../../../../builtin.html#name-int">int</a>, q []<a href="../../../../builtin.html#name-float64">float64</a>, ldq <a href="../../../../builtin.html#name-int">int</a>, iwork []<a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) (k, l <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dggsvp3-docs' class="fold-docs">
<span class="md-text">				Dggsvp3 computes orthogonal matrices U, V and Q such that
				
					                n-k-l  k    l
					Uᵀ*A*Q =     k [ 0    A12  A13 ] if m-k-l &gt;= 0;
					             l [ 0     0   A23 ]
					         m-k-l [ 0     0    0  ]
				
					                n-k-l  k    l
					Uᵀ*A*Q =     k [ 0    A12  A13 ] if m-k-l &lt; 0;
					           m-k [ 0     0   A23 ]
				
					                n-k-l  k    l
					Vᵀ*B*Q =     l [ 0     0   B13 ]
					           p-l [ 0     0    0  ]
				
				where the k×k matrix A12 and l×l matrix B13 are non-singular
				upper triangular. A23 is l×l upper triangular if m-k-l &gt;= 0,
				otherwise A23 is (m-k)×l upper trapezoidal.
				
				Dggsvp3 returns k and l, the dimensions of the sub-blocks. k+l
				is the effective numerical rank of the (m+p)×n matrix [ Aᵀ Bᵀ ]ᵀ.
				
				jobU, jobV and jobQ are options for computing the orthogonal matrices. The behavior
				is as follows
				
					jobU == lapack.GSVDU        Compute orthogonal matrix U
					jobU == lapack.GSVDNone     Do not compute orthogonal matrix.
				
				The behavior is the same for jobV and jobQ with the exception that instead of
				lapack.GSVDU these accept lapack.GSVDV and lapack.GSVDQ respectively.
				The matrices U, V and Q must be m×m, p×p and n×n respectively unless the
				relevant job parameter is lapack.GSVDNone.
				
				tola and tolb are the convergence criteria for the Jacobi-Kogbetliantz
				iteration procedure. Generally, they are the same as used in the preprocessing
				step, for example,
				
					tola = max(m, n)*norm(A)*eps,
					tolb = max(p, n)*norm(B)*eps.
				
				Where eps is the machine epsilon.
				
				iwork must have length n, work must have length at least max(1, lwork), and
				lwork must be -1 or greater than zero, otherwise Dggsvp3 will panic.
				
				Dggsvp3 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dgtsv"><label for="Implementation-fold-method-Dgtsv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgtsv.go.html#line-26">Dgtsv</a>(n, nrhs <a href="../../../../builtin.html#name-int">int</a>, dl, d, du []<a href="../../../../builtin.html#name-float64">float64</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dgtsv-docs' class="fold-docs">
<span class="md-text">				Dgtsv solves the equation
				
					A * X = B
				
				where A is an n×n tridiagonal matrix. It uses Gaussian elimination with
				partial pivoting. The equation Aᵀ * X = B may be solved by swapping the
				arguments for du and dl.
				
				On entry, dl, d and du contain the sub-diagonal, the diagonal and the
				super-diagonal, respectively, of A. On return, the first n-2 elements of dl,
				the first n-1 elements of du and the first n elements of d may be
				overwritten.
				
				On entry, b contains the n×nrhs right-hand side matrix B. On return, b will
				be overwritten. If ok is true, it will be overwritten by the solution matrix X.
				
				Dgtsv returns whether the solution X has been successfully computed.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dhseqr"><label for="Implementation-fold-method-Dhseqr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dhseqr.go.html#line-141">Dhseqr</a>(job <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-SchurJob">SchurJob</a>, compz <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-SchurComp">SchurComp</a>, n, ilo, ihi <a href="../../../../builtin.html#name-int">int</a>, h []<a href="../../../../builtin.html#name-float64">float64</a>, ldh <a href="../../../../builtin.html#name-int">int</a>, wr, wi []<a href="../../../../builtin.html#name-float64">float64</a>, z []<a href="../../../../builtin.html#name-float64">float64</a>, ldz <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) (unconverged <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dhseqr-docs' class="fold-docs">
<span class="md-text">				Dhseqr computes the eigenvalues of an n×n Hessenberg matrix H and,
				optionally, the matrices T and Z from the Schur decomposition
				
					H = Z T Zᵀ,
				
				where T is an n×n upper quasi-triangular matrix (the Schur form), and Z is
				the n×n orthogonal matrix of Schur vectors.
				
				Optionally Z may be postmultiplied into an input orthogonal matrix Q so that
				this routine can give the Schur factorization of a matrix A which has been
				reduced to the Hessenberg form H by the orthogonal matrix Q:
				
					A = Q H Qᵀ = (QZ) T (QZ)ᵀ.
				
				If job == lapack.EigenvaluesOnly, only the eigenvalues will be computed.
				If job == lapack.EigenvaluesAndSchur, the eigenvalues and the Schur form T will
				be computed.
				For other values of job Dhseqr will panic.
				
				If compz == lapack.SchurNone, no Schur vectors will be computed and Z will not be
				referenced.
				If compz == lapack.SchurHess, on return Z will contain the matrix of Schur
				vectors of H.
				If compz == lapack.SchurOrig, on entry z is assumed to contain the orthogonal
				matrix Q that is the identity except for the submatrix
				Q[ilo:ihi+1,ilo:ihi+1]. On return z will be updated to the product Q*Z.
				
				ilo and ihi determine the block of H on which Dhseqr operates. It is assumed
				that H is already upper triangular in rows and columns [0:ilo] and [ihi+1:n],
				although it will be only checked that the block is isolated, that is,
				
					ilo == 0   or H[ilo,ilo-1] == 0,
					ihi == n-1 or H[ihi+1,ihi] == 0,
				
				and Dhseqr will panic otherwise. ilo and ihi are typically set by a previous
				call to Dgebal, otherwise they should be set to 0 and n-1, respectively. It
				must hold that
				
					0 &lt;= ilo &lt;= ihi &lt; n     if n &gt; 0,
					ilo == 0 and ihi == -1  if n == 0.
				
				wr and wi must have length n.
				
				work must have length at least lwork and lwork must be at least max(1,n)
				otherwise Dhseqr will panic. The minimum lwork delivers very good and
				sometimes optimal performance, although lwork as large as 11*n may be
				required. On return, work[0] will contain the optimal value of lwork.
				
				If lwork is -1, instead of performing Dhseqr, the function only estimates the
				optimal workspace size and stores it into work[0]. Neither h nor z are
				accessed.
				
				unconverged indicates whether Dhseqr computed all the eigenvalues.
				
				If unconverged == 0, all the eigenvalues have been computed and their real
				and imaginary parts will be stored on return in wr and wi, respectively. If
				two eigenvalues are computed as a complex conjugate pair, they are stored in
				consecutive elements of wr and wi, say the i-th and (i+1)th, with wi[i] &gt; 0
				and wi[i+1] &lt; 0.
				
				If unconverged == 0 and job == lapack.EigenvaluesAndSchur, on return H will
				contain the upper quasi-triangular matrix T from the Schur decomposition (the
				Schur form). 2×2 diagonal blocks (corresponding to complex conjugate pairs of
				eigenvalues) will be returned in standard form, with
				
					H[i,i] == H[i+1,i+1],
				
				and
				
					H[i+1,i]*H[i,i+1] &lt; 0.
				
				The eigenvalues will be stored in wr and wi in the same order as on the
				diagonal of the Schur form returned in H, with
				
					wr[i] = H[i,i],
				
				and, if H[i:i+2,i:i+2] is a 2×2 diagonal block,
				
					wi[i]   = sqrt(-H[i+1,i]*H[i,i+1]),
					wi[i+1] = -wi[i].
				
				If unconverged == 0 and job == lapack.EigenvaluesOnly, the contents of h
				on return is unspecified.
				
				If unconverged &gt; 0, some eigenvalues have not converged, and the blocks
				[0:ilo] and [unconverged:n] of wr and wi will contain those eigenvalues which
				have been successfully computed. Failures are rare.
				
				If unconverged &gt; 0 and job == lapack.EigenvaluesOnly, on return the
				remaining unconverged eigenvalues are the eigenvalues of the upper Hessenberg
				matrix H[ilo:unconverged,ilo:unconverged].
				
				If unconverged &gt; 0 and job == lapack.EigenvaluesAndSchur, then on
				return
				
					(initial H) U = U (final H),   (*)
				
				where U is an orthogonal matrix. The final H is upper Hessenberg and
				H[unconverged:ihi+1,unconverged:ihi+1] is upper quasi-triangular.
				
				If unconverged &gt; 0 and compz == lapack.SchurOrig, then on return
				
					(final Z) = (initial Z) U,
				
				where U is the orthogonal matrix in (*) regardless of the value of job.
				
				If unconverged &gt; 0 and compz == lapack.SchurHess, then on return
				
					(final Z) = U,
				
				where U is the orthogonal matrix in (*) regardless of the value of job.
				
				References:
				
					[1] R. Byers. LAPACK 3.1 xHSEQR: Tuning and Implementation Notes on the
					    Small Bulge Multi-Shift QR Algorithm with Aggressive Early Deflation.
					    LAPACK Working Note 187 (2007)
					    URL: http://www.netlib.org/lapack/lawnspdf/lawn187.pdf
					[2] K. Braman, R. Byers, R. Mathias. The Multishift QR Algorithm. Part I:
					    Maintaining Well-Focused Shifts and Level 3 Performance. SIAM J. Matrix
					    Anal. Appl. 23(4) (2002), pp. 929—947
					    URL: http://dx.doi.org/10.1137/S0895479801384573
					[3] K. Braman, R. Byers, R. Mathias. The Multishift QR Algorithm. Part II:
					    Aggressive Early Deflation. SIAM J. Matrix Anal. Appl. 23(4) (2002), pp. 948—973
					    URL: http://dx.doi.org/10.1137/S0895479801384585
				
				Dhseqr is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlabrd"><label for="Implementation-fold-method-Dlabrd">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlabrd.go.html#line-65">Dlabrd</a>(m, n, nb <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, d, e, tauQ, tauP, x []<a href="../../../../builtin.html#name-float64">float64</a>, ldx <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, ldy <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlabrd-docs' class="fold-docs">
<span class="md-text">				Dlabrd reduces the first NB rows and columns of a real general m×n matrix
				A to upper or lower bidiagonal form by an orthogonal transformation
				
					Q**T * A * P
				
				If m &gt;= n, A is reduced to upper bidiagonal form and upon exit the elements
				on and below the diagonal in the first nb columns represent the elementary
				reflectors, and the elements above the diagonal in the first nb rows represent
				the matrix P. If m &lt; n, A is reduced to lower bidiagonal form and the elements
				P is instead stored above the diagonal.
				
				The reduction to bidiagonal form is stored in d and e, where d are the diagonal
				elements, and e are the off-diagonal elements.
				
				The matrices Q and P are products of elementary reflectors
				
					Q = H_0 * H_1 * ... * H_{nb-1}
					P = G_0 * G_1 * ... * G_{nb-1}
				
				where
				
					H_i = I - tauQ[i] * v_i * v_iᵀ
					G_i = I - tauP[i] * u_i * u_iᵀ
				
				As an example, on exit the entries of A when m = 6, n = 5, and nb = 2
				
					[ 1   1  u1  u1  u1]
					[v1   1   1  u2  u2]
					[v1  v2   a   a   a]
					[v1  v2   a   a   a]
					[v1  v2   a   a   a]
					[v1  v2   a   a   a]
				
				and when m = 5, n = 6, and nb = 2
				
					[ 1  u1  u1  u1  u1  u1]
					[ 1   1  u2  u2  u2  u2]
					[v1   1   a   a   a   a]
					[v1  v2   a   a   a   a]
					[v1  v2   a   a   a   a]
				
				Dlabrd also returns the matrices X and Y which are used with U and V to
				apply the transformation to the unreduced part of the matrix
				
					A := A - V*Yᵀ - X*Uᵀ
				
				and returns the matrices X and Y which are needed to apply the
				transformation to the unreduced part of A.
				
				X is an m×nb matrix, Y is an n×nb matrix. d, e, taup, and tauq must all have
				length at least nb. Dlabrd will panic if these size constraints are violated.
				
				Dlabrd is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlacn2"><label for="Implementation-fold-method-Dlacn2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlacn2.go.html#line-32">Dlacn2</a>(n <a href="../../../../builtin.html#name-int">int</a>, v, x []<a href="../../../../builtin.html#name-float64">float64</a>, isgn []<a href="../../../../builtin.html#name-int">int</a>, est <a href="../../../../builtin.html#name-float64">float64</a>, kase <a href="../../../../builtin.html#name-int">int</a>, isave *[3]<a href="../../../../builtin.html#name-int">int</a>) (<a href="../../../../builtin.html#name-float64">float64</a>, <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlacn2-docs' class="fold-docs">
<span class="md-text">				Dlacn2 estimates the 1-norm of an n×n matrix A using sequential updates with
				matrix-vector products provided externally.
				
				Dlacn2 is called sequentially and it returns the value of est and kase to be
				used on the next call.
				On the initial call, kase must be 0.
				In between calls, x must be overwritten by
				
					A * X    if kase was returned as 1,
					Aᵀ * X   if kase was returned as 2,
				
				and all other parameters must not be changed.
				On the final return, kase is returned as 0, v contains A*W where W is a
				vector, and est = norm(V)/norm(W) is a lower bound for 1-norm of A.
				
				v, x, and isgn must all have length n and n must be at least 1, otherwise
				Dlacn2 will panic. isave is used for temporary storage.
				
				Dlacn2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlacpy"><label for="Implementation-fold-method-Dlacpy">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlacpy.go.html#line-14">Dlacpy</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlacpy-docs' class="fold-docs">
<span class="md-text">				Dlacpy copies the elements of A specified by uplo into B. Uplo can specify
				a triangular portion with blas.Upper or blas.Lower, or can specify all of the
				elements with blas.All.
				
				Dlacpy is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlae2"><label for="Implementation-fold-method-Dlae2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlae2.go.html#line-18">Dlae2</a>(a, b, c <a href="../../../../builtin.html#name-float64">float64</a>) (rt1, rt2 <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlae2-docs' class="fold-docs">
<span class="md-text">				Dlae2 computes the eigenvalues of a 2×2 symmetric matrix
				
					[a b]
					[b c]
				
				and returns the eigenvalue with the larger absolute value as rt1 and the
				smaller as rt2.
				
				Dlae2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlaev2"><label for="Implementation-fold-method-Dlaev2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaev2.go.html#line-22">Dlaev2</a>(a, b, c <a href="../../../../builtin.html#name-float64">float64</a>) (rt1, rt2, cs1, sn1 <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlaev2-docs' class="fold-docs">
<span class="md-text">				Dlaev2 computes the Eigen decomposition of a symmetric 2×2 matrix.
				The matrix is given by
				
					[a b]
					[b c]
				
				Dlaev2 returns rt1 and rt2, the eigenvalues of the matrix where |RT1| &gt; |RT2|,
				and [cs1, sn1] which is the unit right eigenvalue for RT1.
				
					[ cs1 sn1] [a b] [cs1 -sn1] = [rt1   0]
					[-sn1 cs1] [b c] [sn1  cs1]   [  0 rt2]
				
				Dlaev2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlaexc"><label for="Implementation-fold-method-Dlaexc">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaexc.go.html#line-37">Dlaexc</a>(wantq <a href="../../../../builtin.html#name-bool">bool</a>, n <a href="../../../../builtin.html#name-int">int</a>, t []<a href="../../../../builtin.html#name-float64">float64</a>, ldt <a href="../../../../builtin.html#name-int">int</a>, q []<a href="../../../../builtin.html#name-float64">float64</a>, ldq <a href="../../../../builtin.html#name-int">int</a>, j1, n1, n2 <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dlaexc-docs' class="fold-docs">
<span class="md-text">				Dlaexc swaps two adjacent diagonal blocks of order 1 or 2 in an n×n upper
				quasi-triangular matrix T by an orthogonal similarity transformation.
				
				T must be in Schur canonical form, that is, block upper triangular with 1×1
				and 2×2 diagonal blocks; each 2×2 diagonal block has its diagonal elements
				equal and its off-diagonal elements of opposite sign. On return, T will
				contain the updated matrix again in Schur canonical form.
				
				If wantq is true, the transformation is accumulated in the n×n matrix Q,
				otherwise Q is not referenced.
				
				j1 is the index of the first row of the first block. n1 and n2 are the order
				of the first and second block, respectively.
				
				work must have length at least n, otherwise Dlaexc will panic.
				
				If ok is false, the transformed matrix T would be too far from Schur form.
				The blocks are not swapped, and T and Q are not modified.
				
				If n1 and n2 are both equal to 1, Dlaexc will always return true.
				
				Dlaexc is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlag2"><label for="Implementation-fold-method-Dlag2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlag2.go.html#line-45">Dlag2</a>(a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>) (scale1, scale2, wr1, wr2, wi <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlag2-docs' class="fold-docs">
<span class="md-text">				Dlag2 computes the eigenvalues of a 2×2 generalized eigenvalue problem
				
					A - w*B
				
				where B is an upper triangular matrix.
				
				Dlag2 uses scaling as necessary to avoid over-/underflow. Scaling results in
				a modified eigenvalue problem
				
					s*A - w*B
				
				where s is a non-negative scaling factor chosen so that w, w*B, and s*A do
				not overflow and, if possible, do not underflow, either.
				
				scale1 and scale2 are used to avoid over-/underflow in the eigenvalue
				equation which defines the first and second eigenvalue respectively. Note
				that scale1 and scale2 may be zero or less than the underflow threshold if
				the corresponding exact eigenvalue is sufficiently large.
				
				If the eigenvalues are real, then:
				  - wi is zero,
				  - the eigenvalues are wr1/scale1 and wr2/scale2.
				
				If the eigenvalues are complex, then:
				  - wi is non-negative,
				  - the eigenvalues are (wr1 ± wi*i)/scale1,
				  - wr1 = wr2,
				  - scale1 = scale2.
				
				Dlag2 assumes that the one-norm of A and B is less than 1/dlamchS. Entries of
				A less than sqrt(dlamchS)*norm(A) are subject to being treated as zero. The
				diagonals of B should be at least sqrt(dlamchS) times the largest element of
				B (in absolute value); if a diagonal is smaller than that, then
				±sqrt(dlamchS) will be used instead of that diagonal.
				
				Dlag2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlags2"><label for="Implementation-fold-method-Dlags2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlags2.go.html#line-38">Dlags2</a>(upper <a href="../../../../builtin.html#name-bool">bool</a>, a1, a2, a3, b1, b2, b3 <a href="../../../../builtin.html#name-float64">float64</a>) (csu, snu, csv, snv, csq, snq <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlags2-docs' class="fold-docs">
<span class="md-text">				Dlags2 computes 2-by-2 orthogonal matrices U, V and Q with the
				triangles of A and B specified by upper.
				
				If upper is true
				
					Uᵀ*A*Q = Uᵀ*[ a1 a2 ]*Q = [ x  0 ]
					            [ 0  a3 ]     [ x  x ]
				
				and
				
					Vᵀ*B*Q = Vᵀ*[ b1 b2 ]*Q = [ x  0 ]
					            [ 0  b3 ]     [ x  x ]
				
				otherwise
				
					Uᵀ*A*Q = Uᵀ*[ a1 0  ]*Q = [ x  x ]
					            [ a2 a3 ]     [ 0  x ]
				
				and
				
					Vᵀ*B*Q = Vᵀ*[ b1 0  ]*Q = [ x  x ]
					            [ b2 b3 ]     [ 0  x ].
				
				The rows of the transformed A and B are parallel, where
				
					U = [  csu  snu ], V = [  csv snv ], Q = [  csq   snq ]
					    [ -snu  csu ]      [ -snv csv ]      [ -snq   csq ]
				
				Dlags2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlagtm"><label for="Implementation-fold-method-Dlagtm">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlagtm.go.html#line-16">Dlagtm</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, dl, d, du []<a href="../../../../builtin.html#name-float64">float64</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlagtm-docs' class="fold-docs">
<span class="md-text">				Dlagtm performs one of the matrix-matrix operations
				
					C = alpha * A * B + beta * C   if trans == blas.NoTrans
					C = alpha * Aᵀ * B + beta * C  if trans == blas.Trans or blas.ConjTrans
				
				where A is an m×m tridiagonal matrix represented by its diagonals dl, d, du,
				B and C are m×n dense matrices, and alpha and beta are scalars.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlahqr"><label for="Implementation-fold-method-Dlahqr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlahqr.go.html#line-84">Dlahqr</a>(wantt, wantz <a href="../../../../builtin.html#name-bool">bool</a>, n, ilo, ihi <a href="../../../../builtin.html#name-int">int</a>, h []<a href="../../../../builtin.html#name-float64">float64</a>, ldh <a href="../../../../builtin.html#name-int">int</a>, wr, wi []<a href="../../../../builtin.html#name-float64">float64</a>, iloz, ihiz <a href="../../../../builtin.html#name-int">int</a>, z []<a href="../../../../builtin.html#name-float64">float64</a>, ldz <a href="../../../../builtin.html#name-int">int</a>) (unconverged <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlahqr-docs' class="fold-docs">
<span class="md-text">				Dlahqr computes the eigenvalues and Schur factorization of a block of an n×n
				upper Hessenberg matrix H, using the double-shift/single-shift QR algorithm.
				
				h and ldh represent the matrix H. Dlahqr works primarily with the Hessenberg
				submatrix H[ilo:ihi+1,ilo:ihi+1], but applies transformations to all of H if
				wantt is true. It is assumed that H[ihi+1:n,ihi+1:n] is already upper
				quasi-triangular, although this is not checked.
				
				It must hold that
				
					0 &lt;= ilo &lt;= max(0,ihi), and ihi &lt; n,
				
				and that
				
					H[ilo,ilo-1] == 0,  if ilo &gt; 0,
				
				otherwise Dlahqr will panic.
				
				If unconverged is zero on return, wr[ilo:ihi+1] and wi[ilo:ihi+1] will contain
				respectively the real and imaginary parts of the computed eigenvalues ilo
				to ihi. If two eigenvalues are computed as a complex conjugate pair, they are
				stored in consecutive elements of wr and wi, say the i-th and (i+1)th, with
				wi[i] &gt; 0 and wi[i+1] &lt; 0. If wantt is true, the eigenvalues are stored in
				the same order as on the diagonal of the Schur form returned in H, with
				wr[i] = H[i,i], and, if H[i:i+2,i:i+2] is a 2×2 diagonal block,
				wi[i] = sqrt(abs(H[i+1,i]*H[i,i+1])) and wi[i+1] = -wi[i].
				
				wr and wi must have length ihi+1.
				
				z and ldz represent an n×n matrix Z. If wantz is true, the transformations
				will be applied to the submatrix Z[iloz:ihiz+1,ilo:ihi+1] and it must hold that
				
					0 &lt;= iloz &lt;= ilo, and ihi &lt;= ihiz &lt; n.
				
				If wantz is false, z is not referenced.
				
				unconverged indicates whether Dlahqr computed all the eigenvalues ilo to ihi
				in a total of 30 iterations per eigenvalue.
				
				If unconverged is zero, all the eigenvalues ilo to ihi have been computed and
				will be stored on return in wr[ilo:ihi+1] and wi[ilo:ihi+1].
				
				If unconverged is zero and wantt is true, H[ilo:ihi+1,ilo:ihi+1] will be
				overwritten on return by upper quasi-triangular full Schur form with any
				2×2 diagonal blocks in standard form.
				
				If unconverged is zero and if wantt is false, the contents of h on return is
				unspecified.
				
				If unconverged is positive, some eigenvalues have not converged, and
				wr[unconverged:ihi+1] and wi[unconverged:ihi+1] contain those eigenvalues
				which have been successfully computed.
				
				If unconverged is positive and wantt is true, then on return
				
					(initial H)*U = U*(final H),   (*)
				
				where U is an orthogonal matrix. The final H is upper Hessenberg and
				H[unconverged:ihi+1,unconverged:ihi+1] is upper quasi-triangular.
				
				If unconverged is positive and wantt is false, on return the remaining
				unconverged eigenvalues are the eigenvalues of the upper Hessenberg matrix
				H[ilo:unconverged,ilo:unconverged].
				
				If unconverged is positive and wantz is true, then on return
				
					(final Z) = (initial Z)*U,
				
				where U is the orthogonal matrix in (*) regardless of the value of wantt.
				
				Dlahqr is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlahr2"><label for="Implementation-fold-method-Dlahr2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlahr2.go.html#line-74">Dlahr2</a>(n, k, nb <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, t []<a href="../../../../builtin.html#name-float64">float64</a>, ldt <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, ldy <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlahr2-docs' class="fold-docs">
<span class="md-text">				Dlahr2 reduces the first nb columns of a real general n×(n-k+1) matrix A so
				that elements below the k-th subdiagonal are zero. The reduction is performed
				by an orthogonal similarity transformation Qᵀ * A * Q. Dlahr2 returns the
				matrices V and T which determine Q as a block reflector I - V*T*Vᵀ, and
				also the matrix Y = A * V * T.
				
				The matrix Q is represented as a product of nb elementary reflectors
				
					Q = H_0 * H_1 * ... * H_{nb-1}.
				
				Each H_i has the form
				
					H_i = I - tau[i] * v * vᵀ,
				
				where v is a real vector with v[0:i+k-1] = 0 and v[i+k-1] = 1. v[i+k:n] is
				stored on exit in A[i+k+1:n,i].
				
				The elements of the vectors v together form the (n-k+1)×nb matrix
				V which is needed, with T and Y, to apply the transformation to the
				unreduced part of the matrix, using an update of the form
				
					A = (I - V*T*Vᵀ) * (A - Y*Vᵀ).
				
				On entry, a contains the n×(n-k+1) general matrix A. On return, the elements
				on and above the k-th subdiagonal in the first nb columns are overwritten
				with the corresponding elements of the reduced matrix; the elements below the
				k-th subdiagonal, with the slice tau, represent the matrix Q as a product of
				elementary reflectors. The other columns of A are unchanged.
				
				The contents of A on exit are illustrated by the following example
				with n = 7, k = 3 and nb = 2:
				
					[ a   a   a   a   a ]
					[ a   a   a   a   a ]
					[ a   a   a   a   a ]
					[ h   h   a   a   a ]
					[ v0  h   a   a   a ]
					[ v0  v1  a   a   a ]
					[ v0  v1  a   a   a ]
				
				where a denotes an element of the original matrix A, h denotes a
				modified element of the upper Hessenberg matrix H, and vi denotes an
				element of the vector defining H_i.
				
				k is the offset for the reduction. Elements below the k-th subdiagonal in the
				first nb columns are reduced to zero.
				
				nb is the number of columns to be reduced.
				
				On entry, a represents the n×(n-k+1) matrix A. On return, the elements on and
				above the k-th subdiagonal in the first nb columns are overwritten with the
				corresponding elements of the reduced matrix. The elements below the k-th
				subdiagonal, with the slice tau, represent the matrix Q as a product of
				elementary reflectors. The other columns of A are unchanged.
				
				tau will contain the scalar factors of the elementary reflectors. It must
				have length at least nb.
				
				t and ldt represent the nb×nb upper triangular matrix T, and y and ldy
				represent the n×nb matrix Y.
				
				Dlahr2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlaln2"><label for="Implementation-fold-method-Dlaln2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaln2.go.html#line-55">Dlaln2</a>(trans <a href="../../../../builtin.html#name-bool">bool</a>, na, nw <a href="../../../../builtin.html#name-int">int</a>, smin, ca <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, d1, d2 <a href="../../../../builtin.html#name-float64">float64</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, wr, wi <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, ldx <a href="../../../../builtin.html#name-int">int</a>) (scale, xnorm <a href="../../../../builtin.html#name-float64">float64</a>, ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dlaln2-docs' class="fold-docs">
<span class="md-text">				Dlaln2 solves a linear equation or a system of 2 linear equations of the form
				
					(ca A   - w D) X = scale B  if trans == false,
					(ca Aᵀ - w D) X = scale B   if trans == true,
				
				where A is a na×na real matrix, ca is a real scalar, D is a na×na diagonal
				real matrix, w is a scalar, real if nw == 1, complex if nw == 2, and X and B
				are na×1 matrices, real if w is real, complex if w is complex.
				
				If w is complex, X and B are represented as na×2 matrices, the first column
				of each being the real part and the second being the imaginary part.
				
				na and nw must be 1 or 2, otherwise Dlaln2 will panic.
				
				d1 and d2 are the diagonal elements of D. d2 is not used if na == 1.
				
				wr and wi represent the real and imaginary part, respectively, of the scalar
				w. wi is not used if nw == 1.
				
				smin is the desired lower bound on the singular values of A. This should be
				a safe distance away from underflow or overflow, say, between
				(underflow/machine precision) and (overflow*machine precision).
				
				If both singular values of (ca A - w D) are less than smin, smin*identity
				will be used instead of (ca A - w D). If only one singular value is less than
				smin, one element of (ca A - w D) will be perturbed enough to make the
				smallest singular value roughly smin. If both singular values are at least
				smin, (ca A - w D) will not be perturbed. In any case, the perturbation will
				be at most some small multiple of max(smin, ulp*norm(ca A - w D)). The
				singular values are computed by infinity-norm approximations, and thus will
				only be correct to a factor of 2 or so.
				
				All input quantities are assumed to be smaller than overflow by a reasonable
				factor.
				
				scale is a scaling factor less than or equal to 1 which is chosen so that X
				can be computed without overflow. X is further scaled if necessary to assure
				that norm(ca A - w D)*norm(X) is less than overflow.
				
				xnorm contains the infinity-norm of X when X is regarded as a na×nw real
				matrix.
				
				ok will be false if (ca A - w D) had to be perturbed to make its smallest
				singular value greater than smin, otherwise ok will be true.
				
				Dlaln2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlangb"><label for="Implementation-fold-method-Dlangb">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlangb.go.html#line-16">Dlangb</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, m, n, kl, ku <a href="../../../../builtin.html#name-int">int</a>, ab []<a href="../../../../builtin.html#name-float64">float64</a>, ldab <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dlangb-docs' class="fold-docs">
<span class="md-text">				Dlangb returns the given norm of an m×n band matrix with kl sub-diagonals and
				ku super-diagonals.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlange"><label for="Implementation-fold-method-Dlange">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlange.go.html#line-22">Dlange</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dlange-docs' class="fold-docs">
<span class="md-text">				Dlange returns the value of the specified norm of a general m×n matrix A:
				
					lapack.MaxAbs:       the maximum absolute value of any element.
					lapack.MaxColumnSum: the maximum column sum of the absolute values of the elements (1-norm).
					lapack.MaxRowSum:    the maximum row sum of the absolute values of the elements (infinity-norm).
					lapack.Frobenius:    the square root of the sum of the squares of the elements (Frobenius norm).
				
				If norm == lapack.MaxColumnSum, work must be of length n, and this function will
				panic otherwise. There are no restrictions on work for the other matrix norms.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlangt"><label for="Implementation-fold-method-Dlangt">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlangt.go.html#line-17">Dlangt</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, n <a href="../../../../builtin.html#name-int">int</a>, dl, d, du []<a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dlangt-docs' class="fold-docs">
<span class="md-text">				Dlangt returns the value of the given norm of an n×n tridiagonal matrix
				represented by the three diagonals.
				
				d must have length at least n and dl and du must have length at least n-1.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlansb"><label for="Implementation-fold-method-Dlansb">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlansb.go.html#line-19">Dlansb</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n, kd <a href="../../../../builtin.html#name-int">int</a>, ab []<a href="../../../../builtin.html#name-float64">float64</a>, ldab <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dlansb-docs' class="fold-docs">
<span class="md-text">				Dlansb returns the given norm of an n×n symmetric band matrix with kd
				super-diagonals.
				
				When norm is lapack.MaxColumnSum or lapack.MaxRowSum, the length of work must
				be at least n.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlanst"><label for="Implementation-fold-method-Dlanst">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlanst.go.html#line-16">Dlanst</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, n <a href="../../../../builtin.html#name-int">int</a>, d, e []<a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dlanst-docs' class="fold-docs">
<span class="md-text">				Dlanst computes the specified norm of a symmetric tridiagonal matrix A.
				The diagonal elements of A are stored in d and the off-diagonal elements
				are stored in e.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlansy"><label for="Implementation-fold-method-Dlansy">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlansy.go.html#line-17">Dlansy</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dlansy-docs' class="fold-docs">
<span class="md-text">				Dlansy returns the value of the specified norm of an n×n symmetric matrix. If
				norm == lapack.MaxColumnSum or norm == lapack.MaxRowSum, work must have length
				at least n, otherwise work is unused.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlantb"><label for="Implementation-fold-method-Dlantb">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlantb.go.html#line-18">Dlantb</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dlantb-docs' class="fold-docs">
<span class="md-text">				Dlantb returns the value of the given norm of an n×n triangular band matrix A
				with k+1 diagonals.
				
				When norm is lapack.MaxColumnSum, the length of work must be at least n.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlantr"><label for="Implementation-fold-method-Dlantr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlantr.go.html#line-17">Dlantr</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dlantr-docs' class="fold-docs">
<span class="md-text">				Dlantr computes the specified norm of an m×n trapezoidal matrix A. If
				norm == lapack.MaxColumnSum work must have length at least n, otherwise work
				is unused.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlanv2"><label for="Implementation-fold-method-Dlanv2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlanv2.go.html#line-18">Dlanv2</a>(a, b, c, d <a href="../../../../builtin.html#name-float64">float64</a>) (aa, bb, cc, dd <a href="../../../../builtin.html#name-float64">float64</a>, rt1r, rt1i, rt2r, rt2i <a href="../../../../builtin.html#name-float64">float64</a>, cs, sn <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlanv2-docs' class="fold-docs">
<span class="md-text">				Dlanv2 computes the Schur factorization of a real 2×2 matrix:
				
					[ a b ] = [ cs -sn ] * [ aa bb ] * [ cs sn ]
					[ c d ]   [ sn  cs ]   [ cc dd ] * [-sn cs ]
				
				If cc is zero, aa and dd are real eigenvalues of the matrix. Otherwise it
				holds that aa = dd and bb*cc &lt; 0, and aa ± sqrt(bb*cc) are complex conjugate
				eigenvalues. The real and imaginary parts of the eigenvalues are returned in
				(rt1r,rt1i) and (rt2r,rt2i).</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlapll"><label for="Implementation-fold-method-Dlapll">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlapll.go.html#line-16">Dlapll</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>, y []<a href="../../../../builtin.html#name-float64">float64</a>, incY <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dlapll-docs' class="fold-docs">
<span class="md-text">				Dlapll returns the smallest singular value of the n×2 matrix A = [ x y ].
				The function first computes the QR factorization of A = Q*R, and then computes
				the SVD of the 2-by-2 upper triangular matrix r.
				
				The contents of x and y are overwritten during the call.
				
				Dlapll is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlapmr"><label for="Implementation-fold-method-Dlapmr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlapmr.go.html#line-21">Dlapmr</a>(forward <a href="../../../../builtin.html#name-bool">bool</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, ldx <a href="../../../../builtin.html#name-int">int</a>, k []<a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlapmr-docs' class="fold-docs">
<span class="md-text">				Dlapmr rearranges the rows of the m×n matrix X as specified by the permutation
				k[0],k[1],...,k[m-1] of the integers 0,...,m-1.
				
				If forward is true, a forward permutation is applied:
				
					X[k[i],0:n] is moved to X[i,0:n] for i=0,1,...,m-1.
				
				If forward is false, a backward permutation is applied:
				
					X[i,0:n] is moved to X[k[i],0:n] for i=0,1,...,m-1.
				
				k must have length m, otherwise Dlapmr will panic.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlapmt"><label for="Implementation-fold-method-Dlapmt">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlapmt.go.html#line-21">Dlapmt</a>(forward <a href="../../../../builtin.html#name-bool">bool</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, ldx <a href="../../../../builtin.html#name-int">int</a>, k []<a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlapmt-docs' class="fold-docs">
<span class="md-text">				Dlapmt rearranges the columns of the m×n matrix X as specified by the
				permutation k_0, k_1, ..., k_n-1 of the integers 0, ..., n-1.
				
				If forward is true a forward permutation is performed:
				
					X[0:m, k[j]] is moved to X[0:m, j] for j = 0, 1, ..., n-1.
				
				otherwise a backward permutation is performed:
				
					X[0:m, j] is moved to X[0:m, k[j]] for j = 0, 1, ..., n-1.
				
				k must have length n, otherwise Dlapmt will panic. k is zero-indexed.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlapy2"><label for="Implementation-fold-method-Dlapy2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlapy2.go.html#line-12">Dlapy2</a>(x, y <a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dlapy2-docs' class="fold-docs">
<span class="md-text">				Dlapy2 is the LAPACK version of math.Hypot.
				
				Dlapy2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlaqp2"><label for="Implementation-fold-method-Dlaqp2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaqp2.go.html#line-36">Dlaqp2</a>(m, n, offset <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, jpvt []<a href="../../../../builtin.html#name-int">int</a>, tau, vn1, vn2, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlaqp2-docs' class="fold-docs">
<span class="md-text">				Dlaqp2 computes a QR factorization with column pivoting of the block A[offset:m, 0:n]
				of the m×n matrix A. The block A[0:offset, 0:n] is accordingly pivoted, but not factorized.
				
				On exit, the upper triangle of block A[offset:m, 0:n] is the triangular factor obtained.
				The elements in block A[offset:m, 0:n] below the diagonal, together with tau, represent
				the orthogonal matrix Q as a product of elementary reflectors.
				
				offset is number of rows of the matrix A that must be pivoted but not factorized.
				offset must not be negative otherwise Dlaqp2 will panic.
				
				On exit, jpvt holds the permutation that was applied; the jth column of A*P was the
				jpvt[j] column of A. jpvt must have length n, otherwise Dlaqp2 will panic.
				
				On exit tau holds the scalar factors of the elementary reflectors. It must have length
				at least min(m-offset, n) otherwise Dlaqp2 will panic.
				
				vn1 and vn2 hold the partial and complete column norms respectively. They must have length n,
				otherwise Dlaqp2 will panic.
				
				work must have length n, otherwise Dlaqp2 will panic.
				
				Dlaqp2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlaqps"><label for="Implementation-fold-method-Dlaqps">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaqps.go.html#line-51">Dlaqps</a>(m, n, offset, nb <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, jpvt []<a href="../../../../builtin.html#name-int">int</a>, tau, vn1, vn2, auxv, f []<a href="../../../../builtin.html#name-float64">float64</a>, ldf <a href="../../../../builtin.html#name-int">int</a>) (kb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlaqps-docs' class="fold-docs">
<span class="md-text">				Dlaqps computes a step of QR factorization with column pivoting
				of an m×n matrix A by using Blas-3. It tries to factorize nb
				columns from A starting from the row offset, and updates all
				of the matrix with Dgemm.
				
				In some cases, due to catastrophic cancellations, it cannot
				factorize nb columns. Hence, the actual number of factorized
				columns is returned in kb.
				
				Dlaqps computes a QR factorization with column pivoting of the
				block A[offset:m, 0:nb] of the m×n matrix A. The block
				A[0:offset, 0:n] is accordingly pivoted, but not factorized.
				
				On exit, the upper triangle of block A[offset:m, 0:kb] is the
				triangular factor obtained. The elements in block A[offset:m, 0:n]
				below the diagonal, together with tau, represent the orthogonal
				matrix Q as a product of elementary reflectors.
				
				offset is number of rows of the matrix A that must be pivoted but
				not factorized. offset must not be negative otherwise Dlaqps will panic.
				
				On exit, jpvt holds the permutation that was applied; the jth column
				of A*P was the jpvt[j] column of A. jpvt must have length n,
				otherwise Dlapqs will panic.
				
				On exit tau holds the scalar factors of the elementary reflectors.
				It must have length nb, otherwise Dlapqs will panic.
				
				vn1 and vn2 hold the partial and complete column norms respectively.
				They must have length n, otherwise Dlapqs will panic.
				
				auxv must have length nb, otherwise Dlaqps will panic.
				
				f and ldf represent an n×nb matrix F that is overwritten during the
				call.
				
				Dlaqps is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlaqr04"><label for="Implementation-fold-method-Dlaqr04">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaqr04.go.html#line-116">Dlaqr04</a>(wantt, wantz <a href="../../../../builtin.html#name-bool">bool</a>, n, ilo, ihi <a href="../../../../builtin.html#name-int">int</a>, h []<a href="../../../../builtin.html#name-float64">float64</a>, ldh <a href="../../../../builtin.html#name-int">int</a>, wr, wi []<a href="../../../../builtin.html#name-float64">float64</a>, iloz, ihiz <a href="../../../../builtin.html#name-int">int</a>, z []<a href="../../../../builtin.html#name-float64">float64</a>, ldz <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>, recur <a href="../../../../builtin.html#name-int">int</a>) (unconverged <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlaqr04-docs' class="fold-docs">
<span class="md-text">				Dlaqr04 computes the eigenvalues of a block of an n×n upper Hessenberg matrix
				H, and optionally the matrices T and Z from the Schur decomposition
				
					H = Z T Zᵀ
				
				where T is an upper quasi-triangular matrix (the Schur form), and Z is the
				orthogonal matrix of Schur vectors.
				
				wantt indicates whether the full Schur form T is required. If wantt is false,
				then only enough of H will be updated to preserve the eigenvalues.
				
				wantz indicates whether the n×n matrix of Schur vectors Z is required. If it
				is true, the orthogonal similarity transformation will be accumulated into
				Z[iloz:ihiz+1,ilo:ihi+1], otherwise Z will not be referenced.
				
				ilo and ihi determine the block of H on which Dlaqr04 operates. It must hold that
				
					0 &lt;= ilo &lt;= ihi &lt; n     if n &gt; 0,
					ilo == 0 and ihi == -1  if n == 0,
				
				and the block must be isolated, that is,
				
					ilo == 0   or H[ilo,ilo-1] == 0,
					ihi == n-1 or H[ihi+1,ihi] == 0,
				
				otherwise Dlaqr04 will panic.
				
				wr and wi must have length ihi+1.
				
				iloz and ihiz specify the rows of Z to which transformations will be applied
				if wantz is true. It must hold that
				
					0 &lt;= iloz &lt;= ilo,  and  ihi &lt;= ihiz &lt; n,
				
				otherwise Dlaqr04 will panic.
				
				work must have length at least lwork and lwork must be
				
					lwork &gt;= 1  if n &lt;= 11,
					lwork &gt;= n  if n &gt; 11,
				
				otherwise Dlaqr04 will panic. lwork as large as 6*n may be required for
				optimal performance. On return, work[0] will contain the optimal value of
				lwork.
				
				If lwork is -1, instead of performing Dlaqr04, the function only estimates the
				optimal workspace size and stores it into work[0]. Neither h nor z are
				accessed.
				
				recur is the non-negative recursion depth. For recur &gt; 0, Dlaqr04 behaves
				as DLAQR0, for recur == 0 it behaves as DLAQR4.
				
				unconverged indicates whether Dlaqr04 computed all the eigenvalues of H[ilo:ihi+1,ilo:ihi+1].
				
				If unconverged is zero and wantt is true, H will contain on return the upper
				quasi-triangular matrix T from the Schur decomposition. 2×2 diagonal blocks
				(corresponding to complex conjugate pairs of eigenvalues) will be returned in
				standard form, with H[i,i] == H[i+1,i+1] and H[i+1,i]*H[i,i+1] &lt; 0.
				
				If unconverged is zero and if wantt is false, the contents of h on return is
				unspecified.
				
				If unconverged is zero, all the eigenvalues have been computed and their real
				and imaginary parts will be stored on return in wr[ilo:ihi+1] and
				wi[ilo:ihi+1], respectively. If two eigenvalues are computed as a complex
				conjugate pair, they are stored in consecutive elements of wr and wi, say the
				i-th and (i+1)th, with wi[i] &gt; 0 and wi[i+1] &lt; 0. If wantt is true, then the
				eigenvalues are stored in the same order as on the diagonal of the Schur form
				returned in H, with wr[i] = H[i,i] and, if H[i:i+2,i:i+2] is a 2×2 diagonal
				block, wi[i] = sqrt(-H[i+1,i]*H[i,i+1]) and wi[i+1] = -wi[i].
				
				If unconverged is positive, some eigenvalues have not converged, and
				wr[unconverged:ihi+1] and wi[unconverged:ihi+1] will contain those
				eigenvalues which have been successfully computed. Failures are rare.
				
				If unconverged is positive and wantt is true, then on return
				
					(initial H)*U = U*(final H),   (*)
				
				where U is an orthogonal matrix. The final H is upper Hessenberg and
				H[unconverged:ihi+1,unconverged:ihi+1] is upper quasi-triangular.
				
				If unconverged is positive and wantt is false, on return the remaining
				unconverged eigenvalues are the eigenvalues of the upper Hessenberg matrix
				H[ilo:unconverged,ilo:unconverged].
				
				If unconverged is positive and wantz is true, then on return
				
					(final Z) = (initial Z)*U,
				
				where U is the orthogonal matrix in (*) regardless of the value of wantt.
				
				References:
				
					[1] K. Braman, R. Byers, R. Mathias. The Multishift QR Algorithm. Part I:
					    Maintaining Well-Focused Shifts and Level 3 Performance. SIAM J. Matrix
					    Anal. Appl. 23(4) (2002), pp. 929—947
					    URL: http://dx.doi.org/10.1137/S0895479801384573
					[2] K. Braman, R. Byers, R. Mathias. The Multishift QR Algorithm. Part II:
					    Aggressive Early Deflation. SIAM J. Matrix Anal. Appl. 23(4) (2002), pp. 948—973
					    URL: http://dx.doi.org/10.1137/S0895479801384585
				
				Dlaqr04 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlaqr1"><label for="Implementation-fold-method-Dlaqr1">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaqr1.go.html#line-22">Dlaqr1</a>(n <a href="../../../../builtin.html#name-int">int</a>, h []<a href="../../../../builtin.html#name-float64">float64</a>, ldh <a href="../../../../builtin.html#name-int">int</a>, sr1, si1, sr2, si2 <a href="../../../../builtin.html#name-float64">float64</a>, v []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlaqr1-docs' class="fold-docs">
<span class="md-text">				Dlaqr1 sets v to a scalar multiple of the first column of the product
				
					(H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
				
				where H is a 2×2 or 3×3 matrix, I is the identity matrix of the same size,
				and i is the imaginary unit. Scaling is done to avoid overflows and most
				underflows.
				
				n is the order of H and must be either 2 or 3. It must hold that either sr1 =
				sr2 and si1 = -si2, or si1 = si2 = 0. The length of v must be equal to n. If
				any of these conditions is not met, Dlaqr1 will panic.
				
				Dlaqr1 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlaqr23"><label for="Implementation-fold-method-Dlaqr23">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaqr23.go.html#line-89">Dlaqr23</a>(wantt, wantz <a href="../../../../builtin.html#name-bool">bool</a>, n, ktop, kbot, nw <a href="../../../../builtin.html#name-int">int</a>, h []<a href="../../../../builtin.html#name-float64">float64</a>, ldh <a href="../../../../builtin.html#name-int">int</a>, iloz, ihiz <a href="../../../../builtin.html#name-int">int</a>, z []<a href="../../../../builtin.html#name-float64">float64</a>, ldz <a href="../../../../builtin.html#name-int">int</a>, sr, si []<a href="../../../../builtin.html#name-float64">float64</a>, v []<a href="../../../../builtin.html#name-float64">float64</a>, ldv <a href="../../../../builtin.html#name-int">int</a>, nh <a href="../../../../builtin.html#name-int">int</a>, t []<a href="../../../../builtin.html#name-float64">float64</a>, ldt <a href="../../../../builtin.html#name-int">int</a>, nv <a href="../../../../builtin.html#name-int">int</a>, wv []<a href="../../../../builtin.html#name-float64">float64</a>, ldwv <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>, recur <a href="../../../../builtin.html#name-int">int</a>) (ns, nd <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlaqr23-docs' class="fold-docs">
<span class="md-text">				Dlaqr23 performs the orthogonal similarity transformation of an n×n upper
				Hessenberg matrix to detect and deflate fully converged eigenvalues from a
				trailing principal submatrix using aggressive early deflation [1].
				
				On return, H will be overwritten by a new Hessenberg matrix that is a
				perturbation of an orthogonal similarity transformation of H. It is hoped
				that on output H will have many zero subdiagonal entries.
				
				If wantt is true, the matrix H will be fully updated so that the
				quasi-triangular Schur factor can be computed. If wantt is false, then only
				enough of H will be updated to preserve the eigenvalues.
				
				If wantz is true, the orthogonal similarity transformation will be
				accumulated into Z[iloz:ihiz+1,ktop:kbot+1], otherwise Z is not referenced.
				
				ktop and kbot determine a block [ktop:kbot+1,ktop:kbot+1] along the diagonal
				of H. It must hold that
				
					0 &lt;= ilo &lt;= ihi &lt; n     if n &gt; 0,
					ilo == 0 and ihi == -1  if n == 0,
				
				and the block must be isolated, that is, it must hold that
				
					ktop == 0   or H[ktop,ktop-1] == 0,
					kbot == n-1 or H[kbot+1,kbot] == 0,
				
				otherwise Dlaqr23 will panic.
				
				nw is the deflation window size. It must hold that
				
					0 &lt;= nw &lt;= kbot-ktop+1,
				
				otherwise Dlaqr23 will panic.
				
				iloz and ihiz specify the rows of the n×n matrix Z to which transformations
				will be applied if wantz is true. It must hold that
				
					0 &lt;= iloz &lt;= ktop,  and  kbot &lt;= ihiz &lt; n,
				
				otherwise Dlaqr23 will panic.
				
				sr and si must have length kbot+1, otherwise Dlaqr23 will panic.
				
				v and ldv represent an nw×nw work matrix.
				t and ldt represent an nw×nh work matrix, and nh must be at least nw.
				wv and ldwv represent an nv×nw work matrix.
				
				work must have length at least lwork and lwork must be at least max(1,2*nw),
				otherwise Dlaqr23 will panic. Larger values of lwork may result in greater
				efficiency. On return, work[0] will contain the optimal value of lwork.
				
				If lwork is -1, instead of performing Dlaqr23, the function only estimates the
				optimal workspace size and stores it into work[0]. Neither h nor z are
				accessed.
				
				recur is the non-negative recursion depth. For recur &gt; 0, Dlaqr23 behaves
				as DLAQR3, for recur == 0 it behaves as DLAQR2.
				
				On return, ns and nd will contain respectively the number of unconverged
				(i.e., approximate) eigenvalues and converged eigenvalues that are stored in
				sr and si.
				
				On return, the real and imaginary parts of approximate eigenvalues that may
				be used for shifts will be stored respectively in sr[kbot-nd-ns+1:kbot-nd+1]
				and si[kbot-nd-ns+1:kbot-nd+1].
				
				On return, the real and imaginary parts of converged eigenvalues will be
				stored respectively in sr[kbot-nd+1:kbot+1] and si[kbot-nd+1:kbot+1].
				
				References:
				
					[1] K. Braman, R. Byers, R. Mathias. The Multishift QR Algorithm. Part II:
					    Aggressive Early Deflation. SIAM J. Matrix Anal. Appl 23(4) (2002), pp. 948—973
					    URL: http://dx.doi.org/10.1137/S0895479801384585</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlaqr5"><label for="Implementation-fold-method-Dlaqr5">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaqr5.go.html#line-72">Dlaqr5</a>(wantt, wantz <a href="../../../../builtin.html#name-bool">bool</a>, kacc22 <a href="../../../../builtin.html#name-int">int</a>, n, ktop, kbot, nshfts <a href="../../../../builtin.html#name-int">int</a>, sr, si []<a href="../../../../builtin.html#name-float64">float64</a>, h []<a href="../../../../builtin.html#name-float64">float64</a>, ldh <a href="../../../../builtin.html#name-int">int</a>, iloz, ihiz <a href="../../../../builtin.html#name-int">int</a>, z []<a href="../../../../builtin.html#name-float64">float64</a>, ldz <a href="../../../../builtin.html#name-int">int</a>, v []<a href="../../../../builtin.html#name-float64">float64</a>, ldv <a href="../../../../builtin.html#name-int">int</a>, u []<a href="../../../../builtin.html#name-float64">float64</a>, ldu <a href="../../../../builtin.html#name-int">int</a>, nv <a href="../../../../builtin.html#name-int">int</a>, wv []<a href="../../../../builtin.html#name-float64">float64</a>, ldwv <a href="../../../../builtin.html#name-int">int</a>, nh <a href="../../../../builtin.html#name-int">int</a>, wh []<a href="../../../../builtin.html#name-float64">float64</a>, ldwh <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlaqr5-docs' class="fold-docs">
<span class="md-text">				Dlaqr5 performs a single small-bulge multi-shift QR sweep on an isolated
				block of a Hessenberg matrix.
				
				wantt and wantz determine whether the quasi-triangular Schur factor and the
				orthogonal Schur factor, respectively, will be computed.
				
				kacc22 specifies the computation mode of far-from-diagonal orthogonal
				updates. Permitted values are:
				
					0: Dlaqr5 will not accumulate reflections and will not use matrix-matrix
					   multiply to update far-from-diagonal matrix entries.
					1: Dlaqr5 will accumulate reflections and use matrix-matrix multiply to
					   update far-from-diagonal matrix entries.
					2: Same as kacc22=1. This option used to enable exploiting the 2×2 structure
					   during matrix multiplications, but this is no longer supported.
				
				For other values of kacc2 Dlaqr5 will panic.
				
				n is the order of the Hessenberg matrix H.
				
				ktop and kbot are indices of the first and last row and column of an isolated
				diagonal block upon which the QR sweep will be applied. It must hold that
				
					ktop == 0,   or 0 &lt; ktop &lt;= n-1 and H[ktop, ktop-1] == 0, and
					kbot == n-1, or 0 &lt;= kbot &lt; n-1 and H[kbot+1, kbot] == 0,
				
				otherwise Dlaqr5 will panic.
				
				nshfts is the number of simultaneous shifts. It must be positive and even,
				otherwise Dlaqr5 will panic.
				
				sr and si contain the real and imaginary parts, respectively, of the shifts
				of origin that define the multi-shift QR sweep. On return both slices may be
				reordered by Dlaqr5. Their length must be equal to nshfts, otherwise Dlaqr5
				will panic.
				
				h and ldh represent the Hessenberg matrix H of size n×n. On return
				multi-shift QR sweep with shifts sr+i*si has been applied to the isolated
				diagonal block in rows and columns ktop through kbot, inclusive.
				
				iloz and ihiz specify the rows of Z to which transformations will be applied
				if wantz is true. It must hold that 0 &lt;= iloz &lt;= ihiz &lt; n, otherwise Dlaqr5
				will panic.
				
				z and ldz represent the matrix Z of size n×n. If wantz is true, the QR sweep
				orthogonal similarity transformation is accumulated into
				z[iloz:ihiz,iloz:ihiz] from the right, otherwise z not referenced.
				
				v and ldv represent an auxiliary matrix V of size (nshfts/2)×3. Note that V
				is transposed with respect to the reference netlib implementation.
				
				u and ldu represent an auxiliary matrix of size (2*nshfts)×(2*nshfts).
				
				wh and ldwh represent an auxiliary matrix of size (2*nshfts-1)×nh.
				
				wv and ldwv represent an auxiliary matrix of size nv×(2*nshfts-1).
				
				Dlaqr5 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlarf"><label for="Implementation-fold-method-Dlarf">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlarf.go.html#line-27">Dlarf</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, v []<a href="../../../../builtin.html#name-float64">float64</a>, incv <a href="../../../../builtin.html#name-int">int</a>, tau <a href="../../../../builtin.html#name-float64">float64</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlarf-docs' class="fold-docs">
<span class="md-text">				Dlarf applies an elementary reflector H to an m×n matrix C:
				
					C = H * C  if side == blas.Left
					C = C * H  if side == blas.Right
				
				H is represented in the form
				
					H = I - tau * v * vᵀ
				
				where tau is a scalar and v is a vector.
				
				work must have length at least m if side == blas.Left and
				at least n if side == blas.Right.
				
				Dlarf is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlarfb"><label for="Implementation-fold-method-Dlarfb">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlarfb.go.html#line-70">Dlarfb</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, direct <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-Direct">Direct</a>, store <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-StoreV">StoreV</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, v []<a href="../../../../builtin.html#name-float64">float64</a>, ldv <a href="../../../../builtin.html#name-int">int</a>, t []<a href="../../../../builtin.html#name-float64">float64</a>, ldt <a href="../../../../builtin.html#name-int">int</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, ldwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlarfb-docs' class="fold-docs">
<span class="md-text">				Dlarfb applies a block reflector to a matrix.
				
				In the call to Dlarfb, the mxn c is multiplied by the implicitly defined matrix h as follows:
				
					c = h * c   if side == Left and trans == NoTrans
					c = c * h   if side == Right and trans == NoTrans
					c = hᵀ * c  if side == Left and trans == Trans
					c = c * hᵀ  if side == Right and trans == Trans
				
				h is a product of elementary reflectors. direct sets the direction of multiplication
				
					h = h_1 * h_2 * ... * h_k    if direct == Forward
					h = h_k * h_k-1 * ... * h_1  if direct == Backward
				
				The combination of direct and store defines the orientation of the elementary
				reflectors. In all cases the ones on the diagonal are implicitly represented.
				
				If direct == lapack.Forward and store == lapack.ColumnWise
				
					V = [ 1        ]
					    [v1   1    ]
					    [v1  v2   1]
					    [v1  v2  v3]
					    [v1  v2  v3]
				
				If direct == lapack.Forward and store == lapack.RowWise
				
					V = [ 1  v1  v1  v1  v1]
					    [     1  v2  v2  v2]
					    [         1  v3  v3]
				
				If direct == lapack.Backward and store == lapack.ColumnWise
				
					V = [v1  v2  v3]
					    [v1  v2  v3]
					    [ 1  v2  v3]
					    [     1  v3]
					    [         1]
				
				If direct == lapack.Backward and store == lapack.RowWise
				
					V = [v1  v1   1        ]
					    [v2  v2  v2   1    ]
					    [v3  v3  v3  v3   1]
				
				An elementary reflector can be explicitly constructed by extracting the
				corresponding elements of v, placing a 1 where the diagonal would be, and
				placing zeros in the remaining elements.
				
				t is a k×k matrix containing the block reflector, and this function will panic
				if t is not of sufficient size. See Dlarft for more information.
				
				work is a temporary storage matrix with stride ldwork.
				work must be of size at least n×k side == Left and m×k if side == Right, and
				this function will panic if this size is not met.
				
				Dlarfb is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlarfg"><label for="Implementation-fold-method-Dlarfg">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlarfg.go.html#line-29">Dlarfg</a>(n <a href="../../../../builtin.html#name-int">int</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>) (beta, tau <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlarfg-docs' class="fold-docs">
<span class="md-text">				Dlarfg generates an elementary reflector for a Householder matrix. It creates
				a real elementary reflector of order n such that
				
					H * (alpha) = (beta)
					    (    x)   (   0)
					Hᵀ * H = I
				
				H is represented in the form
				
					H = 1 - tau * (1; v) * (1 vᵀ)
				
				where tau is a real scalar.
				
				On entry, x contains the vector x, on exit it contains v.
				
				Dlarfg is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlarft"><label for="Implementation-fold-method-Dlarft">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlarft.go.html#line-34">Dlarft</a>(direct <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-Direct">Direct</a>, store <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-StoreV">StoreV</a>, n, k <a href="../../../../builtin.html#name-int">int</a>, v []<a href="../../../../builtin.html#name-float64">float64</a>, ldv <a href="../../../../builtin.html#name-int">int</a>, tau []<a href="../../../../builtin.html#name-float64">float64</a>, t []<a href="../../../../builtin.html#name-float64">float64</a>, ldt <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlarft-docs' class="fold-docs">
<span class="md-text">				Dlarft forms the triangular factor T of a block reflector H, storing the answer
				in t.
				
					H = I - V * T * Vᵀ  if store == lapack.ColumnWise
					H = I - Vᵀ * T * V  if store == lapack.RowWise
				
				H is defined by a product of the elementary reflectors where
				
					H = H_0 * H_1 * ... * H_{k-1}  if direct == lapack.Forward
					H = H_{k-1} * ... * H_1 * H_0  if direct == lapack.Backward
				
				t is a k×k triangular matrix. t is upper triangular if direct = lapack.Forward
				and lower triangular otherwise. This function will panic if t is not of
				sufficient size.
				
				store describes the storage of the elementary reflectors in v. See
				Dlarfb for a description of layout.
				
				tau contains the scalar factors of the elementary reflectors H_i.
				
				Dlarft is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlarfx"><label for="Implementation-fold-method-Dlarfx">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlarfx.go.html#line-31">Dlarfx</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, v []<a href="../../../../builtin.html#name-float64">float64</a>, tau <a href="../../../../builtin.html#name-float64">float64</a>, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlarfx-docs' class="fold-docs">
<span class="md-text">				Dlarfx applies an elementary reflector H to a real m×n matrix C, from either
				the left or the right, with loop unrolling when the reflector has order less
				than 11.
				
				H is represented in the form
				
					H = I - tau * v * vᵀ,
				
				where tau is a real scalar and v is a real vector. If tau = 0, then H is
				taken to be the identity matrix.
				
				v must have length equal to m if side == blas.Left, and equal to n if side ==
				blas.Right, otherwise Dlarfx will panic.
				
				c and ldc represent the m×n matrix C. On return, C is overwritten by the
				matrix H * C if side == blas.Left, or C * H if side == blas.Right.
				
				work must have length at least n if side == blas.Left, and at least m if side
				== blas.Right, otherwise Dlarfx will panic. work is not referenced if H has
				order &lt; 11.
				
				Dlarfx is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlartg"><label for="Implementation-fold-method-Dlartg">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlartg.go.html#line-23">Dlartg</a>(f, g <a href="../../../../builtin.html#name-float64">float64</a>) (cs, sn, r <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlartg-docs' class="fold-docs">
<span class="md-text">				Dlartg generates a plane rotation so that
				
					[ cs sn] * [f] = [r]
					[-sn cs]   [g] = [0]
				
				where cs*cs + sn*sn = 1.
				
				This is a more accurate version of BLAS Drotg that uses scaling to avoid
				overflow or underflow, with the other differences that
				  - cs &gt;= 0
				  - if g = 0, then cs = 1 and sn = 0
				  - if f = 0 and g != 0, then cs = 0 and sn = sign(1,g)
				
				Dlartg is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlas2"><label for="Implementation-fold-method-Dlas2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlas2.go.html#line-17">Dlas2</a>(f, g, h <a href="../../../../builtin.html#name-float64">float64</a>) (ssmin, ssmax <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlas2-docs' class="fold-docs">
<span class="md-text">				Dlas2 computes the singular values of the 2×2 matrix defined by
				
					[F G]
					[0 H]
				
				The smaller and larger singular values are returned in that order.
				
				Dlas2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlascl"><label for="Implementation-fold-method-Dlascl">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlascl.go.html#line-19">Dlascl</a>(kind <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixType">MatrixType</a>, kl, ku <a href="../../../../builtin.html#name-int">int</a>, cfrom, cto <a href="../../../../builtin.html#name-float64">float64</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlascl-docs' class="fold-docs">
<span class="md-text">				Dlascl multiplies an m×n matrix by the scalar cto/cfrom.
				
				cfrom must not be zero, and cto and cfrom must not be NaN, otherwise Dlascl
				will panic.
				
				Dlascl is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlaset"><label for="Implementation-fold-method-Dlaset">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaset.go.html#line-16">Dlaset</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, alpha, beta <a href="../../../../builtin.html#name-float64">float64</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlaset-docs' class="fold-docs">
<span class="md-text">				Dlaset sets the off-diagonal elements of A to alpha, and the diagonal
				elements to beta. If uplo == blas.Upper, only the elements in the upper
				triangular part are set. If uplo == blas.Lower, only the elements in the
				lower triangular part are set. If uplo is otherwise, all of the elements of A
				are set.
				
				Dlaset is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlasq1"><label for="Implementation-fold-method-Dlasq1">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasq1.go.html#line-21">Dlasq1</a>(n <a href="../../../../builtin.html#name-int">int</a>, d, e, work []<a href="../../../../builtin.html#name-float64">float64</a>) (info <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlasq1-docs' class="fold-docs">
<span class="md-text">				Dlasq1 computes the singular values of an n×n bidiagonal matrix with diagonal
				d and off-diagonal e. On exit, d contains the singular values in decreasing
				order, and e is overwritten. d must have length at least n, e must have
				length at least n-1, and the input work must have length at least 4*n. Dlasq1
				will panic if these conditions are not met.
				
				Dlasq1 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlasq2"><label for="Implementation-fold-method-Dlasq2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasq2.go.html#line-38">Dlasq2</a>(n <a href="../../../../builtin.html#name-int">int</a>, z []<a href="../../../../builtin.html#name-float64">float64</a>) (info <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlasq2-docs' class="fold-docs">
<span class="md-text">				Dlasq2 computes all the eigenvalues of the symmetric positive
				definite tridiagonal matrix associated with the qd array Z. Eigevalues
				are computed to high relative accuracy avoiding denormalization, underflow
				and overflow.
				
				To see the relation of Z to the tridiagonal matrix, let L be a
				unit lower bidiagonal matrix with sub-diagonals Z(2,4,6,,..) and
				let U be an upper bidiagonal matrix with 1's above and diagonal
				Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
				symmetric tridiagonal to which it is similar.
				
				info returns a status error. The return codes mean as follows:
				
					0: The algorithm completed successfully.
					1: A split was marked by a positive value in e.
					2: Current block of Z not diagonalized after 100*n iterations (in inner
					   while loop). On exit Z holds a qd array with the same eigenvalues as
					   the given Z.
					3: Termination criterion of outer while loop not met (program created more
					   than N unreduced blocks).
				
				z must have length at least 4*n, and must not contain any negative elements.
				Dlasq2 will panic otherwise.
				
				Dlasq2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlasq3"><label for="Implementation-fold-method-Dlasq3">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasq3.go.html#line-14">Dlasq3</a>(i0, n0 <a href="../../../../builtin.html#name-int">int</a>, z []<a href="../../../../builtin.html#name-float64">float64</a>, pp <a href="../../../../builtin.html#name-int">int</a>, dmin, sigma, desig, qmax <a href="../../../../builtin.html#name-float64">float64</a>, nFail, iter, nDiv <a href="../../../../builtin.html#name-int">int</a>, ttype <a href="../../../../builtin.html#name-int">int</a>, dmin1, dmin2, dn, dn1, dn2, g, tau <a href="../../../../builtin.html#name-float64">float64</a>) (i0Out, n0Out, ppOut <a href="../../../../builtin.html#name-int">int</a>, dminOut, sigmaOut, desigOut, qmaxOut <a href="../../../../builtin.html#name-float64">float64</a>, nFailOut, iterOut, nDivOut, ttypeOut <a href="../../../../builtin.html#name-int">int</a>, dmin1Out, dmin2Out, dnOut, dn1Out, dn2Out, gOut, tauOut <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlasq3-docs' class="fold-docs">
<span class="md-text">				Dlasq3 checks for deflation, computes a shift (tau) and calls dqds.
				In case of failure it changes shifts, and tries again until output
				is positive.
				
				Dlasq3 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlasq4"><label for="Implementation-fold-method-Dlasq4">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasq4.go.html#line-14">Dlasq4</a>(i0, n0 <a href="../../../../builtin.html#name-int">int</a>, z []<a href="../../../../builtin.html#name-float64">float64</a>, pp <a href="../../../../builtin.html#name-int">int</a>, n0in <a href="../../../../builtin.html#name-int">int</a>, dmin, dmin1, dmin2, dn, dn1, dn2, tau <a href="../../../../builtin.html#name-float64">float64</a>, ttype <a href="../../../../builtin.html#name-int">int</a>, g <a href="../../../../builtin.html#name-float64">float64</a>) (tauOut <a href="../../../../builtin.html#name-float64">float64</a>, ttypeOut <a href="../../../../builtin.html#name-int">int</a>, gOut <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlasq4-docs' class="fold-docs">
<span class="md-text">				Dlasq4 computes an approximation to the smallest eigenvalue using values of d
				from the previous transform.
				i0, n0, and n0in are zero-indexed.
				
				Dlasq4 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlasq5"><label for="Implementation-fold-method-Dlasq5">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasq5.go.html#line-13">Dlasq5</a>(i0, n0 <a href="../../../../builtin.html#name-int">int</a>, z []<a href="../../../../builtin.html#name-float64">float64</a>, pp <a href="../../../../builtin.html#name-int">int</a>, tau, sigma <a href="../../../../builtin.html#name-float64">float64</a>) (i0Out, n0Out, ppOut <a href="../../../../builtin.html#name-int">int</a>, tauOut, sigmaOut, dmin, dmin1, dmin2, dn, dnm1, dnm2 <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlasq5-docs' class="fold-docs">
<span class="md-text">				Dlasq5 computes one dqds transform in ping-pong form.
				i0 and n0 are zero-indexed.
				
				Dlasq5 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlasq6"><label for="Implementation-fold-method-Dlasq6">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasq6.go.html#line-15">Dlasq6</a>(i0, n0 <a href="../../../../builtin.html#name-int">int</a>, z []<a href="../../../../builtin.html#name-float64">float64</a>, pp <a href="../../../../builtin.html#name-int">int</a>) (dmin, dmin1, dmin2, dn, dnm1, dnm2 <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlasq6-docs' class="fold-docs">
<span class="md-text">				Dlasq6 computes one dqd transform in ping-pong form with protection against
				overflow and underflow. z has length at least 4*(n0+1) and holds the qd array.
				i0 is the zero-based first index.
				n0 is the zero-based last index.
				
				Dlasq6 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlasr"><label for="Implementation-fold-method-Dlasr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasr.go.html#line-65">Dlasr</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, pivot <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-Pivot">Pivot</a>, direct <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-Direct">Direct</a>, m, n <a href="../../../../builtin.html#name-int">int</a>, c, s, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlasr-docs' class="fold-docs">
<span class="md-text">				Dlasr applies a sequence of plane rotations to the m×n matrix A. This series
				of plane rotations is implicitly represented by a matrix P. P is multiplied
				by a depending on the value of side -- A = P * A if side == lapack.Left,
				A = A * Pᵀ if side == lapack.Right.
				
				The exact value of P depends on the value of pivot, but in all cases P is
				implicitly represented by a series of 2×2 rotation matrices. The entries of
				rotation matrix k are defined by s[k] and c[k]
				
					R(k) = [ c[k] s[k]]
					       [-s[k] s[k]]
				
				If direct == lapack.Forward, the rotation matrices are applied as
				P = P(z-1) * ... * P(2) * P(1), while if direct == lapack.Backward they are
				applied as P = P(1) * P(2) * ... * P(n).
				
				pivot defines the mapping of the elements in R(k) to P(k).
				If pivot == lapack.Variable, the rotation is performed for the (k, k+1) plane.
				
					P(k) = [1                    ]
					       [    ...              ]
					       [     1               ]
					       [       c[k] s[k]     ]
					       [      -s[k] c[k]     ]
					       [                 1   ]
					       [                ...  ]
					       [                    1]
				
				if pivot == lapack.Top, the rotation is performed for the (1, k+1) plane,
				
					P(k) = [c[k]        s[k]     ]
					       [    1                ]
					       [     ...             ]
					       [         1           ]
					       [-s[k]       c[k]     ]
					       [                 1   ]
					       [                ...  ]
					       [                    1]
				
				and if pivot == lapack.Bottom, the rotation is performed for the (k, z) plane.
				
					P(k) = [1                    ]
					       [  ...                ]
					       [      1              ]
					       [        c[k]     s[k]]
					       [           1         ]
					       [            ...      ]
					       [              1      ]
					       [       -s[k]     c[k]]
				
				s and c have length m - 1 if side == blas.Left, and n - 1 if side == blas.Right.
				
				Dlasr is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlasrt"><label for="Implementation-fold-method-Dlasrt">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasrt.go.html#line-19">Dlasrt</a>(s <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-Sort">Sort</a>, n <a href="../../../../builtin.html#name-int">int</a>, d []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlasrt-docs' class="fold-docs">
<span class="md-text">				Dlasrt sorts the numbers in the input slice d. If s == lapack.SortIncreasing,
				the elements are sorted in increasing order. If s == lapack.SortDecreasing,
				the elements are sorted in decreasing order. For other values of s Dlasrt
				will panic.
				
				Dlasrt is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlassq"><label for="Implementation-fold-method-Dlassq">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlassq.go.html#line-17">Dlassq</a>(n <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incx <a href="../../../../builtin.html#name-int">int</a>, scale <a href="../../../../builtin.html#name-float64">float64</a>, sumsq <a href="../../../../builtin.html#name-float64">float64</a>) (scl, smsq <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlassq-docs' class="fold-docs">
<span class="md-text">				Dlassq updates a sum of squares represented in scaled form. Dlassq returns
				the values scl and smsq such that
				
					scl^2*smsq = X[0]^2 + ... + X[n-1]^2 + scale^2*sumsq
				
				The value of sumsq is assumed to be non-negative.
				
				Dlassq is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlasv2"><label for="Implementation-fold-method-Dlasv2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasv2.go.html#line-18">Dlasv2</a>(f, g, h <a href="../../../../builtin.html#name-float64">float64</a>) (ssmin, ssmax, snr, csr, snl, csl <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlasv2-docs' class="fold-docs">
<span class="md-text">				Dlasv2 computes the singular value decomposition of a 2×2 matrix.
				
					[ csl snl] [f g] [csr -snr] = [ssmax     0]
					[-snl csl] [0 h] [snr  csr] = [    0 ssmin]
				
				ssmax is the larger absolute singular value, and ssmin is the smaller absolute
				singular value. [cls, snl] and [csr, snr] are the left and right singular vectors.
				
				Dlasv2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlaswp"><label for="Implementation-fold-method-Dlaswp">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlaswp.go.html#line-20">Dlaswp</a>(n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, k1, k2 <a href="../../../../builtin.html#name-int">int</a>, ipiv []<a href="../../../../builtin.html#name-int">int</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlaswp-docs' class="fold-docs">
<span class="md-text">				Dlaswp swaps the rows k1 to k2 of a rectangular matrix A according to the
				indices in ipiv so that row k is swapped with ipiv[k].
				
				n is the number of columns of A and incX is the increment for ipiv. If incX
				is 1, the swaps are applied from k1 to k2. If incX is -1, the swaps are
				applied in reverse order from k2 to k1. For other values of incX Dlaswp will
				panic. ipiv must have length k2+1, otherwise Dlaswp will panic.
				
				The indices k1, k2, and the elements of ipiv are zero-based.
				
				Dlaswp is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlasy2"><label for="Implementation-fold-method-Dlasy2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlasy2.go.html#line-32">Dlasy2</a>(tranl, tranr <a href="../../../../builtin.html#name-bool">bool</a>, isgn, n1, n2 <a href="../../../../builtin.html#name-int">int</a>, tl []<a href="../../../../builtin.html#name-float64">float64</a>, ldtl <a href="../../../../builtin.html#name-int">int</a>, tr []<a href="../../../../builtin.html#name-float64">float64</a>, ldtr <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, ldx <a href="../../../../builtin.html#name-int">int</a>) (scale, xnorm <a href="../../../../builtin.html#name-float64">float64</a>, ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dlasy2-docs' class="fold-docs">
<span class="md-text">				Dlasy2 solves the Sylvester matrix equation where the matrices are of order 1
				or 2. It computes the unknown n1×n2 matrix X so that
				
					TL*X   + sgn*X*TR  = scale*B  if tranl == false and tranr == false,
					TLᵀ*X + sgn*X*TR   = scale*B  if tranl == true  and tranr == false,
					TL*X   + sgn*X*TRᵀ = scale*B  if tranl == false and tranr == true,
					TLᵀ*X + sgn*X*TRᵀ  = scale*B  if tranl == true  and tranr == true,
				
				where TL is n1×n1, TR is n2×n2, B is n1×n2, and 1 &lt;= n1,n2 &lt;= 2.
				
				isgn must be 1 or -1, and n1 and n2 must be 0, 1, or 2, but these conditions
				are not checked.
				
				Dlasy2 returns three values, a scale factor that is chosen less than or equal
				to 1 to prevent the solution overflowing, the infinity norm of the solution,
				and an indicator of success. If ok is false, TL and TR have eigenvalues that
				are too close, so TL or TR is perturbed to get a non-singular equation.
				
				Dlasy2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlatbs"><label for="Implementation-fold-method-Dlatbs">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlatbs.go.html#line-36">Dlatbs</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, normin <a href="../../../../builtin.html#name-bool">bool</a>, n, kd <a href="../../../../builtin.html#name-int">int</a>, ab []<a href="../../../../builtin.html#name-float64">float64</a>, ldab <a href="../../../../builtin.html#name-int">int</a>, x, cnorm []<a href="../../../../builtin.html#name-float64">float64</a>) (scale <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlatbs-docs' class="fold-docs">
<span class="md-text">				Dlatbs solves a triangular banded system of equations
				
					A * x = s*b    if trans == blas.NoTrans
					Aᵀ * x = s*b  if trans == blas.Trans or blas.ConjTrans
				
				where A is an upper or lower triangular band matrix, x and b are n-element
				vectors, and s is a scaling factor chosen so that the components of x will be
				less than the overflow threshold.
				
				On entry, x contains the right-hand side b of the triangular system.
				On return, x is overwritten by the solution vector x.
				
				normin specifies whether the cnorm parameter contains the column norms of A on
				entry. If it is true, cnorm[j] contains the norm of the off-diagonal part of
				the j-th column of A. If it is false, the norms will be computed and stored
				in cnorm.
				
				Dlatbs returns the scaling factor s for the triangular system. If the matrix
				A is singular (A[j,j]==0 for some j), then scale is set to 0 and a
				non-trivial solution to A*x = 0 is returned.
				
				Dlatbs is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlatdf"><label for="Implementation-fold-method-Dlatdf">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlatdf.go.html#line-54">Dlatdf</a>(job <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MaximizeNormXJob">MaximizeNormXJob</a>, n <a href="../../../../builtin.html#name-int">int</a>, z []<a href="../../../../builtin.html#name-float64">float64</a>, ldz <a href="../../../../builtin.html#name-int">int</a>, rhs []<a href="../../../../builtin.html#name-float64">float64</a>, rdsum, rdscal <a href="../../../../builtin.html#name-float64">float64</a>, ipiv, jpiv []<a href="../../../../builtin.html#name-int">int</a>) (scale, sum <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlatdf-docs' class="fold-docs">
<span class="md-text">				Dlatdf computes a contribution to the reciprocal Dif-estimate by solving
				
					Z * x = h - f
				
				and choosing the vector h such that the norm of x is as large as possible.
				
				The n×n matrix Z is represented by its LU factorization as computed by Dgetc2
				and has the form
				
					Z = P * L * U * Q
				
				where P and Q are permutation matrices, L is lower triangular with unit
				diagonal elements and U is upper triangular.
				
				job specifies the heuristic method for computing the contribution.
				
				If job is lapack.LocalLookAhead, all entries of h are chosen as either +1 or
				-1.
				
				If job is lapack.NormalizedNullVector, an approximate null-vector e of Z is
				computed using Dgecon and normalized. h is chosen as ±e with the sign giving
				the greater value of 2-norm(x). This strategy is about 5 times as expensive
				as LocalLookAhead.
				
				On entry, rhs holds the contribution f from earlier solved sub-systems. On
				return, rhs holds the solution x.
				
				ipiv and jpiv contain the pivot indices as returned by Dgetc2: row i of the
				matrix has been interchanged with row ipiv[i] and column j of the matrix has
				been interchanged with column jpiv[j].
				
				n must be at most 8, ipiv and jpiv must have length n, and rhs must have
				length at least n, otherwise Dlatdf will panic.
				
				rdsum and rdscal represent the sum of squares of computed contributions to
				the Dif-estimate from earlier solved sub-systems. rdscal is the scaling
				factor used to prevent overflow in rdsum. Dlatdf returns this sum of squares
				updated with the contributions from the current sub-system.
				
				Dlatdf is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlatrd"><label for="Implementation-fold-method-Dlatrd">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlatrd.go.html#line-79">Dlatrd</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n, nb <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, e, tau, w []<a href="../../../../builtin.html#name-float64">float64</a>, ldw <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlatrd-docs' class="fold-docs">
<span class="md-text">				Dlatrd reduces nb rows and columns of a real n×n symmetric matrix A to symmetric
				tridiagonal form. It computes the orthonormal similarity transformation
				
					Qᵀ * A * Q
				
				and returns the matrices V and W to apply to the unreduced part of A. If
				uplo == blas.Upper, the upper triangle is supplied and the last nb rows are
				reduced. If uplo == blas.Lower, the lower triangle is supplied and the first
				nb rows are reduced.
				
				a contains the symmetric matrix on entry with active triangular half specified
				by uplo. On exit, the nb columns have been reduced to tridiagonal form. The
				diagonal contains the diagonal of the reduced matrix, the off-diagonal is
				set to 1, and the remaining elements contain the data to construct Q.
				
				If uplo == blas.Upper, with n = 5 and nb = 2 on exit a is
				
					[ a   a   a  v4  v5]
					[     a   a  v4  v5]
					[         a   1  v5]
					[             d   1]
					[                 d]
				
				If uplo == blas.Lower, with n = 5 and nb = 2, on exit a is
				
					[ d                ]
					[ 1   d            ]
					[v1   1   a        ]
					[v1  v2   a   a    ]
					[v1  v2   a   a   a]
				
				e contains the superdiagonal elements of the reduced matrix. If uplo == blas.Upper,
				e[n-nb:n-1] contains the last nb columns of the reduced matrix, while if
				uplo == blas.Lower, e[:nb] contains the first nb columns of the reduced matrix.
				e must have length at least n-1, and Dlatrd will panic otherwise.
				
				tau contains the scalar factors of the elementary reflectors needed to construct Q.
				The reflectors are stored in tau[n-nb:n-1] if uplo == blas.Upper, and in
				tau[:nb] if uplo == blas.Lower. tau must have length n-1, and Dlatrd will panic
				otherwise.
				
				w is an n×nb matrix. On exit it contains the data to update the unreduced part
				of A.
				
				The matrix Q is represented as a product of elementary reflectors. Each reflector
				H has the form
				
					I - tau * v * vᵀ
				
				If uplo == blas.Upper,
				
					Q = H_{n-1} * H_{n-2} * ... * H_{n-nb}
				
				where v[:i-1] is stored in A[:i-1,i], v[i-1] = 1, and v[i:n] = 0.
				
				If uplo == blas.Lower,
				
					Q = H_0 * H_1 * ... * H_{nb-1}
				
				where v[:i+1] = 0, v[i+1] = 1, and v[i+2:n] is stored in A[i+2:n,i].
				
				The vectors v form the n×nb matrix V which is used with W to apply a
				symmetric rank-2 update to the unreduced part of A
				
					A = A - V * Wᵀ - W * Vᵀ
				
				Dlatrd is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlatrs"><label for="Implementation-fold-method-Dlatrs">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlatrs.go.html#line-33">Dlatrs</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, normin <a href="../../../../builtin.html#name-bool">bool</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, cnorm []<a href="../../../../builtin.html#name-float64">float64</a>) (scale <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dlatrs-docs' class="fold-docs">
<span class="md-text">				Dlatrs solves a triangular system of equations scaled to prevent overflow. It
				solves
				
					A * x = scale * b if trans == blas.NoTrans
					Aᵀ * x = scale * b if trans == blas.Trans
				
				where the scale s is set for numeric stability.
				
				A is an n×n triangular matrix. On entry, the slice x contains the values of
				b, and on exit it contains the solution vector x.
				
				If normin == true, cnorm is an input and cnorm[j] contains the norm of the off-diagonal
				part of the j^th column of A. If trans == blas.NoTrans, cnorm[j] must be greater
				than or equal to the infinity norm, and greater than or equal to the one-norm
				otherwise. If normin == false, then cnorm is treated as an output, and is set
				to contain the 1-norm of the off-diagonal part of the j^th column of A.
				
				Dlatrs is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlauu2"><label for="Implementation-fold-method-Dlauu2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlauu2.go.html#line-20">Dlauu2</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlauu2-docs' class="fold-docs">
<span class="md-text">				Dlauu2 computes the product
				
					U * Uᵀ  if uplo is blas.Upper
					Lᵀ * L  if uplo is blas.Lower
				
				where U or L is stored in the upper or lower triangular part of A.
				Only the upper or lower triangle of the result is stored, overwriting
				the corresponding factor in A.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dlauum"><label for="Implementation-fold-method-Dlauum">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dlauum.go.html#line-20">Dlauum</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dlauum-docs' class="fold-docs">
<span class="md-text">				Dlauum computes the product
				
					U * Uᵀ  if uplo is blas.Upper
					Lᵀ * L  if uplo is blas.Lower
				
				where U or L is stored in the upper or lower triangular part of A.
				Only the upper or lower triangle of the result is stored, overwriting
				the corresponding factor in A.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dorg2l"><label for="Implementation-fold-method-Dorg2l">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorg2l.go.html#line-26">Dorg2l</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dorg2l-docs' class="fold-docs">
<span class="md-text">				Dorg2l generates an m×n matrix Q with orthonormal columns which is defined
				as the last n columns of a product of k elementary reflectors of order m.
				
					Q = H_{k-1} * ... * H_1 * H_0
				
				See Dgelqf for more information. It must be that m &gt;= n &gt;= k.
				
				tau contains the scalar reflectors computed by Dgeqlf. tau must have length
				at least k, and Dorg2l will panic otherwise.
				
				work contains temporary memory, and must have length at least n. Dorg2l will
				panic otherwise.
				
				Dorg2l is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dorg2r"><label for="Implementation-fold-method-Dorg2r">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorg2r.go.html#line-21">Dorg2r</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau []<a href="../../../../builtin.html#name-float64">float64</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dorg2r-docs' class="fold-docs">
<span class="md-text">				Dorg2r generates an m×n matrix Q with orthonormal columns defined by the
				product of elementary reflectors as computed by Dgeqrf.
				
					Q = H_0 * H_1 * ... * H_{k-1}
				
				len(tau) &gt;= k, 0 &lt;= k &lt;= n, 0 &lt;= n &lt;= m, len(work) &gt;= n.
				Dorg2r will panic if these conditions are not met.
				
				Dorg2r is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dorgbr"><label for="Implementation-fold-method-Dorgbr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorgbr.go.html#line-22">Dorgbr</a>(vect <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-GenOrtho">GenOrtho</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dorgbr-docs' class="fold-docs">
<span class="md-text">				Dorgbr generates one of the matrices Q or Pᵀ computed by Dgebrd
				computed from the decomposition Dgebrd. See Dgebd2 for the description of
				Q and Pᵀ.
				
				If vect == lapack.GenerateQ, then a is assumed to have been an m×k matrix and
				Q is of order m. If m &gt;= k, then Dorgbr returns the first n columns of Q
				where m &gt;= n &gt;= k. If m &lt; k, then Dorgbr returns Q as an m×m matrix.
				
				If vect == lapack.GeneratePT, then A is assumed to have been a k×n matrix, and
				Pᵀ is of order n. If k &lt; n, then Dorgbr returns the first m rows of Pᵀ,
				where n &gt;= m &gt;= k. If k &gt;= n, then Dorgbr returns Pᵀ as an n×n matrix.
				
				Dorgbr is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dorghr"><label for="Implementation-fold-method-Dorghr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorghr.go.html#line-37">Dorghr</a>(n, ilo, ihi <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dorghr-docs' class="fold-docs">
<span class="md-text">				Dorghr generates an n×n orthogonal matrix Q which is defined as the product
				of ihi-ilo elementary reflectors:
				
					Q = H_{ilo} H_{ilo+1} ... H_{ihi-1}.
				
				a and lda represent an n×n matrix that contains the elementary reflectors, as
				returned by Dgehrd. On return, a is overwritten by the n×n orthogonal matrix
				Q. Q will be equal to the identity matrix except in the submatrix
				Q[ilo+1:ihi+1,ilo+1:ihi+1].
				
				ilo and ihi must have the same values as in the previous call of Dgehrd. It
				must hold that
				
					0 &lt;= ilo &lt;= ihi &lt; n  if n &gt; 0,
					ilo = 0, ihi = -1    if n == 0.
				
				tau contains the scalar factors of the elementary reflectors, as returned by
				Dgehrd. tau must have length n-1.
				
				work must have length at least max(1,lwork) and lwork must be at least
				ihi-ilo. For optimum performance lwork must be at least (ihi-ilo)*nb where nb
				is the optimal blocksize. On return, work[0] will contain the optimal value
				of lwork.
				
				If lwork == -1, instead of performing Dorghr, only the optimal value of lwork
				will be stored into work[0].
				
				If any requirement on input sizes is not met, Dorghr will panic.
				
				Dorghr is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dorgl2"><label for="Implementation-fold-method-Dorgl2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorgl2.go.html#line-21">Dorgl2</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dorgl2-docs' class="fold-docs">
<span class="md-text">				Dorgl2 generates an m×n matrix Q with orthonormal rows defined by the
				first m rows product of elementary reflectors as computed by Dgelqf.
				
					Q = H_0 * H_1 * ... * H_{k-1}
				
				len(tau) &gt;= k, 0 &lt;= k &lt;= m, 0 &lt;= m &lt;= n, len(work) &gt;= m.
				Dorgl2 will panic if these conditions are not met.
				
				Dorgl2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dorglq"><label for="Implementation-fold-method-Dorglq">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorglq.go.html#line-30">Dorglq</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dorglq-docs' class="fold-docs">
<span class="md-text">				Dorglq generates an m×n matrix Q with orthonormal columns defined by the
				product of elementary reflectors as computed by Dgelqf.
				
					Q = H_0 * H_1 * ... * H_{k-1}
				
				Dorglq is the blocked version of Dorgl2 that makes greater use of level-3 BLAS
				routines.
				
				len(tau) &gt;= k, 0 &lt;= k &lt;= m, and 0 &lt;= m &lt;= n.
				
				work is temporary storage, and lwork specifies the usable memory length. At minimum,
				lwork &gt;= m, and the amount of blocking is limited by the usable length.
				If lwork == -1, instead of computing Dorglq the optimal work length is stored
				into work[0].
				
				Dorglq will panic if the conditions on input values are not met.
				
				Dorglq is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dorgql"><label for="Implementation-fold-method-Dorgql">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorgql.go.html#line-37">Dorgql</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dorgql-docs' class="fold-docs">
<span class="md-text">				Dorgql generates the m×n matrix Q with orthonormal columns defined as the
				last n columns of a product of k elementary reflectors of order m
				
					Q = H_{k-1} * ... * H_1 * H_0.
				
				It must hold that
				
					0 &lt;= k &lt;= n &lt;= m,
				
				and Dorgql will panic otherwise.
				
				On entry, the (n-k+i)-th column of A must contain the vector which defines
				the elementary reflector H_i, for i=0,...,k-1, and tau[i] must contain its
				scalar factor. On return, a contains the m×n matrix Q.
				
				tau must have length at least k, and Dorgql will panic otherwise.
				
				work must have length at least max(1,lwork), and lwork must be at least
				max(1,n), otherwise Dorgql will panic. For optimum performance lwork must
				be a sufficiently large multiple of n.
				
				If lwork == -1, instead of computing Dorgql the optimal work length is stored
				into work[0].
				
				Dorgql is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dorgqr"><label for="Implementation-fold-method-Dorgqr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorgqr.go.html#line-32">Dorgqr</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dorgqr-docs' class="fold-docs">
<span class="md-text">				Dorgqr generates an m×n matrix Q with orthonormal columns defined by the
				product of elementary reflectors
				
					Q = H_0 * H_1 * ... * H_{k-1}
				
				as computed by Dgeqrf.
				Dorgqr is the blocked version of Dorg2r that makes greater use of level-3 BLAS
				routines.
				
				The length of tau must be at least k, and the length of work must be at least n.
				It also must be that 0 &lt;= k &lt;= n and 0 &lt;= n &lt;= m.
				
				work is temporary storage, and lwork specifies the usable memory length. At
				minimum, lwork &gt;= n, and the amount of blocking is limited by the usable
				length. If lwork == -1, instead of computing Dorgqr the optimal work length
				is stored into work[0].
				
				Dorgqr will panic if the conditions on input values are not met.
				
				Dorgqr is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dorgr2"><label for="Implementation-fold-method-Dorgr2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorgr2.go.html#line-34">Dorgr2</a>(m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dorgr2-docs' class="fold-docs">
<span class="md-text">				Dorgr2 generates an m×n real matrix Q with orthonormal rows, which is defined
				as the last m rows of a product of k elementary reflectors of order n
				
					Q = H_0 * H_1 * ... * H_{k-1}
				
				as returned by Dgerqf.
				
				On entry, the (m-k+i)-th row of A must contain the vector which defines the
				elementary reflector H_i, for i = 0,1,...,k, as returned by Dgerqf. On
				return, A will contain the m×n matrix Q.
				
				The i-th element of tau must contain the scalar factor of the elementary
				reflector H_i, as returned by Dgerqf.
				
				It must hold that
				
					n &gt;= m &gt;= k &gt;= 0,
				
				the length of tau must be k and the length of work must be m, otherwise
				Dorgr2 will panic.
				
				Dorgr2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dorgtr"><label for="Implementation-fold-method-Dorgtr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorgtr.go.html#line-29">Dorgtr</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dorgtr-docs' class="fold-docs">
<span class="md-text">				Dorgtr generates a real orthogonal matrix Q which is defined as the product
				of n-1 elementary reflectors of order n as returned by Dsytrd.
				
				The construction of Q depends on the value of uplo:
				
					Q = H_{n-1} * ... * H_1 * H_0  if uplo == blas.Upper
					Q = H_0 * H_1 * ... * H_{n-1}  if uplo == blas.Lower
				
				where H_i is constructed from the elementary reflectors as computed by Dsytrd.
				See the documentation for Dsytrd for more information.
				
				tau must have length at least n-1, and Dorgtr will panic otherwise.
				
				work is temporary storage, and lwork specifies the usable memory length. At
				minimum, lwork &gt;= max(1,n-1), and Dorgtr will panic otherwise. The amount of blocking
				is limited by the usable length.
				If lwork == -1, instead of computing Dorgtr the optimal work length is stored
				into work[0].
				
				Dorgtr is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dorm2r"><label for="Implementation-fold-method-Dorm2r">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorm2r.go.html#line-27">Dorm2r</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dorm2r-docs' class="fold-docs">
<span class="md-text">				Dorm2r multiplies a general matrix C by an orthogonal matrix from a QR factorization
				determined by Dgeqrf.
				
					C = Q * C   if side == blas.Left and trans == blas.NoTrans
					C = Qᵀ * C  if side == blas.Left and trans == blas.Trans
					C = C * Q   if side == blas.Right and trans == blas.NoTrans
					C = C * Qᵀ  if side == blas.Right and trans == blas.Trans
				
				If side == blas.Left, a is a matrix of size m×k, and if side == blas.Right
				a is of size n×k.
				
				tau contains the Householder factors and is of length at least k and this function
				will panic otherwise.
				
				work is temporary storage of length at least n if side == blas.Left
				and at least m if side == blas.Right and this function will panic otherwise.
				
				Dorm2r is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dormbr"><label for="Implementation-fold-method-Dormbr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dormbr.go.html#line-49">Dormbr</a>(vect <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-ApplyOrtho">ApplyOrtho</a>, side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dormbr-docs' class="fold-docs">
<span class="md-text">				Dormbr applies a multiplicative update to the matrix C based on a
				decomposition computed by Dgebrd.
				
				Dormbr overwrites the m×n matrix C with
				
					Q * C   if vect == lapack.ApplyQ, side == blas.Left, and trans == blas.NoTrans
					C * Q   if vect == lapack.ApplyQ, side == blas.Right, and trans == blas.NoTrans
					Qᵀ * C  if vect == lapack.ApplyQ, side == blas.Left, and trans == blas.Trans
					C * Qᵀ  if vect == lapack.ApplyQ, side == blas.Right, and trans == blas.Trans
				
					P * C   if vect == lapack.ApplyP, side == blas.Left, and trans == blas.NoTrans
					C * P   if vect == lapack.ApplyP, side == blas.Right, and trans == blas.NoTrans
					Pᵀ * C  if vect == lapack.ApplyP, side == blas.Left, and trans == blas.Trans
					C * Pᵀ  if vect == lapack.ApplyP, side == blas.Right, and trans == blas.Trans
				
				where P and Q are the orthogonal matrices determined by Dgebrd when reducing
				a matrix A to bidiagonal form: A = Q * B * Pᵀ. See Dgebrd for the
				definitions of Q and P.
				
				If vect == lapack.ApplyQ, A is assumed to have been an nq×k matrix, while if
				vect == lapack.ApplyP, A is assumed to have been a k×nq matrix. nq = m if
				side == blas.Left, while nq = n if side == blas.Right.
				
				tau must have length min(nq,k), and Dormbr will panic otherwise. tau contains
				the elementary reflectors to construct Q or P depending on the value of
				vect.
				
				work must have length at least max(1,lwork), and lwork must be either -1 or
				at least max(1,n) if side == blas.Left, and at least max(1,m) if side ==
				blas.Right. For optimum performance lwork should be at least n*nb if side ==
				blas.Left, and at least m*nb if side == blas.Right, where nb is the optimal
				block size. On return, work[0] will contain the optimal value of lwork.
				
				If lwork == -1, the function only calculates the optimal value of lwork and
				returns it in work[0].
				
				Dormbr is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dormhr"><label for="Implementation-fold-method-Dormhr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dormhr.go.html#line-57">Dormhr</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, ilo, ihi <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dormhr-docs' class="fold-docs">
<span class="md-text">				Dormhr multiplies an m×n general matrix C with an nq×nq orthogonal matrix Q
				
					Q * C   if side == blas.Left  and trans == blas.NoTrans,
					Qᵀ * C  if side == blas.Left  and trans == blas.Trans,
					C * Q   if side == blas.Right and trans == blas.NoTrans,
					C * Qᵀ  if side == blas.Right and trans == blas.Trans,
				
				where nq == m if side == blas.Left and nq == n if side == blas.Right.
				
				Q is defined implicitly as the product of ihi-ilo elementary reflectors, as
				returned by Dgehrd:
				
					Q = H_{ilo} H_{ilo+1} ... H_{ihi-1}.
				
				Q is equal to the identity matrix except in the submatrix
				Q[ilo+1:ihi+1,ilo+1:ihi+1].
				
				ilo and ihi must have the same values as in the previous call of Dgehrd. It
				must hold that
				
					0 &lt;= ilo &lt;= ihi &lt; m   if m &gt; 0 and side == blas.Left,
					ilo = 0 and ihi = -1  if m = 0 and side == blas.Left,
					0 &lt;= ilo &lt;= ihi &lt; n   if n &gt; 0 and side == blas.Right,
					ilo = 0 and ihi = -1  if n = 0 and side == blas.Right.
				
				a and lda represent an m×m matrix if side == blas.Left and an n×n matrix if
				side == blas.Right. The matrix contains vectors which define the elementary
				reflectors, as returned by Dgehrd.
				
				tau contains the scalar factors of the elementary reflectors, as returned by
				Dgehrd. tau must have length m-1 if side == blas.Left and n-1 if side ==
				blas.Right.
				
				c and ldc represent the m×n matrix C. On return, c is overwritten by the
				product with Q.
				
				work must have length at least max(1,lwork), and lwork must be at least
				max(1,n), if side == blas.Left, and max(1,m), if side == blas.Right. For
				optimum performance lwork should be at least n*nb if side == blas.Left and
				m*nb if side == blas.Right, where nb is the optimal block size. On return,
				work[0] will contain the optimal value of lwork.
				
				If lwork == -1, instead of performing Dormhr, only the optimal value of lwork
				will be stored in work[0].
				
				If any requirement on input sizes is not met, Dormhr will panic.
				
				Dormhr is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dorml2"><label for="Implementation-fold-method-Dorml2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dorml2.go.html#line-27">Dorml2</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dorml2-docs' class="fold-docs">
<span class="md-text">				Dorml2 multiplies a general matrix C by an orthogonal matrix from an LQ factorization
				determined by Dgelqf.
				
					C = Q * C   if side == blas.Left and trans == blas.NoTrans
					C = Qᵀ * C  if side == blas.Left and trans == blas.Trans
					C = C * Q   if side == blas.Right and trans == blas.NoTrans
					C = C * Qᵀ  if side == blas.Right and trans == blas.Trans
				
				If side == blas.Left, a is a matrix of side k×m, and if side == blas.Right
				a is of size k×n.
				
				tau contains the Householder factors and is of length at least k and this function will
				panic otherwise.
				
				work is temporary storage of length at least n if side == blas.Left
				and at least m if side == blas.Right and this function will panic otherwise.
				
				Dorml2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dormlq"><label for="Implementation-fold-method-Dormlq">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dormlq.go.html#line-32">Dormlq</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dormlq-docs' class="fold-docs">
<span class="md-text">				Dormlq multiplies the matrix C by the orthogonal matrix Q defined by the
				slices a and tau. A and tau are as returned from Dgelqf.
				
					C = Q * C   if side == blas.Left and trans == blas.NoTrans
					C = Qᵀ * C  if side == blas.Left and trans == blas.Trans
					C = C * Q   if side == blas.Right and trans == blas.NoTrans
					C = C * Qᵀ  if side == blas.Right and trans == blas.Trans
				
				If side == blas.Left, A is a matrix of side k×m, and if side == blas.Right
				A is of size k×n. This uses a blocked algorithm.
				
				work is temporary storage, and lwork specifies the usable memory length.
				At minimum, lwork &gt;= m if side == blas.Left and lwork &gt;= n if side == blas.Right,
				and this function will panic otherwise.
				Dormlq uses a block algorithm, but the block size is limited
				by the temporary space available. If lwork == -1, instead of performing Dormlq,
				the optimal work length will be stored into work[0].
				
				tau contains the Householder scales and must have length at least k, and
				this function will panic otherwise.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dormqr"><label for="Implementation-fold-method-Dormqr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dormqr.go.html#line-42">Dormqr</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dormqr-docs' class="fold-docs">
<span class="md-text">				Dormqr multiplies an m×n matrix C by an orthogonal matrix Q as
				
					C = Q * C   if side == blas.Left  and trans == blas.NoTrans,
					C = Qᵀ * C  if side == blas.Left  and trans == blas.Trans,
					C = C * Q   if side == blas.Right and trans == blas.NoTrans,
					C = C * Qᵀ  if side == blas.Right and trans == blas.Trans,
				
				where Q is defined as the product of k elementary reflectors
				
					Q = H_0 * H_1 * ... * H_{k-1}.
				
				If side == blas.Left, A is an m×k matrix and 0 &lt;= k &lt;= m.
				If side == blas.Right, A is an n×k matrix and 0 &lt;= k &lt;= n.
				The ith column of A contains the vector which defines the elementary
				reflector H_i and tau[i] contains its scalar factor. tau must have length k
				and Dormqr will panic otherwise. Dgeqrf returns A and tau in the required
				form.
				
				work must have length at least max(1,lwork), and lwork must be at least n if
				side == blas.Left and at least m if side == blas.Right, otherwise Dormqr will
				panic.
				
				work is temporary storage, and lwork specifies the usable memory length. At
				minimum, lwork &gt;= m if side == blas.Left and lwork &gt;= n if side ==
				blas.Right, and this function will panic otherwise. Larger values of lwork
				will generally give better performance. On return, work[0] will contain the
				optimal value of lwork.
				
				If lwork is -1, instead of performing Dormqr, the optimal workspace size will
				be stored into work[0].</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dormr2"><label for="Implementation-fold-method-Dormr2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dormr2.go.html#line-27">Dormr2</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, m, n, k <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, tau, c []<a href="../../../../builtin.html#name-float64">float64</a>, ldc <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dormr2-docs' class="fold-docs">
<span class="md-text">				Dormr2 multiplies a general matrix C by an orthogonal matrix from a RQ factorization
				determined by Dgerqf.
				
					C = Q * C   if side == blas.Left and trans == blas.NoTrans
					C = Qᵀ * C  if side == blas.Left and trans == blas.Trans
					C = C * Q   if side == blas.Right and trans == blas.NoTrans
					C = C * Qᵀ  if side == blas.Right and trans == blas.Trans
				
				If side == blas.Left, a is a matrix of size k×m, and if side == blas.Right
				a is of size k×n.
				
				tau contains the Householder factors and is of length at least k and this function
				will panic otherwise.
				
				work is temporary storage of length at least n if side == blas.Left
				and at least m if side == blas.Right and this function will panic otherwise.
				
				Dormr2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dpbcon"><label for="Implementation-fold-method-Dpbcon">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpbcon.go.html#line-28">Dpbcon</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n, kd <a href="../../../../builtin.html#name-int">int</a>, ab []<a href="../../../../builtin.html#name-float64">float64</a>, ldab <a href="../../../../builtin.html#name-int">int</a>, anorm <a href="../../../../builtin.html#name-float64">float64</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, iwork []<a href="../../../../builtin.html#name-int">int</a>) (rcond <a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dpbcon-docs' class="fold-docs">
<span class="md-text">				Dpbcon returns an estimate of the reciprocal of the condition number (in the
				1-norm) of an n×n symmetric positive definite band matrix using the Cholesky
				factorization
				
					A = Uᵀ*U  if uplo == blas.Upper
					A = L*Lᵀ  if uplo == blas.Lower
				
				computed by Dpbtrf. The estimate is obtained for norm(inv(A)), and the
				reciprocal of the condition number is computed as
				
					rcond = 1 / (anorm * norm(inv(A))).
				
				The length of work must be at least 3*n and the length of iwork must be at
				least n.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dpbtf2"><label for="Implementation-fold-method-Dpbtf2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpbtf2.go.html#line-52">Dpbtf2</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n, kd <a href="../../../../builtin.html#name-int">int</a>, ab []<a href="../../../../builtin.html#name-float64">float64</a>, ldab <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dpbtf2-docs' class="fold-docs">
<span class="md-text">				Dpbtf2 computes the Cholesky factorization of a symmetric positive banded
				matrix ab. The matrix ab is n×n with kd diagonal bands. The Cholesky
				factorization computed is
				
					A = Uᵀ * U  if ul == blas.Upper
					A = L * Lᵀ  if ul == blas.Lower
				
				ul also specifies the storage of ab. If ul == blas.Upper, then
				ab is stored as an upper-triangular banded matrix with kd super-diagonals,
				and if ul == blas.Lower, ab is stored as a lower-triangular banded matrix
				with kd sub-diagonals. On exit, the banded matrix U or L is stored in-place
				into ab depending on the value of ul. Dpbtf2 returns whether the factorization
				was successfully completed.
				
				The band storage scheme is illustrated below when n = 6, and kd = 2.
				The resulting Cholesky decomposition is stored in the same elements as the
				input band matrix (a11 becomes u11 or l11, etc.).
				
					ul = blas.Upper
					a11 a12 a13
					a22 a23 a24
					a33 a34 a35
					a44 a45 a46
					a55 a56  *
					a66  *   *
				
					ul = blas.Lower
					 *   *  a11
					 *  a21 a22
					a31 a32 a33
					a42 a43 a44
					a53 a54 a55
					a64 a65 a66
				
				Dpbtf2 is the unblocked version of the algorithm, see Dpbtrf for the blocked
				version.
				
				Dpbtf2 is an internal routine, exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dpbtrf"><label for="Implementation-fold-method-Dpbtrf">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpbtrf.go.html#line-41">Dpbtrf</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n, kd <a href="../../../../builtin.html#name-int">int</a>, ab []<a href="../../../../builtin.html#name-float64">float64</a>, ldab <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dpbtrf-docs' class="fold-docs">
<span class="md-text">				Dpbtrf computes the Cholesky factorization of an n×n symmetric positive
				definite band matrix
				
					A = Uᵀ * U  if uplo == blas.Upper
					A = L * Lᵀ  if uplo == blas.Lower
				
				where U is an upper triangular band matrix and L is lower triangular. kd is
				the number of super- or sub-diagonals of A.
				
				The band storage scheme is illustrated below when n = 6 and kd = 2. Elements
				marked * are not used by the function.
				
					uplo == blas.Upper
					On entry:         On return:
					 a00  a01  a02     u00  u01  u02
					 a11  a12  a13     u11  u12  u13
					 a22  a23  a24     u22  u23  u24
					 a33  a34  a35     u33  u34  u35
					 a44  a45   *      u44  u45   *
					 a55   *    *      u55   *    *
				
					uplo == blas.Lower
					On entry:         On return:
					  *    *   a00       *    *   l00
					  *   a10  a11       *   l10  l11
					 a20  a21  a22      l20  l21  l22
					 a31  a32  a33      l31  l32  l33
					 a42  a43  a44      l42  l43  l44
					 a53  a54  a55      l53  l54  l55</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dpbtrs"><label for="Implementation-fold-method-Dpbtrs">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpbtrs.go.html#line-23">Dpbtrs</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n, kd, nrhs <a href="../../../../builtin.html#name-int">int</a>, ab []<a href="../../../../builtin.html#name-float64">float64</a>, ldab <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dpbtrs-docs' class="fold-docs">
<span class="md-text">				Dpbtrs solves a system of linear equations A*X = B with an n×n symmetric
				positive definite band matrix A using the Cholesky factorization
				
					A = Uᵀ * U  if uplo == blas.Upper
					A = L * Lᵀ  if uplo == blas.Lower
				
				computed by Dpbtrf. kd is the number of super- or sub-diagonals of A. See the
				documentation for Dpbtrf for a description of the band storage format of A.
				
				On entry, b contains the n×nrhs right hand side matrix B. On return, it is
				overwritten with the solution matrix X.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dpocon"><label for="Implementation-fold-method-Dpocon">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpocon.go.html#line-23">Dpocon</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, anorm <a href="../../../../builtin.html#name-float64">float64</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, iwork []<a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dpocon-docs' class="fold-docs">
<span class="md-text">				Dpocon estimates the reciprocal of the condition number of a positive-definite
				matrix A given the Cholesky decomposition of A. The condition number computed
				is based on the 1-norm and the ∞-norm.
				
				anorm is the 1-norm and the ∞-norm of the original matrix A.
				
				work is a temporary data slice of length at least 3*n and Dpocon will panic otherwise.
				
				iwork is a temporary data slice of length at least n and Dpocon will panic otherwise.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dpotf2"><label for="Implementation-fold-method-Dpotf2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpotf2.go.html#line-21">Dpotf2</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dpotf2-docs' class="fold-docs">
<span class="md-text">				Dpotf2 computes the Cholesky decomposition of the symmetric positive definite
				matrix a. If ul == blas.Upper, then a is stored as an upper-triangular matrix,
				and a = Uᵀ U is stored in place into a. If ul == blas.Lower, then a = L Lᵀ
				is computed and stored in-place into a. If a is not positive definite, false
				is returned. This is the unblocked version of the algorithm.
				
				Dpotf2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dpotrf"><label for="Implementation-fold-method-Dpotrf">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpotrf.go.html#line-17">Dpotrf</a>(ul <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dpotrf-docs' class="fold-docs">
<span class="md-text">				Dpotrf computes the Cholesky decomposition of the symmetric positive definite
				matrix a. If ul == blas.Upper, then a is stored as an upper-triangular matrix,
				and a = Uᵀ U is stored in place into a. If ul == blas.Lower, then a = L Lᵀ
				is computed and stored in-place into a. If a is not positive definite, false
				is returned. This is the blocked version of the algorithm.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dpotri"><label for="Implementation-fold-method-Dpotri">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpotri.go.html#line-16">Dpotri</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dpotri-docs' class="fold-docs">
<span class="md-text">				Dpotri computes the inverse of a real symmetric positive definite matrix A
				using its Cholesky factorization.
				
				On entry, a contains the triangular factor U or L from the Cholesky
				factorization A = Uᵀ*U or A = L*Lᵀ, as computed by Dpotrf.
				On return, a contains the upper or lower triangle of the (symmetric)
				inverse of A, overwriting the input factor U or L.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dpotrs"><label for="Implementation-fold-method-Dpotrs">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpotrs.go.html#line-21">Dpotrs</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n, nrhs <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dpotrs-docs' class="fold-docs">
<span class="md-text">				Dpotrs solves a system of n linear equations A*X = B where A is an n×n
				symmetric positive definite matrix and B is an n×nrhs matrix. The matrix A is
				represented by its Cholesky factorization
				
					A = Uᵀ*U  if uplo == blas.Upper
					A = L*Lᵀ  if uplo == blas.Lower
				
				as computed by Dpotrf. On entry, B contains the right-hand side matrix B, on
				return it contains the solution matrix X.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dpstf2"><label for="Implementation-fold-method-Dpstf2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpstf2.go.html#line-41">Dpstf2</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, piv []<a href="../../../../builtin.html#name-int">int</a>, tol <a href="../../../../builtin.html#name-float64">float64</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) (rank <a href="../../../../builtin.html#name-int">int</a>, ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dpstf2-docs' class="fold-docs">
<span class="md-text">				Dpstf2 computes the Cholesky factorization with complete pivoting of an n×n
				symmetric positive semidefinite matrix A.
				
				The factorization has the form
				
					Pᵀ * A * P = Uᵀ * U ,  if uplo = blas.Upper,
					Pᵀ * A * P = L  * Lᵀ,  if uplo = blas.Lower,
				
				where U is an upper triangular matrix, L is lower triangular, and P is a
				permutation matrix.
				
				tol is a user-defined tolerance. The algorithm terminates if the pivot is
				less than or equal to tol. If tol is negative, then n*eps*max(A[k,k]) will be
				used instead.
				
				On return, A contains the factor U or L from the Cholesky factorization and
				piv contains P stored such that P[piv[k],k] = 1.
				
				Dpstf2 returns the computed rank of A and whether the factorization can be
				used to solve a system. Dpstf2 does not attempt to check that A is positive
				semi-definite, so if ok is false, the matrix A is either rank deficient or is
				not positive semidefinite.
				
				The length of piv must be n and the length of work must be at least 2*n,
				otherwise Dpstf2 will panic.
				
				Dpstf2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dpstrf"><label for="Implementation-fold-method-Dpstrf">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dpstrf.go.html#line-41">Dpstrf</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, piv []<a href="../../../../builtin.html#name-int">int</a>, tol <a href="../../../../builtin.html#name-float64">float64</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) (rank <a href="../../../../builtin.html#name-int">int</a>, ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dpstrf-docs' class="fold-docs">
<span class="md-text">				Dpstrf computes the Cholesky factorization with complete pivoting of an n×n
				symmetric positive semidefinite matrix A.
				
				The factorization has the form
				
					Pᵀ * A * P = Uᵀ * U ,  if uplo = blas.Upper,
					Pᵀ * A * P = L  * Lᵀ,  if uplo = blas.Lower,
				
				where U is an upper triangular matrix, L is lower triangular, and P is a
				permutation matrix.
				
				tol is a user-defined tolerance. The algorithm terminates if the pivot is
				less than or equal to tol. If tol is negative, then n*eps*max(A[k,k]) will be
				used instead.
				
				On return, A contains the factor U or L from the Cholesky factorization and
				piv contains P stored such that P[piv[k],k] = 1.
				
				Dpstrf returns the computed rank of A and whether the factorization can be
				used to solve a system. Dpstrf does not attempt to check that A is positive
				semi-definite, so if ok is false, the matrix A is either rank deficient or is
				not positive semidefinite.
				
				The length of piv must be n and the length of work must be at least 2*n,
				otherwise Dpstrf will panic.
				
				Dpstrf is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Drscl"><label for="Implementation-fold-method-Drscl">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/drscl.go.html#line-17">Drscl</a>(n <a href="../../../../builtin.html#name-int">int</a>, a <a href="../../../../builtin.html#name-float64">float64</a>, x []<a href="../../../../builtin.html#name-float64">float64</a>, incX <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Drscl-docs' class="fold-docs">
<span class="md-text">				Drscl multiplies the vector x by 1/a being careful to avoid overflow or
				underflow where possible.
				
				Drscl is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsteqr"><label for="Implementation-fold-method-Dsteqr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dsteqr.go.html#line-39">Dsteqr</a>(compz <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-EVComp">EVComp</a>, n <a href="../../../../builtin.html#name-int">int</a>, d, e, z []<a href="../../../../builtin.html#name-float64">float64</a>, ldz <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dsteqr-docs' class="fold-docs">
<span class="md-text">				Dsteqr computes the eigenvalues and optionally the eigenvectors of a symmetric
				tridiagonal matrix using the implicit QL or QR method. The eigenvectors of a
				full or band symmetric matrix can also be found if Dsytrd, Dsptrd, or Dsbtrd
				have been used to reduce this matrix to tridiagonal form.
				
				d, on entry, contains the diagonal elements of the tridiagonal matrix. On exit,
				d contains the eigenvalues in ascending order. d must have length n and
				Dsteqr will panic otherwise.
				
				e, on entry, contains the off-diagonal elements of the tridiagonal matrix on
				entry, and is overwritten during the call to Dsteqr. e must have length n-1 and
				Dsteqr will panic otherwise.
				
				z, on entry, contains the n×n orthogonal matrix used in the reduction to
				tridiagonal form if compz == lapack.EVOrig. On exit, if
				compz == lapack.EVOrig, z contains the orthonormal eigenvectors of the
				original symmetric matrix, and if compz == lapack.EVTridiag, z contains the
				orthonormal eigenvectors of the symmetric tridiagonal matrix. z is not used
				if compz == lapack.EVCompNone.
				
				work must have length at least max(1, 2*n-2) if the eigenvectors are computed,
				and Dsteqr will panic otherwise.
				
				Dsteqr is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsterf"><label for="Implementation-fold-method-Dsterf">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dsterf.go.html#line-25">Dsterf</a>(n <a href="../../../../builtin.html#name-int">int</a>, d, e []<a href="../../../../builtin.html#name-float64">float64</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dsterf-docs' class="fold-docs">
<span class="md-text">				Dsterf computes all eigenvalues of a symmetric tridiagonal matrix using the
				Pal-Walker-Kahan variant of the QL or QR algorithm.
				
				d contains the diagonal elements of the tridiagonal matrix on entry, and
				contains the eigenvalues in ascending order on exit. d must have length at
				least n, or Dsterf will panic.
				
				e contains the off-diagonal elements of the tridiagonal matrix on entry, and is
				overwritten during the call to Dsterf. e must have length of at least n-1 or
				Dsterf will panic.
				
				Dsterf is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsyev"><label for="Implementation-fold-method-Dsyev">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dsyev.go.html#line-30">Dsyev</a>(jobz <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-EVJob">EVJob</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, w, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dsyev-docs' class="fold-docs">
<span class="md-text">				Dsyev computes all eigenvalues and, optionally, the eigenvectors of a real
				symmetric matrix A.
				
				w contains the eigenvalues in ascending order upon return. w must have length
				at least n, and Dsyev will panic otherwise.
				
				On entry, a contains the elements of the symmetric matrix A in the triangular
				portion specified by uplo. If jobz == lapack.EVCompute, a contains the
				orthonormal eigenvectors of A on exit, otherwise jobz must be lapack.EVNone
				and on exit the specified triangular region is overwritten.
				
				work is temporary storage, and lwork specifies the usable memory length. At minimum,
				lwork &gt;= 3*n-1, and Dsyev will panic otherwise. The amount of blocking is
				limited by the usable length. If lwork == -1, instead of computing Dsyev the
				optimal work length is stored into work[0].</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsytd2"><label for="Implementation-fold-method-Dsytd2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dsytd2.go.html#line-62">Dsytd2</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, d, e, tau []<a href="../../../../builtin.html#name-float64">float64</a>)</label><span id='Implementation-fold-method-Dsytd2-docs' class="fold-docs">
<span class="md-text">				Dsytd2 reduces a symmetric n×n matrix A to symmetric tridiagonal form T by
				an orthogonal similarity transformation
				
					Qᵀ * A * Q = T
				
				On entry, the matrix is contained in the specified triangle of a. On exit,
				if uplo == blas.Upper, the diagonal and first super-diagonal of a are
				overwritten with the elements of T. The elements above the first super-diagonal
				are overwritten with the elementary reflectors that are used with
				the elements written to tau in order to construct Q. If uplo == blas.Lower,
				the elements are written in the lower triangular region.
				
				d must have length at least n. e and tau must have length at least n-1. Dsytd2
				will panic if these sizes are not met.
				
				Q is represented as a product of elementary reflectors.
				If uplo == blas.Upper
				
					Q = H_{n-2} * ... * H_1 * H_0
				
				and if uplo == blas.Lower
				
					Q = H_0 * H_1 * ... * H_{n-2}
				
				where
				
					H_i = I - tau * v * vᵀ
				
				where tau is stored in tau[i], and v is stored in a.
				
				If uplo == blas.Upper, v[0:i-1] is stored in A[0:i-1,i+1], v[i] = 1, and
				v[i+1:] = 0. The elements of a are
				
					[ d   e  v2  v3  v4]
					[     d   e  v3  v4]
					[         d   e  v4]
					[             d   e]
					[                 d]
				
				If uplo == blas.Lower, v[0:i+1] = 0, v[i+1] = 1, and v[i+2:] is stored in
				A[i+2:n,i].
				The elements of a are
				
					[ d                ]
					[ e   d            ]
					[v1   e   d        ]
					[v1  v2   e   d    ]
					[v1  v2  v3   e   d]
				
				Dsytd2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dsytrd"><label for="Implementation-fold-method-Dsytrd">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dsytrd.go.html#line-69">Dsytrd</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, d, e, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dsytrd-docs' class="fold-docs">
<span class="md-text">				Dsytrd reduces a symmetric n×n matrix A to symmetric tridiagonal form by an
				orthogonal similarity transformation
				
					Qᵀ * A * Q = T
				
				where Q is an orthonormal matrix and T is symmetric and tridiagonal.
				
				On entry, a contains the elements of the input matrix in the triangle specified
				by uplo. On exit, the diagonal and sub/super-diagonal are overwritten by the
				corresponding elements of the tridiagonal matrix T. The remaining elements in
				the triangle, along with the array tau, contain the data to construct Q as
				the product of elementary reflectors.
				
				If uplo == blas.Upper, Q is constructed with
				
					Q = H_{n-2} * ... * H_1 * H_0
				
				where
				
					H_i = I - tau_i * v * vᵀ
				
				v is constructed as v[i+1:n] = 0, v[i] = 1, v[0:i-1] is stored in A[0:i-1, i+1].
				The elements of A are
				
					[ d   e  v1  v2  v3]
					[     d   e  v2  v3]
					[         d   e  v3]
					[             d   e]
					[                 e]
				
				If uplo == blas.Lower, Q is constructed with
				
					Q = H_0 * H_1 * ... * H_{n-2}
				
				where
				
					H_i = I - tau_i * v * vᵀ
				
				v is constructed as v[0:i+1] = 0, v[i+1] = 1, v[i+2:n] is stored in A[i+2:n, i].
				The elements of A are
				
					[ d                ]
					[ e   d            ]
					[v0   e   d        ]
					[v0  v1   e   d    ]
					[v0  v1  v2   e   d]
				
				d must have length n, and e and tau must have length n-1. Dsytrd will panic if
				these conditions are not met.
				
				work is temporary storage, and lwork specifies the usable memory length. At minimum,
				lwork &gt;= 1, and Dsytrd will panic otherwise. The amount of blocking is
				limited by the usable length.
				If lwork == -1, instead of computing Dsytrd the optimal work length is stored
				into work[0].
				
				Dsytrd is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtbtrs"><label for="Implementation-fold-method-Dtbtrs">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtbtrs.go.html#line-22">Dtbtrs</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n, kd, nrhs <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dtbtrs-docs' class="fold-docs">
<span class="md-text">				Dtbtrs solves a triangular system of the form
				
					A * X = B   if trans == blas.NoTrans
					Aᵀ * X = B  if trans == blas.Trans or blas.ConjTrans
				
				where A is an n×n triangular band matrix with kd super- or subdiagonals, and
				B is an n×nrhs matrix.
				
				Dtbtrs returns whether A is non-singular. If A is singular, no solution X is
				computed.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtgsja"><label for="Implementation-fold-method-Dtgsja">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtgsja.go.html#line-177">Dtgsja</a>(jobU, jobV, jobQ <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-GSVDJob">GSVDJob</a>, m, p, n, k, l <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>, tola, tolb <a href="../../../../builtin.html#name-float64">float64</a>, alpha, beta, u []<a href="../../../../builtin.html#name-float64">float64</a>, ldu <a href="../../../../builtin.html#name-int">int</a>, v []<a href="../../../../builtin.html#name-float64">float64</a>, ldv <a href="../../../../builtin.html#name-int">int</a>, q []<a href="../../../../builtin.html#name-float64">float64</a>, ldq <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) (cycles <a href="../../../../builtin.html#name-int">int</a>, ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dtgsja-docs' class="fold-docs">
<span class="md-text">				Dtgsja computes the generalized singular value decomposition (GSVD)
				of two real upper triangular or trapezoidal matrices A and B.
				
				A and B have the following forms, which may be obtained by the
				preprocessing subroutine Dggsvp from a general m×n matrix A and p×n
				matrix B:
				
					          n-k-l  k    l
					A =    k [  0   A12  A13 ] if m-k-l &gt;= 0;
					       l [  0    0   A23 ]
					   m-k-l [  0    0    0  ]
				
					          n-k-l  k    l
					A =    k [  0   A12  A13 ] if m-k-l &lt; 0;
					     m-k [  0    0   A23 ]
				
					          n-k-l  k    l
					B =    l [  0    0   B13 ]
					     p-l [  0    0    0  ]
				
				where the k×k matrix A12 and l×l matrix B13 are non-singular
				upper triangular. A23 is l×l upper triangular if m-k-l &gt;= 0,
				otherwise A23 is (m-k)×l upper trapezoidal.
				
				On exit,
				
					Uᵀ*A*Q = D1*[ 0 R ], Vᵀ*B*Q = D2*[ 0 R ],
				
				where U, V and Q are orthogonal matrices.
				R is a non-singular upper triangular matrix, and D1 and D2 are
				diagonal matrices, which are of the following structures:
				
				If m-k-l &gt;= 0,
				
					                  k  l
					     D1 =     k [ I  0 ]
					              l [ 0  C ]
					          m-k-l [ 0  0 ]
				
					                k  l
					     D2 = l   [ 0  S ]
					          p-l [ 0  0 ]
				
					             n-k-l  k    l
					[ 0 R ] = k [  0   R11  R12 ] k
					          l [  0    0   R22 ] l
				
				where
				
					C = diag( alpha_k, ... , alpha_{k+l} ),
					S = diag( beta_k,  ... , beta_{k+l} ),
					C^2 + S^2 = I.
				
				R is stored in
				
					A[0:k+l, n-k-l:n]
				
				on exit.
				
				If m-k-l &lt; 0,
				
					               k m-k k+l-m
					    D1 =   k [ I  0    0  ]
					         m-k [ 0  C    0  ]
				
					                 k m-k k+l-m
					    D2 =   m-k [ 0  S    0  ]
					         k+l-m [ 0  0    I  ]
					           p-l [ 0  0    0  ]
				
					               n-k-l  k   m-k  k+l-m
					[ 0 R ] =    k [ 0    R11  R12  R13 ]
					           m-k [ 0     0   R22  R23 ]
					         k+l-m [ 0     0    0   R33 ]
				
				where
				
					C = diag( alpha_k, ... , alpha_m ),
					S = diag( beta_k,  ... , beta_m ),
					C^2 + S^2 = I.
				
					R = [ R11 R12 R13 ] is stored in A[0:m, n-k-l:n]
					    [  0  R22 R23 ]
				
				and R33 is stored in
				
					B[m-k:l, n+m-k-l:n] on exit.
				
				The computation of the orthogonal transformation matrices U, V or Q
				is optional. These matrices may either be formed explicitly, or they
				may be post-multiplied into input matrices U1, V1, or Q1.
				
				Dtgsja essentially uses a variant of Kogbetliantz algorithm to reduce
				min(l,m-k)×l triangular or trapezoidal matrix A23 and l×l
				matrix B13 to the form:
				
					U1ᵀ*A13*Q1 = C1*R1; V1ᵀ*B13*Q1 = S1*R1,
				
				where U1, V1 and Q1 are orthogonal matrices. C1 and S1 are diagonal
				matrices satisfying
				
					C1^2 + S1^2 = I,
				
				and R1 is an l×l non-singular upper triangular matrix.
				
				jobU, jobV and jobQ are options for computing the orthogonal matrices. The behavior
				is as follows
				
					jobU == lapack.GSVDU        Compute orthogonal matrix U
					jobU == lapack.GSVDUnit     Use unit-initialized matrix
					jobU == lapack.GSVDNone     Do not compute orthogonal matrix.
				
				The behavior is the same for jobV and jobQ with the exception that instead of
				lapack.GSVDU these accept lapack.GSVDV and lapack.GSVDQ respectively.
				The matrices U, V and Q must be m×m, p×p and n×n respectively unless the
				relevant job parameter is lapack.GSVDNone.
				
				k and l specify the sub-blocks in the input matrices A and B:
				
					A23 = A[k:min(k+l,m), n-l:n) and B13 = B[0:l, n-l:n]
				
				of A and B, whose GSVD is going to be computed by Dtgsja.
				
				tola and tolb are the convergence criteria for the Jacobi-Kogbetliantz
				iteration procedure. Generally, they are the same as used in the preprocessing
				step, for example,
				
					tola = max(m, n)*norm(A)*eps,
					tolb = max(p, n)*norm(B)*eps,
				
				where eps is the machine epsilon.
				
				work must have length at least 2*n, otherwise Dtgsja will panic.
				
				alpha and beta must have length n or Dtgsja will panic. On exit, alpha and
				beta contain the generalized singular value pairs of A and B
				
					alpha[0:k] = 1,
					beta[0:k]  = 0,
				
				if m-k-l &gt;= 0,
				
					alpha[k:k+l] = diag(C),
					beta[k:k+l]  = diag(S),
				
				if m-k-l &lt; 0,
				
					alpha[k:m]= C, alpha[m:k+l]= 0
					beta[k:m] = S, beta[m:k+l] = 1.
				
				if k+l &lt; n,
				
					alpha[k+l:n] = 0 and
					beta[k+l:n]  = 0.
				
				On exit, A[n-k:n, 0:min(k+l,m)] contains the triangular matrix R or part of R
				and if necessary, B[m-k:l, n+m-k-l:n] contains a part of R.
				
				Dtgsja returns whether the routine converged and the number of iteration cycles
				that were run.
				
				Dtgsja is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtrcon"><label for="Implementation-fold-method-Dtrcon">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtrcon.go.html#line-21">Dtrcon</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, iwork []<a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Implementation-fold-method-Dtrcon-docs' class="fold-docs">
<span class="md-text">				Dtrcon estimates the reciprocal of the condition number of a triangular matrix A.
				The condition number computed may be based on the 1-norm or the ∞-norm.
				
				work is a temporary data slice of length at least 3*n and Dtrcon will panic otherwise.
				
				iwork is a temporary data slice of length at least n and Dtrcon will panic otherwise.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtrevc3"><label for="Implementation-fold-method-Dtrevc3">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtrevc3.go.html#line-117">Dtrevc3</a>(side <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-EVSide">EVSide</a>, howmny <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-EVHowMany">EVHowMany</a>, selected []<a href="../../../../builtin.html#name-bool">bool</a>, n <a href="../../../../builtin.html#name-int">int</a>, t []<a href="../../../../builtin.html#name-float64">float64</a>, ldt <a href="../../../../builtin.html#name-int">int</a>, vl []<a href="../../../../builtin.html#name-float64">float64</a>, ldvl <a href="../../../../builtin.html#name-int">int</a>, vr []<a href="../../../../builtin.html#name-float64">float64</a>, ldvr <a href="../../../../builtin.html#name-int">int</a>, mm <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) (m <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dtrevc3-docs' class="fold-docs">
<span class="md-text">				Dtrevc3 computes some or all of the right and/or left eigenvectors of an n×n
				upper quasi-triangular matrix T in Schur canonical form. Matrices of this
				type are produced by the Schur factorization of a real general matrix A
				
					A = Q T Qᵀ,
				
				as computed by Dhseqr.
				
				The right eigenvector x of T corresponding to an
				eigenvalue λ is defined by
				
					T x = λ x,
				
				and the left eigenvector y is defined by
				
					yᵀ T = λ yᵀ.
				
				The eigenvalues are read directly from the diagonal blocks of T.
				
				This routine returns the matrices X and/or Y of right and left eigenvectors
				of T, or the products Q*X and/or Q*Y, where Q is an input matrix. If Q is the
				orthogonal factor that reduces a matrix A to Schur form T, then Q*X and Q*Y
				are the matrices of right and left eigenvectors of A.
				
				If side == lapack.EVRight, only right eigenvectors will be computed.
				If side == lapack.EVLeft, only left eigenvectors will be computed.
				If side == lapack.EVBoth, both right and left eigenvectors will be computed.
				For other values of side, Dtrevc3 will panic.
				
				If howmny == lapack.EVAll, all right and/or left eigenvectors will be
				computed.
				If howmny == lapack.EVAllMulQ, all right and/or left eigenvectors will be
				computed and multiplied from left by the matrices in VR and/or VL.
				If howmny == lapack.EVSelected, right and/or left eigenvectors will be
				computed as indicated by selected.
				For other values of howmny, Dtrevc3 will panic.
				
				selected specifies which eigenvectors will be computed. It must have length n
				if howmny == lapack.EVSelected, and it is not referenced otherwise.
				If w_j is a real eigenvalue, the corresponding real eigenvector will be
				computed if selected[j] is true.
				If w_j and w_{j+1} are the real and imaginary parts of a complex eigenvalue,
				the corresponding complex eigenvector is computed if either selected[j] or
				selected[j+1] is true, and on return selected[j] will be set to true and
				selected[j+1] will be set to false.
				
				VL and VR are n×mm matrices. If howmny is lapack.EVAll or
				lapack.AllEVMulQ, mm must be at least n. If howmny is
				lapack.EVSelected, mm must be large enough to store the selected
				eigenvectors. Each selected real eigenvector occupies one column and each
				selected complex eigenvector occupies two columns. If mm is not sufficiently
				large, Dtrevc3 will panic.
				
				On entry, if howmny is lapack.EVAllMulQ, it is assumed that VL (if side
				is lapack.EVLeft or lapack.EVBoth) contains an n×n matrix QL,
				and that VR (if side is lapack.EVRight or lapack.EVBoth) contains
				an n×n matrix QR. QL and QR are typically the orthogonal matrix Q of Schur
				vectors returned by Dhseqr.
				
				On return, if side is lapack.EVLeft or lapack.EVBoth,
				VL will contain:
				
					if howmny == lapack.EVAll,      the matrix Y of left eigenvectors of T,
					if howmny == lapack.EVAllMulQ,  the matrix Q*Y,
					if howmny == lapack.EVSelected, the left eigenvectors of T specified by
					                                selected, stored consecutively in the
					                                columns of VL, in the same order as their
					                                eigenvalues.
				
				VL is not referenced if side == lapack.EVRight.
				
				On return, if side is lapack.EVRight or lapack.EVBoth,
				VR will contain:
				
					if howmny == lapack.EVAll,      the matrix X of right eigenvectors of T,
					if howmny == lapack.EVAllMulQ,  the matrix Q*X,
					if howmny == lapack.EVSelected, the left eigenvectors of T specified by
					                                selected, stored consecutively in the
					                                columns of VR, in the same order as their
					                                eigenvalues.
				
				VR is not referenced if side == lapack.EVLeft.
				
				Complex eigenvectors corresponding to a complex eigenvalue are stored in VL
				and VR in two consecutive columns, the first holding the real part, and the
				second the imaginary part.
				
				Each eigenvector will be normalized so that the element of largest magnitude
				has magnitude 1. Here the magnitude of a complex number (x,y) is taken to be
				|x| + |y|.
				
				work must have length at least lwork and lwork must be at least max(1,3*n),
				otherwise Dtrevc3 will panic. For optimum performance, lwork should be at
				least n+2*n*nb, where nb is the optimal blocksize.
				
				If lwork == -1, instead of performing Dtrevc3, the function only estimates
				the optimal workspace size based on n and stores it into work[0].
				
				Dtrevc3 returns the number of columns in VL and/or VR actually used to store
				the eigenvectors.
				
				Dtrevc3 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtrexc"><label for="Implementation-fold-method-Dtrexc">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtrexc.go.html#line-52">Dtrexc</a>(compq <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-UpdateSchurComp">UpdateSchurComp</a>, n <a href="../../../../builtin.html#name-int">int</a>, t []<a href="../../../../builtin.html#name-float64">float64</a>, ldt <a href="../../../../builtin.html#name-int">int</a>, q []<a href="../../../../builtin.html#name-float64">float64</a>, ldq <a href="../../../../builtin.html#name-int">int</a>, ifst, ilst <a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) (ifstOut, ilstOut <a href="../../../../builtin.html#name-int">int</a>, ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dtrexc-docs' class="fold-docs">
<span class="md-text">				Dtrexc reorders the real Schur factorization of a n×n real matrix
				
					A = Q*T*Qᵀ
				
				so that the diagonal block of T with row index ifst is moved to row ilst.
				
				On entry, T must be in Schur canonical form, that is, block upper triangular
				with 1×1 and 2×2 diagonal blocks; each 2×2 diagonal block has its diagonal
				elements equal and its off-diagonal elements of opposite sign.
				
				On return, T will be reordered by an orthogonal similarity transformation Z
				as Zᵀ*T*Z, and will be again in Schur canonical form.
				
				If compq is lapack.UpdateSchur, on return the matrix Q of Schur vectors will be
				updated by post-multiplying it with Z.
				If compq is lapack.UpdateSchurNone, the matrix Q is not referenced and will not be
				updated.
				For other values of compq Dtrexc will panic.
				
				ifst and ilst specify the reordering of the diagonal blocks of T. The block
				with row index ifst is moved to row ilst, by a sequence of transpositions
				between adjacent blocks.
				
				If ifst points to the second row of a 2×2 block, ifstOut will point to the
				first row, otherwise it will be equal to ifst.
				
				ilstOut will point to the first row of the block in its final position. If ok
				is true, ilstOut may differ from ilst by +1 or -1.
				
				It must hold that
				
					0 &lt;= ifst &lt; n, and  0 &lt;= ilst &lt; n,
				
				otherwise Dtrexc will panic.
				
				If ok is false, two adjacent blocks were too close to swap because the
				problem is very ill-conditioned. T may have been partially reordered, and
				ilstOut will point to the first row of the block at the position to which it
				has been moved.
				
				work must have length at least n, otherwise Dtrexc will panic.
				
				Dtrexc is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtrti2"><label for="Implementation-fold-method-Dtrti2">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtrti2.go.html#line-16">Dtrti2</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Implementation-fold-method-Dtrti2-docs' class="fold-docs">
<span class="md-text">				Dtrti2 computes the inverse of a triangular matrix, storing the result in place
				into a. This is the BLAS level 2 version of the algorithm.
				
				Dtrti2 is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtrtri"><label for="Implementation-fold-method-Dtrtri">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtrtri.go.html#line-18">Dtrtri</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dtrtri-docs' class="fold-docs">
<span class="md-text">				Dtrtri computes the inverse of a triangular matrix, storing the result in place
				into a. This is the BLAS level 3 version of the algorithm which builds upon
				Dtrti2 to operate on matrix blocks instead of only individual columns.
				
				Dtrtri will not perform the inversion if the matrix is singular, and returns
				a boolean indicating whether the inversion was successful.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Dtrtrs"><label for="Implementation-fold-method-Dtrtrs">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dtrtrs.go.html#line-14">Dtrtrs</a>(uplo <a href="../blas.html">blas</a>.<a href="../blas.html#name-Uplo">Uplo</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, diag <a href="../blas.html">blas</a>.<a href="../blas.html#name-Diag">Diag</a>, n, nrhs <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>, b []<a href="../../../../builtin.html#name-float64">float64</a>, ldb <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Implementation-fold-method-Dtrtrs-docs' class="fold-docs">
<span class="md-text">				Dtrtrs solves a triangular system of the form A * X = B or Aᵀ * X = B. Dtrtrs
				returns whether the solve completed successfully. If A is singular, no solve is performed.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Iladlc"><label for="Implementation-fold-method-Iladlc">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/iladlc.go.html#line-11">Iladlc</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></label><span id='Implementation-fold-method-Iladlc-docs' class="fold-docs">
<span class="md-text">				Iladlc scans a matrix for its last non-zero column. Returns -1 if the matrix
				is all zeros.
				
				Iladlc is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Iladlr"><label for="Implementation-fold-method-Iladlr">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/iladlr.go.html#line-11">Iladlr</a>(m, n <a href="../../../../builtin.html#name-int">int</a>, a []<a href="../../../../builtin.html#name-float64">float64</a>, lda <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></label><span id='Implementation-fold-method-Iladlr-docs' class="fold-docs">
<span class="md-text">				Iladlr scans a matrix for its last non-zero row. Returns -1 if the matrix
				is all zeros.
				
				Iladlr is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Ilaenv"><label for="Implementation-fold-method-Ilaenv">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/ilaenv.go.html#line-26">Ilaenv</a>(ispec <a href="../../../../builtin.html#name-int">int</a>, name <a href="../../../../builtin.html#name-string">string</a>, opts <a href="../../../../builtin.html#name-string">string</a>, n1, n2, n3, n4 <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></label><span id='Implementation-fold-method-Ilaenv-docs' class="fold-docs">
<span class="md-text">				Ilaenv returns algorithm tuning parameters for the algorithm given by the
				input string. ispec specifies the parameter to return:
				
					1: The optimal block size for a blocked algorithm.
					2: The minimum block size for a blocked algorithm.
					3: The block size of unprocessed data at which a blocked algorithm should
					   crossover to an unblocked version.
					4: The number of shifts.
					5: The minimum column dimension for blocking to be used.
					6: The crossover point for SVD (to use QR factorization or not).
					7: The number of processors.
					8: The crossover point for multi-shift in QR and QZ methods for non-symmetric eigenvalue problems.
					9: Maximum size of the subproblems in divide-and-conquer algorithms.
					10: ieee infinity and NaN arithmetic can be trusted not to trap.
					11: ieee infinity arithmetic can be trusted not to trap.
					12...16: parameters for Dhseqr and related functions. See Iparmq for more
					         information.
				
				Ilaenv is an internal routine. It is exported for testing purposes.</span>
</span></span><span>
			<input type='checkbox' class="fold" id="Implementation-fold-method-Iparmq"><label for="Implementation-fold-method-Iparmq">( Implementation) <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/iparmq.go.html#line-36">Iparmq</a>(ispec <a href="../../../../builtin.html#name-int">int</a>, name, opts <a href="../../../../builtin.html#name-string">string</a>, n, ilo, ihi, lwork <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></label><span id='Implementation-fold-method-Iparmq-docs' class="fold-docs">
<span class="md-text">				Iparmq returns problem and machine dependent parameters useful for Dhseqr and
				related subroutines for eigenvalue problems.
				
				ispec specifies the parameter to return:
				
					12: Crossover point between Dlahqr and Dlaqr0. Will be at least 11.
					13: Deflation window size.
					14: Nibble crossover point. Determines when to skip a multi-shift QR sweep.
					15: Number of simultaneous shifts in a multishift QR iteration.
					16: Select structured matrix multiply.
				
				For other values of ispec Iparmq will panic.
				
				name is the name of the calling function. name must be in uppercase but this
				is not checked.
				
				opts is not used and exists for future use.
				
				n is the order of the Hessenberg matrix H.
				
				ilo and ihi specify the block [ilo:ihi+1,ilo:ihi+1] that is being processed.
				
				lwork is the amount of workspace available.
				
				Except for ispec input parameters are not checked.
				
				Iparmq is an internal routine. It is exported for testing purposes.</span>
</span></span></span>
		<input type='checkbox' class="fold" id="Implementation-fold-impls"><label for="Implementation-fold-impls">Implements (<i>at least one exported</i>)</label><span id='Implementation-fold-impls-items' class="fold-items"><span>
			 Implementation : gonum.org/v1/gonum/lapack.<a href="../lapack.html#name-Float64">Float64</a></span></span>

</span></div></div>
<div id="exported-functions"><span class="title">Package-Level Functions<span class="title-stat"><i> (total 3, none are exported)</i></span></span>

	<input type='checkbox' class="showhide" id="unexported-functions-showhide"><i><label for="unexported-functions-showhide" class="show-inline">/* 3 unexporteds ... */</label><label for="unexported-functions-showhide" class="hide-inline">/* 3 unexporteds: */</label></i><div class="anchor value-res hidden" id="name-abs"><i>	<span class="nodocs"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..abs^78da4.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html#line-30">abs</a>(a <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></span></i></div><div class="anchor value-res hidden" id="name-max"><i>	<span class="nodocs"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..max^9baf3.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html#line-23">max</a>(a, b <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></span></i></div><div class="anchor value-res hidden" id="name-min"><i>	<span class="nodocs"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..min^1f6fa.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html#line-16">min</a>(a, b <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></span></i></div></div>
<div id="exported-constants"><span class="title">Package-Level Constants<span class="title-stat"><i> (total 171, none are exported)</i></span></span>

	<input type='checkbox' class="showhide" id="unexported-constants-showhide"><i><label for="unexported-constants-showhide" class="show-inline">/* 171 unexporteds ... */</label><label for="unexported-constants-showhide" class="hide-inline">/* 171 unexporteds: */</label></i><div class="anchor value-res hidden" id="name-absIncNotOne"><i>	<input type='checkbox' class="fold" id="absIncNotOne-fold-content"><label for="absIncNotOne-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..absIncNotOne^fe232.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-178">absIncNotOne</a> = "lapack: increment not one or negative one"</label><span id='absIncNotOne-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings for bad vector increments.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badApplyOrtho"><i>	<input type='checkbox' class="fold" id="badApplyOrtho-fold-content"><label for="badApplyOrtho-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badApplyOrtho^3135a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-10">badApplyOrtho</a> = "lapack: bad ApplyOrtho"</label><span id='badApplyOrtho-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings for bad enumeration values.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badBalanceJob"><i>	<input type='checkbox' class="fold" id="badBalanceJob-fold-content"><label for="badBalanceJob-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badBalanceJob^f4f79.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-11">badBalanceJob</a> = "lapack: bad BalanceJob"</label><span id='badBalanceJob-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badDiag"><i>	<input type='checkbox' class="fold" id="badDiag-fold-content"><label for="badDiag-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badDiag^79c17.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-12">badDiag</a> = "lapack: bad Diag"</label><span id='badDiag-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badDirect"><i>	<input type='checkbox' class="fold" id="badDirect-fold-content"><label for="badDirect-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badDirect^f7ec9.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-13">badDirect</a> = "lapack: bad Direct"</label><span id='badDirect-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badEVComp"><i>	<input type='checkbox' class="fold" id="badEVComp-fold-content"><label for="badEVComp-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badEVComp^aab00.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-14">badEVComp</a> = "lapack: bad EVComp"</label><span id='badEVComp-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badEVHowMany"><i>	<input type='checkbox' class="fold" id="badEVHowMany-fold-content"><label for="badEVHowMany-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badEVHowMany^908ef.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-15">badEVHowMany</a> = "lapack: bad EVHowMany"</label><span id='badEVHowMany-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badEVJob"><i>	<input type='checkbox' class="fold" id="badEVJob-fold-content"><label for="badEVJob-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badEVJob^83557.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-16">badEVJob</a> = "lapack: bad EVJob"</label><span id='badEVJob-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badEVSide"><i>	<input type='checkbox' class="fold" id="badEVSide-fold-content"><label for="badEVSide-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badEVSide^feb78.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-17">badEVSide</a> = "lapack: bad EVSide"</label><span id='badEVSide-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badGenOrtho"><i>	<input type='checkbox' class="fold" id="badGenOrtho-fold-content"><label for="badGenOrtho-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badGenOrtho^bcc34.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-19">badGenOrtho</a> = "lapack: bad GenOrtho"</label><span id='badGenOrtho-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badGSVDJob"><i>	<input type='checkbox' class="fold" id="badGSVDJob-fold-content"><label for="badGSVDJob-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badGSVDJob^82a7e.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-18">badGSVDJob</a> = "lapack: bad GSVDJob"</label><span id='badGSVDJob-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badIfst"><i>	<input type='checkbox' class="fold" id="badIfst-fold-content"><label for="badIfst-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badIfst^1fb81.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-38">badIfst</a> = "lapack: ifst out of range"</label><span id='badIfst-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings for bad numerical and string values.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badIhi"><i>	<input type='checkbox' class="fold" id="badIhi-fold-content"><label for="badIhi-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badIhi^16d98.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-39">badIhi</a> = "lapack: ihi out of range"</label><span id='badIhi-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badIhiz"><i>	<input type='checkbox' class="fold" id="badIhiz-fold-content"><label for="badIhiz-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badIhiz^aa89f.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-40">badIhiz</a> = "lapack: ihiz out of range"</label><span id='badIhiz-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badIlo"><i>	<input type='checkbox' class="fold" id="badIlo-fold-content"><label for="badIlo-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badIlo^56489.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-41">badIlo</a> = "lapack: ilo out of range"</label><span id='badIlo-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badIloz"><i>	<input type='checkbox' class="fold" id="badIloz-fold-content"><label for="badIloz-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badIloz^e02dc.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-42">badIloz</a> = "lapack: iloz out of range"</label><span id='badIloz-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badIlst"><i>	<input type='checkbox' class="fold" id="badIlst-fold-content"><label for="badIlst-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badIlst^6730b.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-43">badIlst</a> = "lapack: ilst out of range"</label><span id='badIlst-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badIncX"><i>	<input type='checkbox' class="fold" id="badIncX-fold-content"><label for="badIncX-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badIncX^3d555.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-179">badIncX</a> = "lapack: incX <= 0"</label><span id='badIncX-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badIncY"><i>	<input type='checkbox' class="fold" id="badIncY-fold-content"><label for="badIncY-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badIncY^b8dfc.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-180">badIncY</a> = "lapack: incY <= 0"</label><span id='badIncY-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badIsave"><i>	<input type='checkbox' class="fold" id="badIsave-fold-content"><label for="badIsave-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badIsave^5c3e9.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-44">badIsave</a> = "lapack: bad isave value"</label><span id='badIsave-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badIspec"><i>	<input type='checkbox' class="fold" id="badIspec-fold-content"><label for="badIspec-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badIspec^b28fd.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-45">badIspec</a> = "lapack: bad ispec value"</label><span id='badIspec-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badJ1"><i>	<input type='checkbox' class="fold" id="badJ1-fold-content"><label for="badJ1-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badJ1^c4297.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-46">badJ1</a> = "lapack: j1 out of range"</label><span id='badJ1-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badJpvt"><i>	<input type='checkbox' class="fold" id="badJpvt-fold-content"><label for="badJpvt-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badJpvt^7e8f7.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-47">badJpvt</a> = "lapack: bad element of jpvt"</label><span id='badJpvt-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badK1"><i>	<input type='checkbox' class="fold" id="badK1-fold-content"><label for="badK1-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badK1^cbe13.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-48">badK1</a> = "lapack: k1 out of range"</label><span id='badK1-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badK2"><i>	<input type='checkbox' class="fold" id="badK2-fold-content"><label for="badK2-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badK2^c4ced.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-49">badK2</a> = "lapack: k2 out of range"</label><span id='badK2-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badKacc22"><i>	<input type='checkbox' class="fold" id="badKacc22-fold-content"><label for="badKacc22-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badKacc22^baaf5.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-50">badKacc22</a> = "lapack: invalid value of kacc22"</label><span id='badKacc22-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badKbot"><i>	<input type='checkbox' class="fold" id="badKbot-fold-content"><label for="badKbot-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badKbot^7d784.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-51">badKbot</a> = "lapack: kbot out of range"</label><span id='badKbot-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badKtop"><i>	<input type='checkbox' class="fold" id="badKtop-fold-content"><label for="badKtop-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badKtop^ebad5.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-52">badKtop</a> = "lapack: ktop out of range"</label><span id='badKtop-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdA"><i>	<input type='checkbox' class="fold" id="badLdA-fold-content"><label for="badLdA-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdA^47124.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-157">badLdA</a> = "lapack: bad leading dimension of A"</label><span id='badLdA-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings for bad leading dimensions of matrices.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdB"><i>	<input type='checkbox' class="fold" id="badLdB-fold-content"><label for="badLdB-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdB^b6eed.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-158">badLdB</a> = "lapack: bad leading dimension of B"</label><span id='badLdB-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdC"><i>	<input type='checkbox' class="fold" id="badLdC-fold-content"><label for="badLdC-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdC^4796a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-159">badLdC</a> = "lapack: bad leading dimension of C"</label><span id='badLdC-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdF"><i>	<input type='checkbox' class="fold" id="badLdF-fold-content"><label for="badLdF-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdF^09d80.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-160">badLdF</a> = "lapack: bad leading dimension of F"</label><span id='badLdF-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdH"><i>	<input type='checkbox' class="fold" id="badLdH-fold-content"><label for="badLdH-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdH^32a73.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-161">badLdH</a> = "lapack: bad leading dimension of H"</label><span id='badLdH-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdQ"><i>	<input type='checkbox' class="fold" id="badLdQ-fold-content"><label for="badLdQ-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdQ^b10d4.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-162">badLdQ</a> = "lapack: bad leading dimension of Q"</label><span id='badLdQ-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdT"><i>	<input type='checkbox' class="fold" id="badLdT-fold-content"><label for="badLdT-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdT^8c2e8.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-163">badLdT</a> = "lapack: bad leading dimension of T"</label><span id='badLdT-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdU"><i>	<input type='checkbox' class="fold" id="badLdU-fold-content"><label for="badLdU-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdU^fbeda.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-164">badLdU</a> = "lapack: bad leading dimension of U"</label><span id='badLdU-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdV"><i>	<input type='checkbox' class="fold" id="badLdV-fold-content"><label for="badLdV-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdV^78655.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-165">badLdV</a> = "lapack: bad leading dimension of V"</label><span id='badLdV-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdVL"><i>	<input type='checkbox' class="fold" id="badLdVL-fold-content"><label for="badLdVL-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdVL^eec4e.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-166">badLdVL</a> = "lapack: bad leading dimension of VL"</label><span id='badLdVL-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdVR"><i>	<input type='checkbox' class="fold" id="badLdVR-fold-content"><label for="badLdVR-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdVR^868a4.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-167">badLdVR</a> = "lapack: bad leading dimension of VR"</label><span id='badLdVR-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdVT"><i>	<input type='checkbox' class="fold" id="badLdVT-fold-content"><label for="badLdVT-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdVT^b0ea2.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-168">badLdVT</a> = "lapack: bad leading dimension of VT"</label><span id='badLdVT-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdW"><i>	<input type='checkbox' class="fold" id="badLdW-fold-content"><label for="badLdW-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdW^89dc1.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-169">badLdW</a> = "lapack: bad leading dimension of W"</label><span id='badLdW-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdWH"><i>	<input type='checkbox' class="fold" id="badLdWH-fold-content"><label for="badLdWH-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdWH^9078b.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-170">badLdWH</a> = "lapack: bad leading dimension of WH"</label><span id='badLdWH-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdWork"><i>	<input type='checkbox' class="fold" id="badLdWork-fold-content"><label for="badLdWork-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdWork^4e6e1.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-172">badLdWork</a> = "lapack: bad leading dimension of Work"</label><span id='badLdWork-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdWV"><i>	<input type='checkbox' class="fold" id="badLdWV-fold-content"><label for="badLdWV-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdWV^1e6fb.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-171">badLdWV</a> = "lapack: bad leading dimension of WV"</label><span id='badLdWV-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdX"><i>	<input type='checkbox' class="fold" id="badLdX-fold-content"><label for="badLdX-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdX^04a35.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-173">badLdX</a> = "lapack: bad leading dimension of X"</label><span id='badLdX-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdY"><i>	<input type='checkbox' class="fold" id="badLdY-fold-content"><label for="badLdY-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdY^bcd4d.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-174">badLdY</a> = "lapack: bad leading dimension of Y"</label><span id='badLdY-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLdZ"><i>	<input type='checkbox' class="fold" id="badLdZ-fold-content"><label for="badLdZ-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLdZ^52840.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-175">badLdZ</a> = "lapack: bad leading dimension of Z"</label><span id='badLdZ-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLeftEVJob"><i>	<input type='checkbox' class="fold" id="badLeftEVJob-fold-content"><label for="badLeftEVJob-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLeftEVJob^7ebc8.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-20">badLeftEVJob</a> = "lapack: bad LeftEVJob"</label><span id='badLeftEVJob-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenAlpha"><i>	<input type='checkbox' class="fold" id="badLenAlpha-fold-content"><label for="badLenAlpha-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenAlpha^6639c.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-102">badLenAlpha</a> = "lapack: bad length of alpha"</label><span id='badLenAlpha-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings for bad slice lengths.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenBeta"><i>	<input type='checkbox' class="fold" id="badLenBeta-fold-content"><label for="badLenBeta-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenBeta^37ec6.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-103">badLenBeta</a> = "lapack: bad length of beta"</label><span id='badLenBeta-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenIpiv"><i>	<input type='checkbox' class="fold" id="badLenIpiv-fold-content"><label for="badLenIpiv-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenIpiv^1823f.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-104">badLenIpiv</a> = "lapack: bad length of ipiv"</label><span id='badLenIpiv-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenJpiv"><i>	<input type='checkbox' class="fold" id="badLenJpiv-fold-content"><label for="badLenJpiv-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenJpiv^e5695.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-105">badLenJpiv</a> = "lapack: bad length of jpiv"</label><span id='badLenJpiv-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenJpvt"><i>	<input type='checkbox' class="fold" id="badLenJpvt-fold-content"><label for="badLenJpvt-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenJpvt^34a0d.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-106">badLenJpvt</a> = "lapack: bad length of jpvt"</label><span id='badLenJpvt-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenK"><i>	<input type='checkbox' class="fold" id="badLenK-fold-content"><label for="badLenK-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenK^33695.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-107">badLenK</a> = "lapack: bad length of k"</label><span id='badLenK-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenPiv"><i>	<input type='checkbox' class="fold" id="badLenPiv-fold-content"><label for="badLenPiv-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenPiv^90fa6.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-108">badLenPiv</a> = "lapack: bad length of piv"</label><span id='badLenPiv-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenSelected"><i>	<input type='checkbox' class="fold" id="badLenSelected-fold-content"><label for="badLenSelected-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenSelected^08dab.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-109">badLenSelected</a> = "lapack: bad length of selected"</label><span id='badLenSelected-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenSi"><i>	<input type='checkbox' class="fold" id="badLenSi-fold-content"><label for="badLenSi-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenSi^0242d.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-110">badLenSi</a> = "lapack: bad length of si"</label><span id='badLenSi-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenSr"><i>	<input type='checkbox' class="fold" id="badLenSr-fold-content"><label for="badLenSr-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenSr^924ba.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-111">badLenSr</a> = "lapack: bad length of sr"</label><span id='badLenSr-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenTau"><i>	<input type='checkbox' class="fold" id="badLenTau-fold-content"><label for="badLenTau-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenTau^4750e.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-112">badLenTau</a> = "lapack: bad length of tau"</label><span id='badLenTau-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenWi"><i>	<input type='checkbox' class="fold" id="badLenWi-fold-content"><label for="badLenWi-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenWi^62a60.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-113">badLenWi</a> = "lapack: bad length of wi"</label><span id='badLenWi-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLenWr"><i>	<input type='checkbox' class="fold" id="badLenWr-fold-content"><label for="badLenWr-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLenWr^37d35.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-114">badLenWr</a> = "lapack: bad length of wr"</label><span id='badLenWr-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badLWork"><i>	<input type='checkbox' class="fold" id="badLWork-fold-content"><label for="badLWork-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badLWork^deddb.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-53">badLWork</a> = "lapack: insufficient declared workspace length"</label><span id='badLWork-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badMatrixType"><i>	<input type='checkbox' class="fold" id="badMatrixType-fold-content"><label for="badMatrixType-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badMatrixType^be590.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-21">badMatrixType</a> = "lapack: bad MatrixType"</label><span id='badMatrixType-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badMaximizeNormXJob"><i>	<input type='checkbox' class="fold" id="badMaximizeNormXJob-fold-content"><label for="badMaximizeNormXJob-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badMaximizeNormXJob^a1758.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-22">badMaximizeNormXJob</a> = "lapack: bad MaximizeNormXJob"</label><span id='badMaximizeNormXJob-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badMm"><i>	<input type='checkbox' class="fold" id="badMm-fold-content"><label for="badMm-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badMm^4e908.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-54">badMm</a> = "lapack: mm out of range"</label><span id='badMm-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badN1"><i>	<input type='checkbox' class="fold" id="badN1-fold-content"><label for="badN1-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badN1^29e54.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-55">badN1</a> = "lapack: bad value of n1"</label><span id='badN1-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badN2"><i>	<input type='checkbox' class="fold" id="badN2-fold-content"><label for="badN2-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badN2^fc9da.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-56">badN2</a> = "lapack: bad value of n2"</label><span id='badN2-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badNa"><i>	<input type='checkbox' class="fold" id="badNa-fold-content"><label for="badNa-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badNa^84e52.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-57">badNa</a> = "lapack: bad value of na"</label><span id='badNa-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badName"><i>	<input type='checkbox' class="fold" id="badName-fold-content"><label for="badName-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badName^5f58e.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-58">badName</a> = "lapack: bad name"</label><span id='badName-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badNh"><i>	<input type='checkbox' class="fold" id="badNh-fold-content"><label for="badNh-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badNh^11b95.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-59">badNh</a> = "lapack: bad value of nh"</label><span id='badNh-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badNorm"><i>	<input type='checkbox' class="fold" id="badNorm-fold-content"><label for="badNorm-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badNorm^7985c.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-23">badNorm</a> = "lapack: bad Norm"</label><span id='badNorm-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badNw"><i>	<input type='checkbox' class="fold" id="badNw-fold-content"><label for="badNw-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badNw^f6d4b.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-60">badNw</a> = "lapack: bad value of nw"</label><span id='badNw-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badPivot"><i>	<input type='checkbox' class="fold" id="badPivot-fold-content"><label for="badPivot-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badPivot^1e60e.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-24">badPivot</a> = "lapack: bad Pivot"</label><span id='badPivot-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badPp"><i>	<input type='checkbox' class="fold" id="badPp-fold-content"><label for="badPp-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badPp^8ad79.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-61">badPp</a> = "lapack: bad value of pp"</label><span id='badPp-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badRightEVJob"><i>	<input type='checkbox' class="fold" id="badRightEVJob-fold-content"><label for="badRightEVJob-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badRightEVJob^6131b.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-25">badRightEVJob</a> = "lapack: bad RightEVJob"</label><span id='badRightEVJob-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badSchurComp"><i>	<input type='checkbox' class="fold" id="badSchurComp-fold-content"><label for="badSchurComp-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badSchurComp^83cdf.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-27">badSchurComp</a> = "lapack: bad SchurComp"</label><span id='badSchurComp-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badSchurJob"><i>	<input type='checkbox' class="fold" id="badSchurJob-fold-content"><label for="badSchurJob-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badSchurJob^0c820.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-28">badSchurJob</a> = "lapack: bad SchurJob"</label><span id='badSchurJob-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badShifts"><i>	<input type='checkbox' class="fold" id="badShifts-fold-content"><label for="badShifts-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badShifts^70fd8.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-62">badShifts</a> = "lapack: bad shifts"</label><span id='badShifts-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badSide"><i>	<input type='checkbox' class="fold" id="badSide-fold-content"><label for="badSide-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badSide^7168b.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-29">badSide</a> = "lapack: bad Side"</label><span id='badSide-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badSort"><i>	<input type='checkbox' class="fold" id="badSort-fold-content"><label for="badSort-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badSort^897c7.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-30">badSort</a> = "lapack: bad Sort"</label><span id='badSort-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badStoreV"><i>	<input type='checkbox' class="fold" id="badStoreV-fold-content"><label for="badStoreV-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badStoreV^8fdd6.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-31">badStoreV</a> = "lapack: bad StoreV"</label><span id='badStoreV-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badSVDJob"><i>	<input type='checkbox' class="fold" id="badSVDJob-fold-content"><label for="badSVDJob-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badSVDJob^a31fe.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-26">badSVDJob</a> = "lapack: bad SVDJob"</label><span id='badSVDJob-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badTrans"><i>	<input type='checkbox' class="fold" id="badTrans-fold-content"><label for="badTrans-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badTrans^a6a87.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-32">badTrans</a> = "lapack: bad Trans"</label><span id='badTrans-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badUpdateSchurComp"><i>	<input type='checkbox' class="fold" id="badUpdateSchurComp-fold-content"><label for="badUpdateSchurComp-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badUpdateSchurComp^196b6.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-33">badUpdateSchurComp</a> = "lapack: bad UpdateSchurComp"</label><span id='badUpdateSchurComp-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-badUplo"><i>	<input type='checkbox' class="fold" id="badUplo-fold-content"><label for="badUplo-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..badUplo^dbb29.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-34">badUplo</a> = "lapack: bad Uplo"</label><span id='badUplo-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-bothSVDOver"><i>	<input type='checkbox' class="fold" id="bothSVDOver-fold-content"><label for="bothSVDOver-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..bothSVDOver^4e9f7.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-35">bothSVDOver</a> = "lapack: both jobU and jobVT are lapack.SVDOverwrite"</label><span id='bothSVDOver-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-dlamchB"><i>	<input type='checkbox' class="fold" id="dlamchB-fold-content"><label for="dlamchB-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..dlamchB^fea1c.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html#line-42">dlamchB</a> = 2</label><span id='dlamchB-fold-content-docs' class="fold-docs">
<span class="md-text">		dlamchB is the radix of the machine (the base of the number system).</span>

</span></i></div><div class="anchor value-res hidden" id="name-dlamchE"><i>	<input type='checkbox' class="fold" id="dlamchE-fold-content"><label for="dlamchE-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..dlamchE^3c583.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html#line-39">dlamchE</a> = 1.11022e-16</label><span id='dlamchE-fold-content-docs' class="fold-docs">
<span class="md-text">		dlamchE is the machine epsilon. For IEEE this is 2^{-53}.</span>

</span></i></div><div class="anchor value-res hidden" id="name-dlamchP"><i>	<input type='checkbox' class="fold" id="dlamchP-fold-content"><label for="dlamchP-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..dlamchP^7d006.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html#line-45">dlamchP</a> = 2.22045e-16</label><span id='dlamchP-fold-content-docs' class="fold-docs">
<span class="md-text">		dlamchP is base * eps.</span>

</span></i></div><div class="anchor value-res hidden" id="name-dlamchS"><i>	<input type='checkbox' class="fold" id="dlamchS-fold-content"><label for="dlamchS-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..dlamchS^877aa.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html#line-50">dlamchS</a> = 2.22507e-308</label><span id='dlamchS-fold-content-docs' class="fold-docs">
<span class="md-text">		dlamchS is the "safe minimum", that is, the lowest number such that
		1/dlamchS does not overflow, or also the smallest normal number.
		For IEEE this is 2^{-1022}.</span>

</span></i></div><div class="anchor value-res hidden" id="name-dsbig"><i>	<span class="nodocs"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..dsbig^32b63.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html#line-77">dsbig</a> = 1.11138e-162</span></i></div><div class="anchor value-res hidden" id="name-dssml"><i>	<span class="nodocs"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..dssml^4bfd5.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html#line-76">dssml</a> = 4.49891e+161</span></i></div><div class="anchor value-res hidden" id="name-dtbig"><i>	<span class="nodocs"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..dtbig^d1fa2.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html#line-75">dtbig</a> = 1.99792e+146</span></i></div><div class="anchor value-res hidden" id="name-dtsml"><i>	<input type='checkbox' class="fold" id="dtsml-fold-content"><label for="dtsml-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..dtsml^a893e.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/lapack.go.html#line-74">dtsml</a> = 1.49167e-154</label><span id='dtsml-fold-content-docs' class="fold-docs">
<span class="md-text">		Blue's scaling constants
		
		An n-vector x is well-scaled if
		 dtsml ≤ |xᵢ| ≤ dtbig for 0 ≤ i &lt; n and n ≤ 1/dlamchP,
		where
		 dtsml = 2^ceil((expmin-1)/2) = 2^ceil((-1021-1)/2) = 2^{-511} = 1.4916681462400413e-154
		 dtbig = 2^floor((expmax-digits+1)/2) = 2^floor((1024-53+1)/2) = 2^{486} = 1.997919072202235e+146
		If any xᵢ is not well-scaled, then multiplying small values by dssml and
		large values by dsbig avoids underflow or overflow when computing the sum
		of squares \sum_0^{n-1} (xᵢ)².
		 dssml = 2^{-floor((expmin-digits)/2)} = 2^{-floor((-1021-53)/2)} = 2^537 = 4.4989137945431964e+161
		 dsbig = 2^{-ceil((expmax+digits-1)/2)} = 2^{-ceil((1024+53-1)/2)} = 2^{-538} = 1.1113793747425387e-162
		
		References:
		 - Anderson E. (2017)
		   Algorithm 978: Safe Scaling in the Level 1 BLAS
		   ACM Trans Math Softw 44:1--28
		   https://doi.org/10.1145/3061665
		 - Blue, James L. (1978)
		   A Portable Fortran Program to Find the Euclidean Norm of a Vector
		   ACM Trans Math Softw 4:15--23
		   https://doi.org/10.1145/355769.355771</span>

</span></i></div><div class="anchor value-res hidden" id="name-i0LT0"><i>	<input type='checkbox' class="fold" id="i0LT0-fold-content"><label for="i0LT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..i0LT0^24a1e.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-63">i0LT0</a> = "lapack: i0 < 0"</label><span id='i0LT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-kdLT0"><i>	<input type='checkbox' class="fold" id="kdLT0-fold-content"><label for="kdLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..kdLT0^3e123.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-68">kdLT0</a> = "lapack: kd < 0"</label><span id='kdLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-kGTM"><i>	<input type='checkbox' class="fold" id="kGTM-fold-content"><label for="kGTM-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..kGTM^f8794.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-64">kGTM</a> = "lapack: k > m"</label><span id='kGTM-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-kGTN"><i>	<input type='checkbox' class="fold" id="kGTN-fold-content"><label for="kGTN-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..kGTN^1ecaa.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-65">kGTN</a> = "lapack: k > n"</label><span id='kGTN-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-klLT0"><i>	<input type='checkbox' class="fold" id="klLT0-fold-content"><label for="klLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..klLT0^ce91a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-69">klLT0</a> = "lapack: kl < 0"</label><span id='klLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-kLT0"><i>	<input type='checkbox' class="fold" id="kLT0-fold-content"><label for="kLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..kLT0^82e4f.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-66">kLT0</a> = "lapack: k < 0"</label><span id='kLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-kLT1"><i>	<input type='checkbox' class="fold" id="kLT1-fold-content"><label for="kLT1-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..kLT1^7f297.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-67">kLT1</a> = "lapack: k < 1"</label><span id='kLT1-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-kuLT0"><i>	<input type='checkbox' class="fold" id="kuLT0-fold-content"><label for="kuLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..kuLT0^568c1.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-70">kuLT0</a> = "lapack: ku < 0"</label><span id='kuLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-mGTN"><i>	<input type='checkbox' class="fold" id="mGTN-fold-content"><label for="mGTN-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..mGTN^dd366.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-71">mGTN</a> = "lapack: m > n"</label><span id='mGTN-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-mLT0"><i>	<input type='checkbox' class="fold" id="mLT0-fold-content"><label for="mLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..mLT0^ad35b.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-72">mLT0</a> = "lapack: m < 0"</label><span id='mLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-mmLT0"><i>	<input type='checkbox' class="fold" id="mmLT0-fold-content"><label for="mmLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..mmLT0^326a9.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-73">mmLT0</a> = "lapack: mm < 0"</label><span id='mmLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-n0LT0"><i>	<input type='checkbox' class="fold" id="n0LT0-fold-content"><label for="n0LT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..n0LT0^880a2.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-74">n0LT0</a> = "lapack: n0 < 0"</label><span id='n0LT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nanCFrom"><i>	<input type='checkbox' class="fold" id="nanCFrom-fold-content"><label for="nanCFrom-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nanCFrom^e9095.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-79">nanCFrom</a> = "lapack: cfrom is NaN"</label><span id='nanCFrom-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nanCTo"><i>	<input type='checkbox' class="fold" id="nanCTo-fold-content"><label for="nanCTo-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nanCTo^7a098.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-80">nanCTo</a> = "lapack: cto is NaN"</label><span id='nanCTo-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nbGTM"><i>	<input type='checkbox' class="fold" id="nbGTM-fold-content"><label for="nbGTM-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nbGTM^61e54.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-81">nbGTM</a> = "lapack: nb > m"</label><span id='nbGTM-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nbGTN"><i>	<input type='checkbox' class="fold" id="nbGTN-fold-content"><label for="nbGTN-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nbGTN^37ff8.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-82">nbGTN</a> = "lapack: nb > n"</label><span id='nbGTN-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nbLT0"><i>	<input type='checkbox' class="fold" id="nbLT0-fold-content"><label for="nbLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nbLT0^4a6c5.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-83">nbLT0</a> = "lapack: nb < 0"</label><span id='nbLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nccLT0"><i>	<input type='checkbox' class="fold" id="nccLT0-fold-content"><label for="nccLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nccLT0^4359f.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-84">nccLT0</a> = "lapack: ncc < 0"</label><span id='nccLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-ncvtLT0"><i>	<input type='checkbox' class="fold" id="ncvtLT0-fold-content"><label for="ncvtLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..ncvtLT0^b1674.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-85">ncvtLT0</a> = "lapack: ncvt < 0"</label><span id='ncvtLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-negANorm"><i>	<input type='checkbox' class="fold" id="negANorm-fold-content"><label for="negANorm-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..negANorm^e972a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-86">negANorm</a> = "lapack: anorm < 0"</label><span id='negANorm-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-negZ"><i>	<input type='checkbox' class="fold" id="negZ-fold-content"><label for="negZ-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..negZ^8c90a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-87">negZ</a> = "lapack: negative z value"</label><span id='negZ-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nGTM"><i>	<input type='checkbox' class="fold" id="nGTM-fold-content"><label for="nGTM-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nGTM^a3fdc.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-75">nGTM</a> = "lapack: n > m"</label><span id='nGTM-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nhLT0"><i>	<input type='checkbox' class="fold" id="nhLT0-fold-content"><label for="nhLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nhLT0^995ce.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-88">nhLT0</a> = "lapack: nh < 0"</label><span id='nhLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nLT0"><i>	<input type='checkbox' class="fold" id="nLT0-fold-content"><label for="nLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nLT0^e9f5b.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-76">nLT0</a> = "lapack: n < 0"</label><span id='nLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nLT1"><i>	<input type='checkbox' class="fold" id="nLT1-fold-content"><label for="nLT1-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nLT1^7297c.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-77">nLT1</a> = "lapack: n < 1"</label><span id='nLT1-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nLTM"><i>	<input type='checkbox' class="fold" id="nLTM-fold-content"><label for="nLTM-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nLTM^2bfca.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-78">nLTM</a> = "lapack: n < m"</label><span id='nLTM-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-noSVDO"><i>	<span class="nodocs"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..noSVDO^608f7.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/dgesvd.go.html#line-15">noSVDO</a> = "dgesvd: not coded for overwrite"</span></i></div><div class="anchor value-res hidden" id="name-notIsolated"><i>	<input type='checkbox' class="fold" id="notIsolated-fold-content"><label for="notIsolated-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..notIsolated^e7db4.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-89">notIsolated</a> = "lapack: block is not isolated"</label><span id='notIsolated-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nrhsLT0"><i>	<input type='checkbox' class="fold" id="nrhsLT0-fold-content"><label for="nrhsLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nrhsLT0^acd3a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-90">nrhsLT0</a> = "lapack: nrhs < 0"</label><span id='nrhsLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nruLT0"><i>	<input type='checkbox' class="fold" id="nruLT0-fold-content"><label for="nruLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nruLT0^0536c.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-91">nruLT0</a> = "lapack: nru < 0"</label><span id='nruLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nshftsLT0"><i>	<input type='checkbox' class="fold" id="nshftsLT0-fold-content"><label for="nshftsLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nshftsLT0^0172e.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-92">nshftsLT0</a> = "lapack: nshfts < 0"</label><span id='nshftsLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nshftsOdd"><i>	<input type='checkbox' class="fold" id="nshftsOdd-fold-content"><label for="nshftsOdd-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nshftsOdd^08acd.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-93">nshftsOdd</a> = "lapack: nshfts must be even"</label><span id='nshftsOdd-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-nvLT0"><i>	<input type='checkbox' class="fold" id="nvLT0-fold-content"><label for="nvLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..nvLT0^02c28.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-94">nvLT0</a> = "lapack: nv < 0"</label><span id='nvLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-offsetGTM"><i>	<input type='checkbox' class="fold" id="offsetGTM-fold-content"><label for="offsetGTM-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..offsetGTM^2e0b9.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-95">offsetGTM</a> = "lapack: offset > m"</label><span id='offsetGTM-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-offsetLT0"><i>	<input type='checkbox' class="fold" id="offsetLT0-fold-content"><label for="offsetLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..offsetLT0^3440f.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-96">offsetLT0</a> = "lapack: offset < 0"</label><span id='offsetLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-pLT0"><i>	<input type='checkbox' class="fold" id="pLT0-fold-content"><label for="pLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..pLT0^a2b62.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-97">pLT0</a> = "lapack: p < 0"</label><span id='pLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-recurLT0"><i>	<input type='checkbox' class="fold" id="recurLT0-fold-content"><label for="recurLT0-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..recurLT0^300c9.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-98">recurLT0</a> = "lapack: recur < 0"</label><span id='recurLT0-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortA"><i>	<input type='checkbox' class="fold" id="shortA-fold-content"><label for="shortA-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortA^e8c8c.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-117">shortA</a> = "lapack: insufficient length of a"</label><span id='shortA-fold-content-docs' class="fold-docs">
<span class="md-text">		Panic strings for insufficient slice lengths.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortAB"><i>	<input type='checkbox' class="fold" id="shortAB-fold-content"><label for="shortAB-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortAB^3a254.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-118">shortAB</a> = "lapack: insufficient length of ab"</label><span id='shortAB-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortAuxv"><i>	<input type='checkbox' class="fold" id="shortAuxv-fold-content"><label for="shortAuxv-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortAuxv^cf289.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-119">shortAuxv</a> = "lapack: insufficient length of auxv"</label><span id='shortAuxv-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortB"><i>	<input type='checkbox' class="fold" id="shortB-fold-content"><label for="shortB-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortB^76b08.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-120">shortB</a> = "lapack: insufficient length of b"</label><span id='shortB-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortC"><i>	<input type='checkbox' class="fold" id="shortC-fold-content"><label for="shortC-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortC^1dbc2.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-121">shortC</a> = "lapack: insufficient length of c"</label><span id='shortC-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortCNorm"><i>	<input type='checkbox' class="fold" id="shortCNorm-fold-content"><label for="shortCNorm-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortCNorm^e17ef.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-122">shortCNorm</a> = "lapack: insufficient length of cnorm"</label><span id='shortCNorm-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortD"><i>	<input type='checkbox' class="fold" id="shortD-fold-content"><label for="shortD-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortD^d1b89.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-123">shortD</a> = "lapack: insufficient length of d"</label><span id='shortD-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortDL"><i>	<input type='checkbox' class="fold" id="shortDL-fold-content"><label for="shortDL-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortDL^67cb5.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-124">shortDL</a> = "lapack: insufficient length of dl"</label><span id='shortDL-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortDU"><i>	<input type='checkbox' class="fold" id="shortDU-fold-content"><label for="shortDU-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortDU^5e154.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-125">shortDU</a> = "lapack: insufficient length of du"</label><span id='shortDU-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortE"><i>	<input type='checkbox' class="fold" id="shortE-fold-content"><label for="shortE-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortE^294c0.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-126">shortE</a> = "lapack: insufficient length of e"</label><span id='shortE-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortF"><i>	<input type='checkbox' class="fold" id="shortF-fold-content"><label for="shortF-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortF^4228e.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-127">shortF</a> = "lapack: insufficient length of f"</label><span id='shortF-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortH"><i>	<input type='checkbox' class="fold" id="shortH-fold-content"><label for="shortH-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortH^faae8.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-128">shortH</a> = "lapack: insufficient length of h"</label><span id='shortH-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortIsgn"><i>	<input type='checkbox' class="fold" id="shortIsgn-fold-content"><label for="shortIsgn-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortIsgn^dfdc0.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-130">shortIsgn</a> = "lapack: insufficient length of isgn"</label><span id='shortIsgn-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortIWork"><i>	<input type='checkbox' class="fold" id="shortIWork-fold-content"><label for="shortIWork-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortIWork^6569e.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-129">shortIWork</a> = "lapack: insufficient length of iwork"</label><span id='shortIWork-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortQ"><i>	<input type='checkbox' class="fold" id="shortQ-fold-content"><label for="shortQ-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortQ^b5ef4.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-131">shortQ</a> = "lapack: insufficient length of q"</label><span id='shortQ-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortRHS"><i>	<input type='checkbox' class="fold" id="shortRHS-fold-content"><label for="shortRHS-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortRHS^8f192.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-132">shortRHS</a> = "lapack: insufficient length of rhs"</label><span id='shortRHS-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortS"><i>	<input type='checkbox' class="fold" id="shortS-fold-content"><label for="shortS-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortS^a8aa9.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-133">shortS</a> = "lapack: insufficient length of s"</label><span id='shortS-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortScale"><i>	<input type='checkbox' class="fold" id="shortScale-fold-content"><label for="shortScale-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortScale^13461.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-134">shortScale</a> = "lapack: insufficient length of scale"</label><span id='shortScale-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortT"><i>	<input type='checkbox' class="fold" id="shortT-fold-content"><label for="shortT-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortT^f632a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-135">shortT</a> = "lapack: insufficient length of t"</label><span id='shortT-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortTau"><i>	<input type='checkbox' class="fold" id="shortTau-fold-content"><label for="shortTau-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortTau^41134.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-136">shortTau</a> = "lapack: insufficient length of tau"</label><span id='shortTau-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortTauP"><i>	<input type='checkbox' class="fold" id="shortTauP-fold-content"><label for="shortTauP-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortTauP^74552.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-137">shortTauP</a> = "lapack: insufficient length of tauP"</label><span id='shortTauP-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortTauQ"><i>	<input type='checkbox' class="fold" id="shortTauQ-fold-content"><label for="shortTauQ-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortTauQ^4273a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-138">shortTauQ</a> = "lapack: insufficient length of tauQ"</label><span id='shortTauQ-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortU"><i>	<input type='checkbox' class="fold" id="shortU-fold-content"><label for="shortU-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortU^dceb1.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-139">shortU</a> = "lapack: insufficient length of u"</label><span id='shortU-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortV"><i>	<input type='checkbox' class="fold" id="shortV-fold-content"><label for="shortV-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortV^7089a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-140">shortV</a> = "lapack: insufficient length of v"</label><span id='shortV-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortVL"><i>	<input type='checkbox' class="fold" id="shortVL-fold-content"><label for="shortVL-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortVL^ce978.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-141">shortVL</a> = "lapack: insufficient length of vl"</label><span id='shortVL-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortVn1"><i>	<input type='checkbox' class="fold" id="shortVn1-fold-content"><label for="shortVn1-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortVn1^4ce1a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-144">shortVn1</a> = "lapack: insufficient length of vn1"</label><span id='shortVn1-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortVn2"><i>	<input type='checkbox' class="fold" id="shortVn2-fold-content"><label for="shortVn2-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortVn2^fafbe.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-145">shortVn2</a> = "lapack: insufficient length of vn2"</label><span id='shortVn2-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortVR"><i>	<input type='checkbox' class="fold" id="shortVR-fold-content"><label for="shortVR-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortVR^b8b52.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-142">shortVR</a> = "lapack: insufficient length of vr"</label><span id='shortVR-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortVT"><i>	<input type='checkbox' class="fold" id="shortVT-fold-content"><label for="shortVT-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortVT^590ed.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-143">shortVT</a> = "lapack: insufficient length of vt"</label><span id='shortVT-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortW"><i>	<input type='checkbox' class="fold" id="shortW-fold-content"><label for="shortW-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortW^a257d.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-146">shortW</a> = "lapack: insufficient length of w"</label><span id='shortW-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortWH"><i>	<input type='checkbox' class="fold" id="shortWH-fold-content"><label for="shortWH-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortWH^2f870.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-147">shortWH</a> = "lapack: insufficient length of wh"</label><span id='shortWH-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortWi"><i>	<input type='checkbox' class="fold" id="shortWi-fold-content"><label for="shortWi-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortWi^087da.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-149">shortWi</a> = "lapack: insufficient length of wi"</label><span id='shortWi-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortWork"><i>	<input type='checkbox' class="fold" id="shortWork-fold-content"><label for="shortWork-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortWork^ba4c8.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-150">shortWork</a> = "lapack: insufficient length of work"</label><span id='shortWork-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortWr"><i>	<input type='checkbox' class="fold" id="shortWr-fold-content"><label for="shortWr-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortWr^c02f8.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-151">shortWr</a> = "lapack: insufficient length of wr"</label><span id='shortWr-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortWV"><i>	<input type='checkbox' class="fold" id="shortWV-fold-content"><label for="shortWV-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortWV^75f6a.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-148">shortWV</a> = "lapack: insufficient length of wv"</label><span id='shortWV-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortX"><i>	<input type='checkbox' class="fold" id="shortX-fold-content"><label for="shortX-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortX^fc690.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-152">shortX</a> = "lapack: insufficient length of x"</label><span id='shortX-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortY"><i>	<input type='checkbox' class="fold" id="shortY-fold-content"><label for="shortY-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortY^09545.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-153">shortY</a> = "lapack: insufficient length of y"</label><span id='shortY-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-shortZ"><i>	<input type='checkbox' class="fold" id="shortZ-fold-content"><label for="shortZ-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..shortZ^82529.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-154">shortZ</a> = "lapack: insufficient length of z"</label><span id='shortZ-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-zeroCFrom"><i>	<input type='checkbox' class="fold" id="zeroCFrom-fold-content"><label for="zeroCFrom-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..zeroCFrom^60ec0.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-99">zeroCFrom</a> = "lapack: zero cfrom"</label><span id='zeroCFrom-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div><div class="anchor value-res hidden" id="name-zeroIncV"><i>	<input type='checkbox' class="fold" id="zeroIncV-fold-content"><label for="zeroIncV-fold-content"><a href="../../../../../use/gonum.org/v1/gonum/lapack/gonum..zeroIncV^9b74b.html">const</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/gonum/errors.go.html#line-181">zeroIncV</a> = "lapack: incv == 0"</label><span id='zeroIncV-fold-content-docs' class="fold-docs">
<span class="md-text">		This list is duplicated in netlib/lapack/netlib. Keep in sync.</span>

</span></i></div></div></code></pre><pre id="footer">
<table><tr><td><img src="../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.7</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>