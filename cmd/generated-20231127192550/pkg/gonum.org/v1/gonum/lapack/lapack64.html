<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Package: gonum.org/v1/gonum/lapack/lapack64</title>
<link href="../../../../../css/auto-v0.6.7.css" rel="stylesheet">
<script src="../../../../../jvs/golds-v0.6.7.js"></script>
<body onload="onPageLoad()"><div>

<pre id="package-details"><code><span style="font-size:xx-large;">package <b>lapack64</b></span>

<span class="title">Import Path</span>
	<a href="../../../../../index.html#pkg-gonum.org/v1/gonum/lapack/lapack64">gonum.org/v1/gonum/lapack/lapack64</a><i> (on <a href="https://pkg.go.dev/gonum.org/v1/gonum/lapack/lapack64" target="_blank">go.dev</a>)</i>

<span class="title">Dependency Relation</span>
	imports <a href="../../../../../dep/gonum.org/v1/gonum/lapack/lapack64.html">4 packages</a>, and imported by <a href="../../../../../dep/gonum.org/v1/gonum/lapack/lapack64.html#imported-by">one package</a>

<div id="files"><span class="title">Involved Source Files</span>

	<input type='checkbox' checked class="fold" id="file-0-fold-content"><label for="file-0-fold-content">  <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/doc.go.html#doc">d</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/doc.go.html">doc.go</a></label><span id='file-0-fold-content-items' class="fold-items">
<span class="md-text">		Package lapack64 provides a set of convenient wrapper functions for LAPACK
		calls, as specified in the netlib standard (www.netlib.org).
		
		The native Go routines are used by default, and the Use function can be used
		to set an alternative implementation.
		
		If the type of matrix (General, Symmetric, etc.) is known and fixed, it is
		used in the wrapper signature. In many cases, however, the type of the matrix
		changes during the call to the routine, for example the matrix is symmetric on
		entry and is triangular on exit. In these cases the correct types should be checked
		in the documentation.
		
		The full set of Lapack functions is very large, and it is not clear that a
		full implementation is desirable, let alone feasible. Please open up an issue
		if there is a specific function you need and/or are willing to implement.</span>
</span>
	<span class="nodocs">    <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html">lapack64.go</a></span></div>
<div id="exported-types"><span class="title">Package-Level Type Names<span class="title-stat"><i> (only one, which is exported)</i></span></span>

<div id="exported-types-buttons" class="js-on">	/* sort exporteds by: <label id="sort-types-by-alphabet" class="button">alphabet</label> | <label id="sort-types-by-popularity" class="button">popularity</label> */</div><div class="anchor type-res" id="name-Tridiagonal" data-popularity="290">	<input type='checkbox' class="fold" id="Tridiagonal-fold-content"><label for="Tridiagonal-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Tridiagonal.html">type</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-23">Tridiagonal</a> <i>(struct)</i></label><span id='Tridiagonal-fold-content-docs' class="fold-docs">
<span class="md-text">		Tridiagonal represents a tridiagonal matrix using its three diagonals.</span>

		<input type='checkbox' class="fold" id="Tridiagonal-fold-fields"><label for="Tridiagonal-fold-fields">Fields (<i>total 4, all are exported</i>)</label><span id='Tridiagonal-fold-fields-items' class="fold-items"><span>
			<span class="nodocs"><a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-26">D</a> <i>[]<a href="../../../../builtin.html#name-float64">float64</a></i></span></span><span>
			<span class="nodocs"><a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-25">DL</a> <i>[]<a href="../../../../builtin.html#name-float64">float64</a></i></span></span><span>
			<span class="nodocs"><a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-27">DU</a> <i>[]<a href="../../../../builtin.html#name-float64">float64</a></i></span></span><span>
			<span class="nodocs"><a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-24">N</a> <i><a href="../../../../builtin.html#name-int">int</a></i></span></span></span>
		<input type='checkbox' class="fold" id="Tridiagonal-fold-results"><label for="Tridiagonal-fold-results">As Outputs Of (<i>at least 2, both are exported</i>)</label><span id='Tridiagonal-fold-results-items' class="fold-items"><span>
			func gonum.org/v1/gonum/mat.<a href="../mat.html#name-RawTridiagonaler">RawTridiagonaler</a>.<a href="../../../../../src/gonum.org/v1/gonum/mat/tridiag.go.html#line-30">RawTridiagonal</a>() <b>Tridiagonal</b></span><span>
			func gonum.org/v1/gonum/mat.(*<a href="../mat.html#name-Tridiag">Tridiag</a>).<a href="../../../../../src/gonum.org/v1/gonum/mat/tridiag.go.html#line-102">RawTridiagonal</a>() <b>Tridiagonal</b></span></span>
		<input type='checkbox' class="fold" id="Tridiagonal-fold-params"><label for="Tridiagonal-fold-params">As Inputs Of (<i>at least 4, all are exported</i>)</label><span id='Tridiagonal-fold-params-items' class="fold-items"><span>
			func <a href="#name-Gtsv">Gtsv</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, a <b>Tridiagonal</b>, b <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</span><span>
			func <a href="#name-Lagtm">Lagtm</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a <b>Tridiagonal</b>, b <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, c <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>)</span><span>
			func <a href="#name-Langt">Langt</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, a <b>Tridiagonal</b>) <a href="../../../../builtin.html#name-float64">float64</a></span><span>
			func gonum.org/v1/gonum/mat.(*<a href="../mat.html#name-Tridiag">Tridiag</a>).<a href="../../../../../src/gonum.org/v1/gonum/mat/tridiag.go.html#line-109">SetRawTridiagonal</a>(mat <b>Tridiagonal</b>)</span></span>

</span></div></div>
<div id="exported-functions"><span class="title">Package-Level Functions<span class="title-stat"><i> (total 38, in which 37 are exported)</i></span></span>

<div class="anchor value-res" id="name-Gecon">	<input type='checkbox' class="fold" id="Gecon-fold-content"><label for="Gecon-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Gecon.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-187">Gecon</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, anorm <a href="../../../../builtin.html#name-float64">float64</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, iwork []<a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Gecon-fold-content-docs' class="fold-docs">
<span class="md-text">		Gecon estimates the reciprocal of the condition number of the n×n matrix A
		given the LU decomposition of the matrix. The condition number computed may
		be based on the 1-norm or the ∞-norm.
		
		a contains the result of the LU decomposition of A as computed by Getrf.
		
		anorm is the corresponding 1-norm or ∞-norm of the original matrix A.
		
		work is a temporary data slice of length at least 4*n and Gecon will panic otherwise.
		
		iwork is a temporary data slice of length at least n and Gecon will panic otherwise.</span>

</span></div><div class="anchor value-res" id="name-Geev">	<input type='checkbox' class="fold" id="Geev-fold-content"><label for="Geev-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Geev.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-814">Geev</a>(jobvl <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-LeftEVJob">LeftEVJob</a>, jobvr <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-RightEVJob">RightEVJob</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, wr, wi []<a href="../../../../builtin.html#name-float64">float64</a>, vl, vr <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) (first <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Geev-fold-content-docs' class="fold-docs">
<span class="md-text">		Geev computes the eigenvalues and, optionally, the left and/or right
		eigenvectors for an n×n real nonsymmetric matrix A.
		
		The right eigenvector v_j of A corresponding to an eigenvalue λ_j
		is defined by
		
			A v_j = λ_j v_j,
		
		and the left eigenvector u_j corresponding to an eigenvalue λ_j is defined by
		
			u_jᴴ A = λ_j u_jᴴ,
		
		where u_jᴴ is the conjugate transpose of u_j.
		
		On return, A will be overwritten and the left and right eigenvectors will be
		stored, respectively, in the columns of the n×n matrices VL and VR in the
		same order as their eigenvalues. If the j-th eigenvalue is real, then
		
			u_j = VL[:,j],
			v_j = VR[:,j],
		
		and if it is not real, then j and j+1 form a complex conjugate pair and the
		eigenvectors can be recovered as
		
			u_j     = VL[:,j] + i*VL[:,j+1],
			u_{j+1} = VL[:,j] - i*VL[:,j+1],
			v_j     = VR[:,j] + i*VR[:,j+1],
			v_{j+1} = VR[:,j] - i*VR[:,j+1],
		
		where i is the imaginary unit. The computed eigenvectors are normalized to
		have Euclidean norm equal to 1 and largest component real.
		
		Left eigenvectors will be computed only if jobvl == lapack.LeftEVCompute,
		otherwise jobvl must be lapack.LeftEVNone.
		Right eigenvectors will be computed only if jobvr == lapack.RightEVCompute,
		otherwise jobvr must be lapack.RightEVNone.
		For other values of jobvl and jobvr Geev will panic.
		
		On return, wr and wi will contain the real and imaginary parts, respectively,
		of the computed eigenvalues. Complex conjugate pairs of eigenvalues appear
		consecutively with the eigenvalue having the positive imaginary part first.
		wr and wi must have length n, and Geev will panic otherwise.
		
		work must have length at least lwork and lwork must be at least max(1,4*n) if
		the left or right eigenvectors are computed, and at least max(1,3*n) if no
		eigenvectors are computed. For good performance, lwork must generally be
		larger. On return, optimal value of lwork will be stored in work[0].
		
		If lwork == -1, instead of performing Geev, the function only calculates the
		optimal value of lwork and stores it into work[0].
		
		On return, first will be the index of the first valid eigenvalue.
		If first == 0, all eigenvalues and eigenvectors have been computed.
		If first is positive, Geev failed to compute all the eigenvalues, no
		eigenvectors have been computed and wr[first:] and wi[first:] contain those
		eigenvalues which have converged.</span>

</span></div><div class="anchor value-res" id="name-Gelqf">	<input type='checkbox' class="fold" id="Gelqf-fold-content"><label for="Gelqf-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Gelqf.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-269">Gelqf</a>(a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Gelqf-fold-content-docs' class="fold-docs">
<span class="md-text">		Gelqf computes the LQ factorization of the m×n matrix A using a blocked
		algorithm. A is modified to contain the information to construct L and Q. The
		lower triangle of a contains the matrix L. The elements above the diagonal
		and the slice tau represent the matrix Q. tau is modified to contain the
		reflector scales. tau must have length at least min(m,n), and this function
		will panic otherwise.
		
		See Geqrf for a description of the elementary reflectors and orthonormal
		matrix Q. Q is constructed as a product of these elementary reflectors,
		Q = H_{k-1} * ... * H_1 * H_0.
		
		Work is temporary storage, and lwork specifies the usable memory length.
		At minimum, lwork &gt;= m and this function will panic otherwise.
		Gelqf is a blocked LQ factorization, but the block size is limited
		by the temporary space available. If lwork == -1, instead of performing Gelqf,
		the optimal work length will be stored into work[0].</span>

</span></div><div class="anchor value-res" id="name-Gels">	<input type='checkbox' class="fold" id="Gels-fold-content"><label for="Gels-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Gels.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-221">Gels</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, b <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-bool">bool</a></label><span id='Gels-fold-content-docs' class="fold-docs">
<span class="md-text">		Gels finds a minimum-norm solution based on the matrices A and B using the
		QR or LQ factorization. Gels returns false if the matrix
		A is singular, and true if this solution was successfully found.
		
		The minimization problem solved depends on the input parameters.
		
		 1. If m &gt;= n and trans == blas.NoTrans, Gels finds X such that || A*X - B||_2
		    is minimized.
		 2. If m &lt; n and trans == blas.NoTrans, Gels finds the minimum norm solution of
		    A * X = B.
		 3. If m &gt;= n and trans == blas.Trans, Gels finds the minimum norm solution of
		    Aᵀ * X = B.
		 4. If m &lt; n and trans == blas.Trans, Gels finds X such that || A*X - B||_2
		    is minimized.
		
		Note that the least-squares solutions (cases 1 and 3) perform the minimization
		per column of B. This is not the same as finding the minimum-norm matrix.
		
		The matrix A is a general matrix of size m×n and is modified during this call.
		The input matrix B is of size max(m,n)×nrhs, and serves two purposes. On entry,
		the elements of b specify the input matrix B. B has size m×nrhs if
		trans == blas.NoTrans, and n×nrhs if trans == blas.Trans. On exit, the
		leading submatrix of b contains the solution vectors X. If trans == blas.NoTrans,
		this submatrix is of size n×nrhs, and of size m×nrhs otherwise.
		
		Work is temporary storage, and lwork specifies the usable memory length.
		At minimum, lwork &gt;= max(m,n) + max(m,n,nrhs), and this function will panic
		otherwise. A longer work will enable blocked algorithms to be called.
		In the special case that lwork == -1, work[0] will be set to the optimal working
		length.</span>

</span></div><div class="anchor value-res" id="name-Geqrf">	<input type='checkbox' class="fold" id="Geqrf-fold-content"><label for="Geqrf-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Geqrf.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-249">Geqrf</a>(a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, tau, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Geqrf-fold-content-docs' class="fold-docs">
<span class="md-text">		Geqrf computes the QR factorization of the m×n matrix A using a blocked
		algorithm. A is modified to contain the information to construct Q and R.
		The upper triangle of a contains the matrix R. The lower triangular elements
		(not including the diagonal) contain the elementary reflectors. tau is modified
		to contain the reflector scales. tau must have length at least min(m,n), and
		this function will panic otherwise.
		
		The ith elementary reflector can be explicitly constructed by first extracting
		the
		
			v[j] = 0           j &lt; i
			v[j] = 1           j == i
			v[j] = a[j*lda+i]  j &gt; i
		
		and computing H_i = I - tau[i] * v * vᵀ.
		
		The orthonormal matrix Q can be constructed from a product of these elementary
		reflectors, Q = H_0 * H_1 * ... * H_{k-1}, where k = min(m,n).
		
		Work is temporary storage, and lwork specifies the usable memory length.
		At minimum, lwork &gt;= m and this function will panic otherwise.
		Geqrf is a blocked QR factorization, but the block size is limited
		by the temporary space available. If lwork == -1, instead of performing Geqrf,
		the optimal work length will be stored into work[0].</span>

</span></div><div class="anchor value-res" id="name-Gesvd">	<input type='checkbox' class="fold" id="Gesvd-fold-content"><label for="Gesvd-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Gesvd.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-319">Gesvd</a>(jobU, jobVT <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-SVDJob">SVDJob</a>, a, u, vt <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, s, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Gesvd-fold-content-docs' class="fold-docs">
<span class="md-text">		Gesvd computes the singular value decomposition of the input matrix A.
		
		The singular value decomposition is
		
			A = U * Sigma * Vᵀ
		
		where Sigma is an m×n diagonal matrix containing the singular values of A,
		U is an m×m orthogonal matrix and V is an n×n orthogonal matrix. The first
		min(m,n) columns of U and V are the left and right singular vectors of A
		respectively.
		
		jobU and jobVT are options for computing the singular vectors. The behavior
		is as follows
		
			jobU == lapack.SVDAll       All m columns of U are returned in u
			jobU == lapack.SVDStore     The first min(m,n) columns are returned in u
			jobU == lapack.SVDOverwrite The first min(m,n) columns of U are written into a
			jobU == lapack.SVDNone      The columns of U are not computed.
		
		The behavior is the same for jobVT and the rows of Vᵀ. At most one of jobU
		and jobVT can equal lapack.SVDOverwrite, and Gesvd will panic otherwise.
		
		On entry, a contains the data for the m×n matrix A. During the call to Gesvd
		the data is overwritten. On exit, A contains the appropriate singular vectors
		if either job is lapack.SVDOverwrite.
		
		s is a slice of length at least min(m,n) and on exit contains the singular
		values in decreasing order.
		
		u contains the left singular vectors on exit, stored columnwise. If
		jobU == lapack.SVDAll, u is of size m×m. If jobU == lapack.SVDStore u is
		of size m×min(m,n). If jobU == lapack.SVDOverwrite or lapack.SVDNone, u is
		not used.
		
		vt contains the left singular vectors on exit, stored rowwise. If
		jobV == lapack.SVDAll, vt is of size n×m. If jobVT == lapack.SVDStore vt is
		of size min(m,n)×n. If jobVT == lapack.SVDOverwrite or lapack.SVDNone, vt is
		not used.
		
		work is a slice for storing temporary memory, and lwork is the usable size of
		the slice. lwork must be at least max(5*min(m,n), 3*min(m,n)+max(m,n)).
		If lwork == -1, instead of performing Gesvd, the optimal work length will be
		stored into work[0]. Gesvd will panic if the working memory has insufficient
		storage.
		
		Gesvd returns whether the decomposition successfully completed.</span>

</span></div><div class="anchor value-res" id="name-Getrf">	<input type='checkbox' class="fold" id="Getrf-fold-content"><label for="Getrf-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Getrf.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-342">Getrf</a>(a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, ipiv []<a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-bool">bool</a></label><span id='Getrf-fold-content-docs' class="fold-docs">
<span class="md-text">		Getrf computes the LU decomposition of the m×n matrix A.
		The LU decomposition is a factorization of A into
		
			A = P * L * U
		
		where P is a permutation matrix, L is a unit lower triangular matrix, and
		U is a (usually) non-unit upper triangular matrix. On exit, L and U are stored
		in place into a.
		
		ipiv is a permutation vector. It indicates that row i of the matrix was
		changed with ipiv[i]. ipiv must have length at least min(m,n), and will panic
		otherwise. ipiv is zero-indexed.
		
		Getrf is the blocked version of the algorithm.
		
		Getrf returns whether the matrix A is singular. The LU decomposition will
		be computed regardless of the singularity of A, but division by zero
		will occur if the false is returned and the result is used to solve a
		system of equations.</span>

</span></div><div class="anchor value-res" id="name-Getri">	<input type='checkbox' class="fold" id="Getri-fold-content"><label for="Getri-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Getri.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-358">Getri</a>(a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, ipiv []<a href="../../../../builtin.html#name-int">int</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Getri-fold-content-docs' class="fold-docs">
<span class="md-text">		Getri computes the inverse of the matrix A using the LU factorization computed
		by Getrf. On entry, a contains the PLU decomposition of A as computed by
		Getrf and on exit contains the reciprocal of the original matrix.
		
		Getri will not perform the inversion if the matrix is singular, and returns
		a boolean indicating whether the inversion was successful.
		
		Work is temporary storage, and lwork specifies the usable memory length.
		At minimum, lwork &gt;= n and this function will panic otherwise.
		Getri is a blocked inversion, but the block size is limited
		by the temporary space available. If lwork == -1, instead of performing Getri,
		the optimal work length will be stored into work[0].</span>

</span></div><div class="anchor value-res" id="name-Getrs">	<input type='checkbox' class="fold" id="Getrs-fold-content"><label for="Getrs-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Getrs.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-375">Getrs</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, b <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, ipiv []<a href="../../../../builtin.html#name-int">int</a>)</label><span id='Getrs-fold-content-docs' class="fold-docs">
<span class="md-text">		Getrs solves a system of equations using an LU factorization.
		The system of equations solved is
		
			A * X = B   if trans == blas.Trans
			Aᵀ * X = B  if trans == blas.NoTrans
		
		A is a general n×n matrix with stride lda. B is a general matrix of size n×nrhs.
		
		On entry b contains the elements of the matrix B. On exit, b contains the
		elements of X, the solution to the system of equations.
		
		a and ipiv contain the LU factorization of A and the permutation indices as
		computed by Getrf. ipiv is zero-indexed.</span>

</span></div><div class="anchor value-res" id="name-Ggsvd3">	<input type='checkbox' class="fold" id="Ggsvd3-fold-content"><label for="Ggsvd3-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Ggsvd3.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-491">Ggsvd3</a>(jobU, jobV, jobQ <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-GSVDJob">GSVDJob</a>, a, b <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, alpha, beta []<a href="../../../../builtin.html#name-float64">float64</a>, u, v, q <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>, iwork []<a href="../../../../builtin.html#name-int">int</a>) (k, l <a href="../../../../builtin.html#name-int">int</a>, ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Ggsvd3-fold-content-docs' class="fold-docs">
<span class="md-text">		Ggsvd3 computes the generalized singular value decomposition (GSVD)
		of an m×n matrix A and p×n matrix B:
		
			Uᵀ*A*Q = D1*[ 0 R ]
		
			Vᵀ*B*Q = D2*[ 0 R ]
		
		where U, V and Q are orthogonal matrices.
		
		Ggsvd3 returns k and l, the dimensions of the sub-blocks. k+l
		is the effective numerical rank of the (m+p)×n matrix [ Aᵀ Bᵀ ]ᵀ.
		R is a (k+l)×(k+l) nonsingular upper triangular matrix, D1 and
		D2 are m×(k+l) and p×(k+l) diagonal matrices and of the following
		structures, respectively:
		
		If m-k-l &gt;= 0,
		
			                  k  l
			     D1 =     k [ I  0 ]
			              l [ 0  C ]
			          m-k-l [ 0  0 ]
		
			                k  l
			     D2 = l   [ 0  S ]
			          p-l [ 0  0 ]
		
			             n-k-l  k    l
			[ 0 R ] = k [  0   R11  R12 ] k
			          l [  0    0   R22 ] l
		
		where
		
			C = diag( alpha_k, ... , alpha_{k+l} ),
			S = diag( beta_k,  ... , beta_{k+l} ),
			C^2 + S^2 = I.
		
		R is stored in
		
			A[0:k+l, n-k-l:n]
		
		on exit.
		
		If m-k-l &lt; 0,
		
			               k m-k k+l-m
			    D1 =   k [ I  0    0  ]
			         m-k [ 0  C    0  ]
		
			                 k m-k k+l-m
			    D2 =   m-k [ 0  S    0  ]
			         k+l-m [ 0  0    I  ]
			           p-l [ 0  0    0  ]
		
			               n-k-l  k   m-k  k+l-m
			[ 0 R ] =    k [ 0    R11  R12  R13 ]
			           m-k [ 0     0   R22  R23 ]
			         k+l-m [ 0     0    0   R33 ]
		
		where
		
			C = diag( alpha_k, ... , alpha_m ),
			S = diag( beta_k,  ... , beta_m ),
			C^2 + S^2 = I.
		
			R = [ R11 R12 R13 ] is stored in A[1:m, n-k-l+1:n]
			    [  0  R22 R23 ]
		
		and R33 is stored in
		
			B[m-k:l, n+m-k-l:n] on exit.
		
		Ggsvd3 computes C, S, R, and optionally the orthogonal transformation
		matrices U, V and Q.
		
		jobU, jobV and jobQ are options for computing the orthogonal matrices. The behavior
		is as follows
		
			jobU == lapack.GSVDU        Compute orthogonal matrix U
			jobU == lapack.GSVDNone     Do not compute orthogonal matrix.
		
		The behavior is the same for jobV and jobQ with the exception that instead of
		lapack.GSVDU these accept lapack.GSVDV and lapack.GSVDQ respectively.
		The matrices U, V and Q must be m×m, p×p and n×n respectively unless the
		relevant job parameter is lapack.GSVDNone.
		
		alpha and beta must have length n or Ggsvd3 will panic. On exit, alpha and
		beta contain the generalized singular value pairs of A and B
		
			alpha[0:k] = 1,
			beta[0:k]  = 0,
		
		if m-k-l &gt;= 0,
		
			alpha[k:k+l] = diag(C),
			beta[k:k+l]  = diag(S),
		
		if m-k-l &lt; 0,
		
			alpha[k:m]= C, alpha[m:k+l]= 0
			beta[k:m] = S, beta[m:k+l] = 1.
		
		if k+l &lt; n,
		
			alpha[k+l:n] = 0 and
			beta[k+l:n]  = 0.
		
		On exit, iwork contains the permutation required to sort alpha descending.
		
		iwork must have length n, work must have length at least max(1, lwork), and
		lwork must be -1 or greater than n, otherwise Ggsvd3 will panic. If
		lwork is -1, work[0] holds the optimal lwork on return, but Ggsvd3 does
		not perform the GSVD.</span>

</span></div><div class="anchor value-res" id="name-Gtsv">	<input type='checkbox' class="fold" id="Gtsv-fold-content"><label for="Gtsv-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Gtsv.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-512">Gtsv</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, a <a href="#name-Tridiagonal">Tridiagonal</a>, b <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Gtsv-fold-content-docs' class="fold-docs">
<span class="md-text">		Gtsv solves one of the equations
		
			A * X = B   if trans == blas.NoTrans
			Aᵀ * X = B  if trans == blas.Trans or blas.ConjTrans
		
		where A is an n×n tridiagonal matrix. It uses Gaussian elimination with
		partial pivoting.
		
		On entry, a contains the matrix A, on return it will be overwritten.
		
		On entry, b contains the n×nrhs right-hand side matrix B. On return, it will
		be overwritten. If ok is true, it will be overwritten by the solution matrix X.
		
		Gtsv returns whether the solution X has been successfully computed.
		
		Dgtsv is not part of the lapack.Float64 interface and so calls to Gtsv are
		always executed by the Gonum implementation.</span>

</span></div><div class="anchor value-res" id="name-Lagtm">	<input type='checkbox' class="fold" id="Lagtm-fold-content"><label for="Lagtm-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Lagtm.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-529">Lagtm</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, alpha <a href="../../../../builtin.html#name-float64">float64</a>, a <a href="#name-Tridiagonal">Tridiagonal</a>, b <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, beta <a href="../../../../builtin.html#name-float64">float64</a>, c <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>)</label><span id='Lagtm-fold-content-docs' class="fold-docs">
<span class="md-text">		Lagtm performs one of the matrix-matrix operations
		
			C = alpha * A * B + beta * C   if trans == blas.NoTrans
			C = alpha * Aᵀ * B + beta * C  if trans == blas.Trans or blas.ConjTrans
		
		where A is an m×m tridiagonal matrix represented by its diagonals dl, d, du,
		B and C are m×n dense matrices, and alpha and beta are scalars.
		
		Dlagtm is not part of the lapack.Float64 interface and so calls to Lagtm are
		always executed by the Gonum implementation.</span>

</span></div><div class="anchor value-res" id="name-Langb">	<input type='checkbox' class="fold" id="Langb-fold-content"><label for="Langb-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Langb.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-552">Langb</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Band">Band</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Langb-fold-content-docs' class="fold-docs">
<span class="md-text">		Langb returns the given norm of a general m×n band matrix with kl sub-diagonals and
		ku super-diagonals.
		
		Dlangb is not part of the lapack.Float64 interface and so calls to Langb are always
		executed by the Gonum implementation.</span>

</span></div><div class="anchor value-res" id="name-Lange">	<input type='checkbox' class="fold" id="Lange-fold-content"><label for="Lange-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Lange.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-543">Lange</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Lange-fold-content-docs' class="fold-docs">
<span class="md-text">		Lange computes the matrix norm of the general m×n matrix A. The input norm
		specifies the norm computed.
		
			lapack.MaxAbs: the maximum absolute value of an element.
			lapack.MaxColumnSum: the maximum column sum of the absolute values of the entries.
			lapack.MaxRowSum: the maximum row sum of the absolute values of the entries.
			lapack.Frobenius: the square root of the sum of the squares of the entries.
		
		If norm == lapack.MaxColumnSum, work must be of length n, and this function will panic otherwise.
		There are no restrictions on work for the other matrix norms.</span>

</span></div><div class="anchor value-res" id="name-Langt">	<input type='checkbox' class="fold" id="Langt-fold-content"><label for="Langt-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Langt.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-560">Langt</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, a <a href="#name-Tridiagonal">Tridiagonal</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Langt-fold-content-docs' class="fold-docs">
<span class="md-text">		Langt computes the specified norm of an n×n tridiagonal matrix.
		
		Dlangt is not part of the lapack.Float64 interface and so calls to Langt are
		always executed by the Gonum implementation.</span>

</span></div><div class="anchor value-res" id="name-Lansb">	<input type='checkbox' class="fold" id="Lansb-fold-content"><label for="Lansb-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Lansb.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-571">Lansb</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-SymmetricBand">SymmetricBand</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Lansb-fold-content-docs' class="fold-docs">
<span class="md-text">		Lansb computes the specified norm of an n×n symmetric band matrix. If
		norm == lapack.MaxColumnSum or norm == lapack.MaxRowSum, work must have length
		at least n and this function will panic otherwise.
		There are no restrictions on work for the other matrix norms.
		
		Dlansb is not part of the lapack.Float64 interface and so calls to Lansb are always
		executed by the Gonum implementation.</span>

</span></div><div class="anchor value-res" id="name-Lansy">	<input type='checkbox' class="fold" id="Lansy-fold-content"><label for="Lansy-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Lansy.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-579">Lansy</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Symmetric">Symmetric</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Lansy-fold-content-docs' class="fold-docs">
<span class="md-text">		Lansy computes the specified norm of an n×n symmetric matrix. If
		norm == lapack.MaxColumnSum or norm == lapack.MaxRowSum, work must have length
		at least n and this function will panic otherwise.
		There are no restrictions on work for the other matrix norms.</span>

</span></div><div class="anchor value-res" id="name-Lantb">	<input type='checkbox' class="fold" id="Lantb-fold-content"><label for="Lantb-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Lantb.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-594">Lantb</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-TriangularBand">TriangularBand</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Lantb-fold-content-docs' class="fold-docs">
<span class="md-text">		Lantb computes the specified norm of an n×n triangular band matrix A. If
		norm == lapack.MaxColumnSum work must have length at least n and this function
		will panic otherwise. There are no restrictions on work for the other matrix
		norms.</span>

</span></div><div class="anchor value-res" id="name-Lantr">	<input type='checkbox' class="fold" id="Lantr-fold-content"><label for="Lantr-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Lantr.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-586">Lantr</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Triangular">Triangular</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Lantr-fold-content-docs' class="fold-docs">
<span class="md-text">		Lantr computes the specified norm of an m×n trapezoidal matrix A. If
		norm == lapack.MaxColumnSum work must have length at least n and this function
		will panic otherwise. There are no restrictions on work for the other matrix norms.</span>

</span></div><div class="anchor value-res" id="name-Lapmr">	<input type='checkbox' class="fold" id="Lapmr-fold-content"><label for="Lapmr-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Lapmr.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-610">Lapmr</a>(forward <a href="../../../../builtin.html#name-bool">bool</a>, x <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, k []<a href="../../../../builtin.html#name-int">int</a>)</label><span id='Lapmr-fold-content-docs' class="fold-docs">
<span class="md-text">		Lapmr rearranges the rows of the m×n matrix X as specified by the permutation
		k[0],k[1],...,k[m-1] of the integers 0,...,m-1.
		
		If forward is true, a forward permutation is applied:
		
			X[k[i],0:n] is moved to X[i,0:n] for i=0,1,...,m-1.
		
		If forward is false, a backward permutation is applied:
		
			X[i,0:n] is moved to X[k[i],0:n] for i=0,1,...,m-1.
		
		k must have length m, otherwise Lapmr will panic.</span>

</span></div><div class="anchor value-res" id="name-Lapmt">	<input type='checkbox' class="fold" id="Lapmt-fold-content"><label for="Lapmt-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Lapmt.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-626">Lapmt</a>(forward <a href="../../../../builtin.html#name-bool">bool</a>, x <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, k []<a href="../../../../builtin.html#name-int">int</a>)</label><span id='Lapmt-fold-content-docs' class="fold-docs">
<span class="md-text">		Lapmt rearranges the columns of the m×n matrix X as specified by the
		permutation k_0, k_1, ..., k_{n-1} of the integers 0, ..., n-1.
		
		If forward is true a forward permutation is performed:
		
			X[0:m, k[j]] is moved to X[0:m, j] for j = 0, 1, ..., n-1.
		
		otherwise a backward permutation is performed:
		
			X[0:m, j] is moved to X[0:m, k[j]] for j = 0, 1, ..., n-1.
		
		k must have length n, otherwise Lapmt will panic. k is zero-indexed.</span>

</span></div><div class="anchor value-res" id="name-Ormlq">	<input type='checkbox' class="fold" id="Ormlq-fold-content"><label for="Ormlq-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Ormlq.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-650">Ormlq</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, tau []<a href="../../../../builtin.html#name-float64">float64</a>, c <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Ormlq-fold-content-docs' class="fold-docs">
<span class="md-text">		Ormlq multiplies the matrix C by the othogonal matrix Q defined by
		A and tau. A and tau are as returned from Gelqf.
		
			C = Q * C   if side == blas.Left and trans == blas.NoTrans
			C = Qᵀ * C  if side == blas.Left and trans == blas.Trans
			C = C * Q   if side == blas.Right and trans == blas.NoTrans
			C = C * Qᵀ  if side == blas.Right and trans == blas.Trans
		
		If side == blas.Left, A is a matrix of side k×m, and if side == blas.Right
		A is of size k×n. This uses a blocked algorithm.
		
		Work is temporary storage, and lwork specifies the usable memory length.
		At minimum, lwork &gt;= m if side == blas.Left and lwork &gt;= n if side == blas.Right,
		and this function will panic otherwise.
		Ormlq uses a block algorithm, but the block size is limited
		by the temporary space available. If lwork == -1, instead of performing Ormlq,
		the optimal work length will be stored into work[0].
		
		Tau contains the Householder scales and must have length at least k, and
		this function will panic otherwise.</span>

</span></div><div class="anchor value-res" id="name-Ormqr">	<input type='checkbox' class="fold" id="Ormqr-fold-content"><label for="Ormqr-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Ormqr.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-684">Ormqr</a>(side <a href="../blas.html">blas</a>.<a href="../blas.html#name-Side">Side</a>, trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, tau []<a href="../../../../builtin.html#name-float64">float64</a>, c <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>)</label><span id='Ormqr-fold-content-docs' class="fold-docs">
<span class="md-text">		Ormqr multiplies an m×n matrix C by an orthogonal matrix Q as
		
			C = Q * C   if side == blas.Left  and trans == blas.NoTrans,
			C = Qᵀ * C  if side == blas.Left  and trans == blas.Trans,
			C = C * Q   if side == blas.Right and trans == blas.NoTrans,
			C = C * Qᵀ  if side == blas.Right and trans == blas.Trans,
		
		where Q is defined as the product of k elementary reflectors
		
			Q = H_0 * H_1 * ... * H_{k-1}.
		
		If side == blas.Left, A is an m×k matrix and 0 &lt;= k &lt;= m.
		If side == blas.Right, A is an n×k matrix and 0 &lt;= k &lt;= n.
		The ith column of A contains the vector which defines the elementary
		reflector H_i and tau[i] contains its scalar factor. tau must have length k
		and Ormqr will panic otherwise. Geqrf returns A and tau in the required
		form.
		
		work must have length at least max(1,lwork), and lwork must be at least n if
		side == blas.Left and at least m if side == blas.Right, otherwise Ormqr will
		panic.
		
		work is temporary storage, and lwork specifies the usable memory length. At
		minimum, lwork &gt;= m if side == blas.Left and lwork &gt;= n if side ==
		blas.Right, and this function will panic otherwise. Larger values of lwork
		will generally give better performance. On return, work[0] will contain the
		optimal value of lwork.
		
		If lwork is -1, instead of performing Ormqr, the optimal workspace size will
		be stored into work[0].</span>

</span></div><div class="anchor value-res" id="name-Pbcon">	<input type='checkbox' class="fold" id="Pbcon-fold-content"><label for="Pbcon-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Pbcon.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-100">Pbcon</a>(a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-SymmetricBand">SymmetricBand</a>, anorm <a href="../../../../builtin.html#name-float64">float64</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, iwork []<a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Pbcon-fold-content-docs' class="fold-docs">
<span class="md-text">		Pbcon returns an estimate of the reciprocal of the condition number (in the
		1-norm) of an n×n symmetric positive definite band matrix using the Cholesky
		factorization
		
			A = Uᵀ*U  if uplo == blas.Upper
			A = L*Lᵀ  if uplo == blas.Lower
		
		computed by Pbtrf. The estimate is obtained for norm(inv(A)), and the
		reciprocal of the condition number is computed as
		
			rcond = 1 / (anorm * norm(inv(A))).
		
		The length of work must be at least 3*n and the length of iwork must be at
		least n.</span>

</span></div><div class="anchor value-res" id="name-Pbtrf">	<input type='checkbox' class="fold" id="Pbtrf-fold-content"><label for="Pbtrf-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Pbtrf.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-115">Pbtrf</a>(a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-SymmetricBand">SymmetricBand</a>) (t <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-TriangularBand">TriangularBand</a>, ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Pbtrf-fold-content-docs' class="fold-docs">
<span class="md-text">		Pbtrf computes the Cholesky factorization of an n×n symmetric positive
		definite band matrix
		
			A = Uᵀ * U  if a.Uplo == blas.Upper
			A = L * Lᵀ  if a.Uplo == blas.Lower
		
		where U and L are upper, respectively lower, triangular band matrices.
		
		The triangular matrix U or L is returned in t, and the underlying data
		between a and t is shared. The returned bool indicates whether A is positive
		definite and the factorization could be finished.</span>

</span></div><div class="anchor value-res" id="name-Pbtrs">	<input type='checkbox' class="fold" id="Pbtrs-fold-content"><label for="Pbtrs-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Pbtrs.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-136">Pbtrs</a>(t <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-TriangularBand">TriangularBand</a>, b <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>)</label><span id='Pbtrs-fold-content-docs' class="fold-docs">
<span class="md-text">		Pbtrs solves a system of linear equations A*X = B with an n×n symmetric
		positive definite band matrix A using the Cholesky factorization
		
			A = Uᵀ * U  if t.Uplo == blas.Upper
			A = L * Lᵀ  if t.Uplo == blas.Lower
		
		t contains the corresponding triangular factor as returned by Pbtrf.
		
		On entry, b contains the right hand side matrix B. On return, it is
		overwritten with the solution matrix X.</span>

</span></div><div class="anchor value-res" id="name-Pocon">	<input type='checkbox' class="fold" id="Pocon-fold-content"><label for="Pocon-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Pocon.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-697">Pocon</a>(a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Symmetric">Symmetric</a>, anorm <a href="../../../../builtin.html#name-float64">float64</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, iwork []<a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Pocon-fold-content-docs' class="fold-docs">
<span class="md-text">		Pocon estimates the reciprocal of the condition number of a positive-definite
		matrix A given the Cholesky decomposition of A. The condition number computed
		is based on the 1-norm and the ∞-norm.
		
		anorm is the 1-norm and the ∞-norm of the original matrix A.
		
		work is a temporary data slice of length at least 3*n and Pocon will panic otherwise.
		
		iwork is a temporary data slice of length at least n and Pocon will panic otherwise.</span>

</span></div><div class="anchor value-res" id="name-Potrf">	<input type='checkbox' class="fold" id="Potrf-fold-content"><label for="Potrf-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Potrf.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-47">Potrf</a>(a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Symmetric">Symmetric</a>) (t <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Triangular">Triangular</a>, ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Potrf-fold-content-docs' class="fold-docs">
<span class="md-text">		Potrf computes the Cholesky factorization of a.
		The factorization has the form
		
			A = Uᵀ * U  if a.Uplo == blas.Upper, or
			A = L * Lᵀ  if a.Uplo == blas.Lower,
		
		where U is an upper triangular matrix and L is lower triangular.
		The triangular matrix is returned in t, and the underlying data between
		a and t is shared. The returned bool indicates whether a is positive
		definite and the factorization could be finished.</span>

</span></div><div class="anchor value-res" id="name-Potri">	<input type='checkbox' class="fold" id="Potri-fold-content"><label for="Potri-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Potri.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-68">Potri</a>(t <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Triangular">Triangular</a>) (a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Symmetric">Symmetric</a>, ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Potri-fold-content-docs' class="fold-docs">
<span class="md-text">		Potri computes the inverse of a real symmetric positive definite matrix A
		using its Cholesky factorization.
		
		On entry, t contains the triangular factor U or L from the Cholesky
		factorization A = Uᵀ*U or A = L*Lᵀ, as computed by Potrf.
		
		On return, the upper or lower triangle of the (symmetric) inverse of A is
		stored in t, overwriting the input factor U or L, and also returned in a. The
		underlying data between a and t is shared.
		
		The returned bool indicates whether the inverse was computed successfully.</span>

</span></div><div class="anchor value-res" id="name-Potrs">	<input type='checkbox' class="fold" id="Potrs-fold-content"><label for="Potrs-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Potrs.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-82">Potrs</a>(t <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Triangular">Triangular</a>, b <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>)</label><span id='Potrs-fold-content-docs' class="fold-docs">
<span class="md-text">		Potrs solves a system of n linear equations A*X = B where A is an n×n
		symmetric positive definite matrix and B is an n×nrhs matrix, using the
		Cholesky factorization A = Uᵀ*U or A = L*Lᵀ. t contains the corresponding
		triangular factor as returned by Potrf. On entry, B contains the right-hand
		side matrix B, on return it contains the solution matrix X.</span>

</span></div><div class="anchor value-res" id="name-Pstrf">	<input type='checkbox' class="fold" id="Pstrf-fold-content"><label for="Pstrf-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Pstrf.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-166">Pstrf</a>(a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Symmetric">Symmetric</a>, piv []<a href="../../../../builtin.html#name-int">int</a>, tol <a href="../../../../builtin.html#name-float64">float64</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>) (t <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Triangular">Triangular</a>, rank <a href="../../../../builtin.html#name-int">int</a>, ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Pstrf-fold-content-docs' class="fold-docs">
<span class="md-text">		Pstrf computes the Cholesky factorization with complete pivoting of an n×n
		symmetric positive semidefinite matrix A.
		
		The factorization has the form
		
			Pᵀ * A * P = Uᵀ * U ,  if a.Uplo = blas.Upper,
			Pᵀ * A * P = L  * Lᵀ,  if a.Uplo = blas.Lower,
		
		where U is an upper triangular matrix, L is lower triangular, and P is a
		permutation matrix.
		
		tol is a user-defined tolerance. The algorithm terminates if the pivot is
		less than or equal to tol. If tol is negative, then n*eps*max(A[k,k]) will be
		used instead.
		
		The triangular factor U or L from the Cholesky factorization is returned in t
		and the underlying data between a and t is shared. P is stored on return in
		vector piv such that P[piv[k],k] = 1.
		
		Pstrf returns the computed rank of A and whether the factorization can be
		used to solve a system. Pstrf does not attempt to check that A is positive
		semi-definite, so if ok is false, the matrix A is either rank deficient or is
		not positive semidefinite.
		
		The length of piv must be n and the length of work must be at least 2*n,
		otherwise Pstrf will panic.</span>

</span></div><div class="anchor value-res" id="name-Syev">	<input type='checkbox' class="fold" id="Syev-fold-content"><label for="Syev-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Syev.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-716">Syev</a>(jobz <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-EVJob">EVJob</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Symmetric">Symmetric</a>, w, work []<a href="../../../../builtin.html#name-float64">float64</a>, lwork <a href="../../../../builtin.html#name-int">int</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Syev-fold-content-docs' class="fold-docs">
<span class="md-text">		Syev computes all eigenvalues and, optionally, the eigenvectors of a real
		symmetric matrix A.
		
		w contains the eigenvalues in ascending order upon return. w must have length
		at least n, and Syev will panic otherwise.
		
		On entry, a contains the elements of the symmetric matrix A in the triangular
		portion specified by uplo. If jobz == lapack.EVCompute, a contains the
		orthonormal eigenvectors of A on exit, otherwise jobz must be lapack.EVNone
		and on exit the specified triangular region is overwritten.
		
		Work is temporary storage, and lwork specifies the usable memory length. At minimum,
		lwork &gt;= 3*n-1, and Syev will panic otherwise. The amount of blocking is
		limited by the usable length. If lwork == -1, instead of computing Syev the
		optimal work length is stored into work[0].</span>

</span></div><div class="anchor value-res" id="name-Tbtrs">	<input type='checkbox' class="fold" id="Tbtrs-fold-content"><label for="Tbtrs-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Tbtrs.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-729">Tbtrs</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-TriangularBand">TriangularBand</a>, b <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Tbtrs-fold-content-docs' class="fold-docs">
<span class="md-text">		Tbtrs solves a triangular system of the form
		
			A * X = B   if trans == blas.NoTrans
			Aᵀ * X = B  if trans == blas.Trans or blas.ConjTrans
		
		where A is an n×n triangular band matrix, and B is an n×nrhs matrix.
		
		Tbtrs returns whether A is non-singular. If A is singular, no solutions X
		are computed.</span>

</span></div><div class="anchor value-res" id="name-Trcon">	<input type='checkbox' class="fold" id="Trcon-fold-content"><label for="Trcon-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Trcon.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-739">Trcon</a>(norm <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-MatrixNorm">MatrixNorm</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Triangular">Triangular</a>, work []<a href="../../../../builtin.html#name-float64">float64</a>, iwork []<a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-float64">float64</a></label><span id='Trcon-fold-content-docs' class="fold-docs">
<span class="md-text">		Trcon estimates the reciprocal of the condition number of a triangular matrix A.
		The condition number computed may be based on the 1-norm or the ∞-norm.
		
		work is a temporary data slice of length at least 3*n and Trcon will panic otherwise.
		
		iwork is a temporary data slice of length at least n and Trcon will panic otherwise.</span>

</span></div><div class="anchor value-res" id="name-Trtri">	<input type='checkbox' class="fold" id="Trtri-fold-content"><label for="Trtri-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Trtri.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-748">Trtri</a>(a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Triangular">Triangular</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Trtri-fold-content-docs' class="fold-docs">
<span class="md-text">		Trtri computes the inverse of a triangular matrix, storing the result in place
		into a.
		
		Trtri will not perform the inversion if the matrix is singular, and returns
		a boolean indicating whether the inversion was successful.</span>

</span></div><div class="anchor value-res" id="name-Trtrs">	<input type='checkbox' class="fold" id="Trtrs-fold-content"><label for="Trtrs-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Trtrs.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-754">Trtrs</a>(trans <a href="../blas.html">blas</a>.<a href="../blas.html#name-Transpose">Transpose</a>, a <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-Triangular">Triangular</a>, b <a href="../blas/blas64.html">blas64</a>.<a href="../blas/blas64.html#name-General">General</a>) (ok <a href="../../../../builtin.html#name-bool">bool</a>)</label><span id='Trtrs-fold-content-docs' class="fold-docs">
<span class="md-text">		Trtrs solves a triangular system of the form A * X = B or Aᵀ * X = B. Trtrs
		returns whether the solve completed successfully. If A is singular, no solve is performed.</span>

</span></div><div class="anchor value-res" id="name-Use">	<input type='checkbox' class="fold" id="Use-fold-content"><label for="Use-fold-content"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..Use.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-18">Use</a>(l <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-Float64">Float64</a>)</label><span id='Use-fold-content-docs' class="fold-docs">
<span class="md-text">		Use sets the LAPACK float64 implementation to be used by subsequent BLAS calls.
		The default implementation is native.Implementation.</span>

</span></div>	<input type='checkbox' class="showhide" id="unexported-functions-showhide"><i><label for="unexported-functions-showhide" class="show-inline">/* one unexported ... */</label><label for="unexported-functions-showhide" class="hide-inline">/* one unexported: */</label></i><div class="anchor value-res hidden" id="name-max"><i>	<span class="nodocs"> <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..max^9baf3.html">func</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-30">max</a>(a, b <a href="../../../../builtin.html#name-int">int</a>) <a href="../../../../builtin.html#name-int">int</a></span></i></div></div>
<div id="exported-variables"><span class="title">Package-Level Variables<span class="title-stat"><i> (only one, which is unexported)</i></span></span>

	<input type='checkbox' class="showhide" id="unexported-variables-showhide"><i><label for="unexported-variables-showhide" class="show-inline">/* one unexported ... */</label><label for="unexported-variables-showhide" class="hide-inline">/* one unexported: */</label></i><div class="anchor value-res hidden" id="name-lapack64"><i>	<span class="nodocs">  <a href="../../../../../use/gonum.org/v1/gonum/lapack/lapack64..lapack64^8db11.html">var</a> <a href="../../../../../src/gonum.org/v1/gonum/lapack/lapack64/lapack64.go.html#line-14">lapack64</a> <a href="../lapack.html">lapack</a>.<a href="../lapack.html#name-Float64">Float64</a></span></i></div></div></code></pre><pre id="footer">
<table><tr><td><img src="../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.7</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>