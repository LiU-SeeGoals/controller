<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: doc.go in package gonum.org/v1/gonum/mat</title>
<link href="../../../../../css/auto-v0.6.7.css" rel="stylesheet">
<script src="../../../../../jvs/golds-v0.6.7.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	doc.go

<span class="title">Belonging Package</span>
	<a href="../../../../../pkg/gonum.org/v1/gonum/mat.html">gonum.org/v1/gonum/mat</a>
</code></pre>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code><span class="comment">// Copyright ©2015 The Gonum Authors. All rights reserved.</span></code></span>
<span class="codeline" id="line-2"><code><span class="comment">// Use of this source code is governed by a BSD-style</span></code></span>
<span class="codeline" id="line-3"><code><span class="comment">// license that can be found in the LICENSE file.</span></code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code><span class="comment">// Package mat provides implementations of float64 and complex128 matrix</span></code></span>
<span class="codeline" id="line-6"><code><span class="comment">// structures and linear algebra operations on them.</span></code></span>
<span class="codeline" id="line-7"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-8"><code><span class="comment">// # Overview</span></code></span>
<span class="codeline" id="line-9"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-10"><code><span class="comment">// This section provides a quick overview of the mat package. The following</span></code></span>
<span class="codeline" id="line-11"><code><span class="comment">// sections provide more in depth commentary.</span></code></span>
<span class="codeline" id="line-12"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-13"><code><span class="comment">// mat provides:</span></code></span>
<span class="codeline" id="line-14"><code><span class="comment">//   - Interfaces for Matrix classes (Matrix, Symmetric, Triangular)</span></code></span>
<span class="codeline" id="line-15"><code><span class="comment">//   - Concrete implementations (Dense, SymDense, TriDense, VecDense)</span></code></span>
<span class="codeline" id="line-16"><code><span class="comment">//   - Methods and functions for using matrix data (Add, Trace, SymRankOne)</span></code></span>
<span class="codeline" id="line-17"><code><span class="comment">//   - Types for constructing and using matrix factorizations (QR, LU, etc.)</span></code></span>
<span class="codeline" id="line-18"><code><span class="comment">//   - The complementary types for complex matrices, CMatrix, CSymDense, etc.</span></code></span>
<span class="codeline" id="line-19"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-20"><code><span class="comment">// In the documentation below, we use "matrix" as a short-hand for all of</span></code></span>
<span class="codeline" id="line-21"><code><span class="comment">// the FooDense types implemented in this package. We use "Matrix" to</span></code></span>
<span class="codeline" id="line-22"><code><span class="comment">// refer to the Matrix interface.</span></code></span>
<span class="codeline" id="line-23"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-24"><code><span class="comment">// A matrix may be constructed through the corresponding New function. If no</span></code></span>
<span class="codeline" id="line-25"><code><span class="comment">// backing array is provided the matrix will be initialized to all zeros.</span></code></span>
<span class="codeline" id="line-26"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-27"><code><span class="comment">//	// Allocate a zeroed real matrix of size 3×5</span></code></span>
<span class="codeline" id="line-28"><code><span class="comment">//	zero := mat.NewDense(3, 5, nil)</span></code></span>
<span class="codeline" id="line-29"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-30"><code><span class="comment">// If a backing data slice is provided, the matrix will have those elements.</span></code></span>
<span class="codeline" id="line-31"><code><span class="comment">// All matrices are stored in row-major format and users should consider</span></code></span>
<span class="codeline" id="line-32"><code><span class="comment">// this when expressing matrix arithmetic to ensure optimal performance.</span></code></span>
<span class="codeline" id="line-33"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-34"><code><span class="comment">//	// Generate a 6×6 matrix of random values.</span></code></span>
<span class="codeline" id="line-35"><code><span class="comment">//	data := make([]float64, 36)</span></code></span>
<span class="codeline" id="line-36"><code><span class="comment">//	for i := range data {</span></code></span>
<span class="codeline" id="line-37"><code><span class="comment">//		data[i] = rand.NormFloat64()</span></code></span>
<span class="codeline" id="line-38"><code><span class="comment">//	}</span></code></span>
<span class="codeline" id="line-39"><code><span class="comment">//	a := mat.NewDense(6, 6, data)</span></code></span>
<span class="codeline" id="line-40"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-41"><code><span class="comment">// Operations involving matrix data are implemented as functions when the values</span></code></span>
<span class="codeline" id="line-42"><code><span class="comment">// of the matrix remain unchanged</span></code></span>
<span class="codeline" id="line-43"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-44"><code><span class="comment">//	tr := mat.Trace(a)</span></code></span>
<span class="codeline" id="line-45"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-46"><code><span class="comment">// and are implemented as methods when the operation modifies the receiver.</span></code></span>
<span class="codeline" id="line-47"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-48"><code><span class="comment">//	zero.Copy(a)</span></code></span>
<span class="codeline" id="line-49"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-50"><code><span class="comment">// Note that the input arguments to most functions and methods are interfaces</span></code></span>
<span class="codeline" id="line-51"><code><span class="comment">// rather than concrete types `func Trace(Matrix)` rather than</span></code></span>
<span class="codeline" id="line-52"><code><span class="comment">// `func Trace(*Dense)` allowing flexible use of internal and external</span></code></span>
<span class="codeline" id="line-53"><code><span class="comment">// Matrix types.</span></code></span>
<span class="codeline" id="line-54"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-55"><code><span class="comment">// When a matrix is the destination or receiver for a function or method,</span></code></span>
<span class="codeline" id="line-56"><code><span class="comment">// the operation will panic if the matrix is not the correct size.</span></code></span>
<span class="codeline" id="line-57"><code><span class="comment">// An exception to this is when the destination is empty (see below).</span></code></span>
<span class="codeline" id="line-58"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-59"><code><span class="comment">// # Empty matrix</span></code></span>
<span class="codeline" id="line-60"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-61"><code><span class="comment">// An empty matrix is one that has zero size. Empty matrices are used to allow</span></code></span>
<span class="codeline" id="line-62"><code><span class="comment">// the destination of a matrix operation to assume the correct size automatically.</span></code></span>
<span class="codeline" id="line-63"><code><span class="comment">// This operation will re-use the backing data, if available, or will allocate</span></code></span>
<span class="codeline" id="line-64"><code><span class="comment">// new data if necessary. The IsEmpty method returns whether the given matrix</span></code></span>
<span class="codeline" id="line-65"><code><span class="comment">// is empty. The zero-value of a matrix is empty, and is useful for easily</span></code></span>
<span class="codeline" id="line-66"><code><span class="comment">// getting the result of matrix operations.</span></code></span>
<span class="codeline" id="line-67"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-68"><code><span class="comment">//	var c mat.Dense // construct a new zero-value matrix</span></code></span>
<span class="codeline" id="line-69"><code><span class="comment">//	c.Mul(a, a)     // c is automatically adjusted to be the right size</span></code></span>
<span class="codeline" id="line-70"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-71"><code><span class="comment">// The Reset method can be used to revert a matrix to an empty matrix.</span></code></span>
<span class="codeline" id="line-72"><code><span class="comment">// Reset should not be used when multiple different matrices share the same backing</span></code></span>
<span class="codeline" id="line-73"><code><span class="comment">// data slice. This can cause unexpected data modifications after being resized.</span></code></span>
<span class="codeline" id="line-74"><code><span class="comment">// An empty matrix can not be sliced even if it does have an adequately sized</span></code></span>
<span class="codeline" id="line-75"><code><span class="comment">// backing data slice, but can be expanded using its Grow method if it exists.</span></code></span>
<span class="codeline" id="line-76"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-77"><code><span class="comment">// # The Matrix Interfaces</span></code></span>
<span class="codeline" id="line-78"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-79"><code><span class="comment">// The Matrix interface is the common link between the concrete types of real</span></code></span>
<span class="codeline" id="line-80"><code><span class="comment">// matrices. The Matrix interface is defined by three functions: Dims, which</span></code></span>
<span class="codeline" id="line-81"><code><span class="comment">// returns the dimensions of the Matrix, At, which returns the element in the</span></code></span>
<span class="codeline" id="line-82"><code><span class="comment">// specified location, and T for returning a Transpose (discussed later). All of</span></code></span>
<span class="codeline" id="line-83"><code><span class="comment">// the matrix types can perform these behaviors and so implement the interface.</span></code></span>
<span class="codeline" id="line-84"><code><span class="comment">// Methods and functions are designed to use this interface, so in particular the method</span></code></span>
<span class="codeline" id="line-85"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-86"><code><span class="comment">//	func (m *Dense) Mul(a, b Matrix)</span></code></span>
<span class="codeline" id="line-87"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-88"><code><span class="comment">// constructs a *Dense from the result of a multiplication with any Matrix types,</span></code></span>
<span class="codeline" id="line-89"><code><span class="comment">// not just *Dense. Where more restrictive requirements must be met, there are also</span></code></span>
<span class="codeline" id="line-90"><code><span class="comment">// additional interfaces like Symmetric and Triangular. For example, in</span></code></span>
<span class="codeline" id="line-91"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-92"><code><span class="comment">//	func (s *SymDense) AddSym(a, b Symmetric)</span></code></span>
<span class="codeline" id="line-93"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-94"><code><span class="comment">// the Symmetric interface guarantees a symmetric result.</span></code></span>
<span class="codeline" id="line-95"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-96"><code><span class="comment">// The CMatrix interface plays the same role for complex matrices. The difference</span></code></span>
<span class="codeline" id="line-97"><code><span class="comment">// is that the CMatrix type has the H method instead T, for returning the conjugate</span></code></span>
<span class="codeline" id="line-98"><code><span class="comment">// transpose.</span></code></span>
<span class="codeline" id="line-99"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-100"><code><span class="comment">// (Conjugate) Transposes</span></code></span>
<span class="codeline" id="line-101"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-102"><code><span class="comment">// The T method is used for transposition on real matrices, and H is used for</span></code></span>
<span class="codeline" id="line-103"><code><span class="comment">// conjugate transposition on complex matrices. For example, c.Mul(a.T(), b) computes</span></code></span>
<span class="codeline" id="line-104"><code><span class="comment">// c = aᵀ * b. The mat types implement this method implicitly —</span></code></span>
<span class="codeline" id="line-105"><code><span class="comment">// see the Transpose and Conjugate types for more details. Note that some</span></code></span>
<span class="codeline" id="line-106"><code><span class="comment">// operations have a transpose as part of their definition, as in *SymDense.SymOuterK.</span></code></span>
<span class="codeline" id="line-107"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-108"><code><span class="comment">// # Matrix Factorization</span></code></span>
<span class="codeline" id="line-109"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-110"><code><span class="comment">// Matrix factorizations, such as the LU decomposition, typically have their own</span></code></span>
<span class="codeline" id="line-111"><code><span class="comment">// specific data storage, and so are each implemented as a specific type. The</span></code></span>
<span class="codeline" id="line-112"><code><span class="comment">// factorization can be computed through a call to Factorize</span></code></span>
<span class="codeline" id="line-113"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-114"><code><span class="comment">//	var lu mat.LU</span></code></span>
<span class="codeline" id="line-115"><code><span class="comment">//	lu.Factorize(a)</span></code></span>
<span class="codeline" id="line-116"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-117"><code><span class="comment">// The elements of the factorization can be extracted through methods on the</span></code></span>
<span class="codeline" id="line-118"><code><span class="comment">// factorized type, for example *LU.UTo. The factorization types can also be used</span></code></span>
<span class="codeline" id="line-119"><code><span class="comment">// directly, as in *Cholesky.SolveTo. Some factorizations can be updated directly,</span></code></span>
<span class="codeline" id="line-120"><code><span class="comment">// without needing to update the original matrix and refactorize, for example with</span></code></span>
<span class="codeline" id="line-121"><code><span class="comment">// *LU.RankOne.</span></code></span>
<span class="codeline" id="line-122"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-123"><code><span class="comment">// # BLAS and LAPACK</span></code></span>
<span class="codeline" id="line-124"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-125"><code><span class="comment">// BLAS and LAPACK are the standard APIs for linear algebra routines. Many</span></code></span>
<span class="codeline" id="line-126"><code><span class="comment">// operations in mat are implemented using calls to the wrapper functions</span></code></span>
<span class="codeline" id="line-127"><code><span class="comment">// in gonum/blas/blas64 and gonum/lapack/lapack64 and their complex equivalents.</span></code></span>
<span class="codeline" id="line-128"><code><span class="comment">// By default, blas64 and lapack64 call the native Go implementations of the</span></code></span>
<span class="codeline" id="line-129"><code><span class="comment">// routines. Alternatively, it is possible to use C-based implementations of the</span></code></span>
<span class="codeline" id="line-130"><code><span class="comment">// APIs through the respective cgo packages and the wrapper packages' "Use"</span></code></span>
<span class="codeline" id="line-131"><code><span class="comment">// functions. The Go implementation of LAPACK makes calls through blas64, so if</span></code></span>
<span class="codeline" id="line-132"><code><span class="comment">// a cgo BLAS implementation is registered, the lapack64 calls will be partially</span></code></span>
<span class="codeline" id="line-133"><code><span class="comment">// executed in Go and partially executed in C.</span></code></span>
<span class="codeline" id="line-134"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-135"><code><span class="comment">// # Type Switching</span></code></span>
<span class="codeline" id="line-136"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-137"><code><span class="comment">// The Matrix abstraction enables efficiency as well as interoperability. Go's</span></code></span>
<span class="codeline" id="line-138"><code><span class="comment">// type reflection capabilities are used to choose the most efficient routine</span></code></span>
<span class="codeline" id="line-139"><code><span class="comment">// given the specific concrete types. For example, in</span></code></span>
<span class="codeline" id="line-140"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-141"><code><span class="comment">//	c.Mul(a, b)</span></code></span>
<span class="codeline" id="line-142"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-143"><code><span class="comment">// if a and b both implement RawMatrixer, that is, they can be represented as a</span></code></span>
<span class="codeline" id="line-144"><code><span class="comment">// blas64.General, blas64.Gemm (general matrix multiplication) is called, while</span></code></span>
<span class="codeline" id="line-145"><code><span class="comment">// instead if b is a RawSymmetricer blas64.Symm is used (general-symmetric</span></code></span>
<span class="codeline" id="line-146"><code><span class="comment">// multiplication), and if b is a *VecDense blas64.Gemv is used.</span></code></span>
<span class="codeline" id="line-147"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-148"><code><span class="comment">// There are many possible type combinations and special cases. No specific guarantees</span></code></span>
<span class="codeline" id="line-149"><code><span class="comment">// are made about the performance of any method, and in particular, note that an</span></code></span>
<span class="codeline" id="line-150"><code><span class="comment">// abstract matrix type may be copied into a concrete type of the corresponding</span></code></span>
<span class="codeline" id="line-151"><code><span class="comment">// value. If there are specific special cases that are needed, please submit a</span></code></span>
<span class="codeline" id="line-152"><code><span class="comment">// pull-request or file an issue.</span></code></span>
<span class="codeline" id="line-153"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-154"><code><span class="comment">// # Invariants</span></code></span>
<span class="codeline" id="line-155"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-156"><code><span class="comment">// Matrix input arguments to package functions are never directly modified. If an</span></code></span>
<span class="codeline" id="line-157"><code><span class="comment">// operation changes Matrix data, the mutated matrix will be the receiver of a</span></code></span>
<span class="codeline" id="line-158"><code><span class="comment">// method, or will be the first, dst, argument to a method named with a To suffix.</span></code></span>
<span class="codeline" id="line-159"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-160"><code><span class="comment">// For convenience, a matrix may be used as both a receiver and as an input, e.g.</span></code></span>
<span class="codeline" id="line-161"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-162"><code><span class="comment">//	a.Pow(a, 6)</span></code></span>
<span class="codeline" id="line-163"><code><span class="comment">//	v.SolveVec(a.T(), v)</span></code></span>
<span class="codeline" id="line-164"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-165"><code><span class="comment">// though in many cases this will cause an allocation (see Element Aliasing).</span></code></span>
<span class="codeline" id="line-166"><code><span class="comment">// An exception to this rule is Copy, which does not allow a.Copy(a.T()).</span></code></span>
<span class="codeline" id="line-167"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-168"><code><span class="comment">// # Element Aliasing</span></code></span>
<span class="codeline" id="line-169"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-170"><code><span class="comment">// Most methods in mat modify receiver data. It is forbidden for the modified</span></code></span>
<span class="codeline" id="line-171"><code><span class="comment">// data region of the receiver to overlap the used data area of the input</span></code></span>
<span class="codeline" id="line-172"><code><span class="comment">// arguments. The exception to this rule is when the method receiver is equal to one</span></code></span>
<span class="codeline" id="line-173"><code><span class="comment">// of the input arguments, as in the a.Pow(a, 6) call above, or its implicit transpose.</span></code></span>
<span class="codeline" id="line-174"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-175"><code><span class="comment">// This prohibition is to help avoid subtle mistakes when the method needs to read</span></code></span>
<span class="codeline" id="line-176"><code><span class="comment">// from and write to the same data region. There are ways to make mistakes using the</span></code></span>
<span class="codeline" id="line-177"><code><span class="comment">// mat API, and mat functions will detect and complain about those.</span></code></span>
<span class="codeline" id="line-178"><code><span class="comment">// There are many ways to make mistakes by excursion from the mat API via</span></code></span>
<span class="codeline" id="line-179"><code><span class="comment">// interaction with raw matrix values.</span></code></span>
<span class="codeline" id="line-180"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-181"><code><span class="comment">// If you need to read the rest of this section to understand the behavior of</span></code></span>
<span class="codeline" id="line-182"><code><span class="comment">// your program, you are being clever. Don't be clever. If you must be clever,</span></code></span>
<span class="codeline" id="line-183"><code><span class="comment">// blas64 and lapack64 may be used to call the behavior directly.</span></code></span>
<span class="codeline" id="line-184"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-185"><code><span class="comment">// mat will use the following rules to detect overlap between the receiver and one</span></code></span>
<span class="codeline" id="line-186"><code><span class="comment">// of the inputs:</span></code></span>
<span class="codeline" id="line-187"><code><span class="comment">//   - the input implements one of the Raw methods, and</span></code></span>
<span class="codeline" id="line-188"><code><span class="comment">//   - the address ranges of the backing data slices overlap, and</span></code></span>
<span class="codeline" id="line-189"><code><span class="comment">//   - the strides differ or there is an overlap in the used data elements.</span></code></span>
<span class="codeline" id="line-190"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-191"><code><span class="comment">// If such an overlap is detected, the method will panic.</span></code></span>
<span class="codeline" id="line-192"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-193"><code><span class="comment">// The following cases will not panic:</span></code></span>
<span class="codeline" id="line-194"><code><span class="comment">//   - the data slices do not overlap,</span></code></span>
<span class="codeline" id="line-195"><code><span class="comment">//   - there is pointer identity between the receiver and input values after</span></code></span>
<span class="codeline" id="line-196"><code><span class="comment">//     the value has been untransposed if necessary.</span></code></span>
<span class="codeline" id="line-197"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-198"><code><span class="comment">// mat will not attempt to detect element overlap if the input does not implement a</span></code></span>
<span class="codeline" id="line-199"><code><span class="comment">// Raw method. Method behavior is undefined if there is undetected overlap.</span></code></span></div><span class="codeline" id="line-200"><code><span class="keyword">package</span> mat <span class="comment">// import "gonum.org/v1/gonum/mat"</span></code></span>
</pre><pre id="footer">
<table><tr><td><img src="../../../../../png/go101-twitter.png"></td>
<td>The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.6.7</i>. (GOOS=linux GOARCH=amd64)
<b>Golds</b> is a <a href="https://go101.org">Go 101</a> project developed by <a href="https://tapirgames.com">Tapir Liu</a>.
PR and bug reports are welcome and can be submitted to <a href="https://github.com/go101/golds">the issue list</a>.
Please follow <a href="https://twitter.com/go100and1">@Go100and1</a> (reachable from the left QR code) to get the latest news of <b>Golds</b>.</td></tr></table></pre>